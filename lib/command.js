// Generated by LiveScript 1.6.0
var LiveScript, path, fs, util, prelude, each, breakList, ref$, parseOptions, generateHelp, nameFromPath, version, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
LiveScript = require('..');
path = require('path');
fs = require('fs');
util = require('util');
prelude = require('prelude-ls'), each = prelude.each, breakList = prelude.breakList;
ref$ = require('./options'), parseOptions = ref$.parse, generateHelp = ref$.generateHelp;
nameFromPath = require('./util').nameFromPath;
version = LiveScript.VERSION;
(function(it){
  return module.exports = it;
})(function(args, arg$){
  var ref$, say, sayWithTimestamp, warn, die, o, positional, e, validMapValues, that, filename, jsonCallback;
  ref$ = arg$ != null
    ? arg$
    : {}, say = ref$.say, sayWithTimestamp = ref$.sayWithTimestamp, warn = ref$.warn, die = ref$.die;
  say == null && (say = console.log);
  sayWithTimestamp == null && (sayWithTimestamp = util.log);
  warn == null && (warn = console.error);
  die == null && (die = function(message){
    console.error(message);
    process.exit(1);
  });
  try {
    o = parseOptions(args);
    positional = o._;
  } catch (e$) {
    e = e$;
    die(e.message);
  }
  switch (false) {
  case !o.nodejs:
    forkNode();
    break;
  case !o.version:
    say("LiveScript version " + version);
    break;
  case !o.help:
    say(generateHelp({
      interpolate: {
        version: version
      }
    }));
    break;
  default:
    o.compile || (o.compile = o.output);
    o.run = !(o.compile || o.ast || o.tokens || o.lex);
    if (o.map != null) {
      validMapValues = ['none', 'linked', 'linked-src', 'embedded', 'debug'];
      if (!in$(o.map, validMapValues)) {
        die("Option --map must be either: " + validMapValues.join(', '));
      }
    } else {
      o.map = o.run ? 'embedded' : 'none';
    }
    if (o.run && args === process.argv) {
      process.argv.lsc = o.stdin || o.eval
        ? [void 8].concat(arrayFrom$(positional))
        : [positional[0]].concat(arrayFrom$(positional.splice(1)));
    }
    if (that = o.require) {
      filename = module.filename;
      module.filename = '.';
      each(function(it){
        return global[nameFromPath(it)] = require(it);
      })(
      that);
      module.filename = filename;
    }
    switch (false) {
    case !o.eval:
      jsonCallback = function(input){
        if (o.prelude) {
          import$(global, prelude);
        }
        o.runContext = JSON.parse(input.toString());
        compileScript('', o.eval);
      };
      if (positional.length && (o.json || /\.json$/.test(positional[0]))) {
        o.json = true;
        fshoot('readFile', positional[0], jsonCallback);
      } else if (o.json && o.run) {
        getStdin(jsonCallback);
      } else {
        compileScript('', o.eval);
      }
      break;
    case !o.stdin:
      compileStdin();
      break;
    case !positional.length:
      compileScripts();
      break;
    case !require('tty').isatty(0):
      say("LiveScript " + version + " - use 'lsc --help' for more information");
      require('./repl')(o);
      break;
    default:
      compileStdin();
    }
  }
  function fshoot(name, arg, callback){
    fs[name](arg, function(e, result){
      if (e) {
        die(e.stack || e);
      }
      callback(result);
    });
  }
  function compileScripts(){
    positional.forEach(function(it){
      walk(it, path.normalize(it), true);
    });
    function walk(source, base, top){
      function work(){
        fshoot('readFile', source, function(it){
          compileScript(source, it + "", base);
        });
      }
      fs.stat(source, function(e, stats){
        if (e) {
          if (!top || /(?:\.ls|\/)$/.test(source)) {
            die("Can't find: " + source);
          }
          walk(source + ".ls", base);
          return;
        }
        if (stats.isDirectory()) {
          if (!o.run) {
            fshoot('readdir', source, function(it){
              it.forEach(function(it){
                walk(source + "/" + it, base);
              });
            });
            return;
          }
          source += '/index.ls';
        }
        if (top || '.ls' === source.slice(-3)) {
          if (o.watch) {
            watch(source, work);
          } else {
            work();
          }
        }
      });
    }
  }
  function compileScript(filename, input, base){
    var options, t, json, run, print, ref$, e;
    options = {
      filename: filename,
      outputFilename: outputFilename(filename, o.json),
      bare: o.bare,
      'const': o['const'],
      map: o.map,
      header: o.header,
      warn: o.warn
    };
    t = {
      input: input,
      options: options
    };
    try {
      if (o.lex || o.tokens || o.ast) {
        LiveScript.emit('lex', t);
        t.tokens = LiveScript.tokens(t.input, {
          raw: o.lex
        });
        if (o.lex || o.tokens) {
          printTokens(t.tokens);
          throw null;
        }
        LiveScript.emit('parse', t);
        t.ast = LiveScript.ast(t.tokens);
        say(o.json
          ? t.ast.stringify(2)
          : ''.trim.call(t.ast));
        throw null;
      }
      json = o.json || /\.json\.ls$/.test(filename);
      run = o.run || (json && o.print);
      if (run) {
        LiveScript.emit('compile', t);
        print = json || o.print;
        t.output = LiveScript.compile(t.input, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$.run = run, ref$.print = print, ref$));
        LiveScript.emit('run', t);
        require('source-map-support').install({
          hookRequire: true
        });
        t.result = LiveScript.run(o.map === 'none'
          ? t.output
          : t.output.code, options, {
          js: true,
          context: o.runContext
        });
        switch (false) {
        case !json:
          say(JSON.stringify(t.result, null, 2));
          break;
        case !o.print:
          say(t.result);
        }
        throw null;
      }
      LiveScript.emit('compile', t);
      t.output = LiveScript.compile(t.input, (ref$ = {}, import$(ref$, options), ref$.json = json, ref$.print = o.print, ref$));
      LiveScript.emit('write', t);
      if (o.print || !filename) {
        say((o.map === 'none'
          ? t.output
          : t.output.code).trimRight());
      } else {
        writeJS(filename, t.output, t.input, base, json);
      }
    } catch (e$) {
      e = e$;
      if (e != null) {
        if (LiveScript.listeners('failure').length) {
          LiveScript.emit('failure', e, t);
        } else {
          if (filename) {
            warn("Failed at: " + filename);
          }
          if (!(e instanceof SyntaxError || /^Parse error /.test(e.message))) {
            e = e.stack || e;
          }
          if (o.watch) {
            warn(e + '\x07');
          } else {
            die(e);
          }
        }
        return;
      }
    }
    LiveScript.emit('success', t);
  }
  function getStdin(cb){
    var x$, code;
    x$ = process.openStdin();
    code = '';
    x$.on('data', function(it){
      code += it;
    });
    x$.on('end', function(){
      cb(code);
    });
    x$.on('data', function(){
      var ref$;
      if ((ref$ = code.slice(-3)) === '\x04\r\n' || ref$ === '\x1a\r\n') {
        cb(code.slice(0, -3));
        x$.destroy();
      }
    });
  }
  function compileStdin(){
    getStdin(function(input){
      compileScript('', input);
    });
  }
  function watch(source, action){
    (function repeat(ptime){
      fshoot('stat', source, function(arg$){
        var mtime;
        mtime = arg$.mtime;
        if (ptime ^ mtime) {
          action();
        }
        setTimeout(repeat, 500, mtime);
      });
    }.call(this, 0));
  }
  function writeJS(source, js, input, base, json){
    var filename, dir, that, jsPath;
    filename = outputFilename(source, json);
    dir = path.dirname(source);
    if (that = o.output) {
      dir = path.join(that, dir.slice(base === '.'
        ? 0
        : base.length));
    }
    source = path.normalize(source);
    jsPath = path.join(dir, filename);
    function compile(){
      fs.writeFile(jsPath, js.toString() || '\n', function(e){
        if (e) {
          return warn(e);
        }
        if (o.watch || o.debug) {
          sayWithTimestamp(source + " => " + jsPath);
        }
      });
    }
    function compileWithMap(){
      fs.writeFile(jsPath, js.code || '\n', function(e){
        var mapPath;
        if (e) {
          return warn(e);
        }
        if (o.map === 'linked' || o.map === "debug") {
          mapPath = jsPath + ".map";
          fs.writeFile(mapPath, js.map.toString() || '\n', function(e2){
            if (e2) {
              return warn(e2);
            }
            if (o.map === "debug") {
              fs.writeFile(mapPath + ".debug", js.debug || '\n', function(e3){
                if (o.watch || o.debug) {
                  sayWithTimestamp(source + " => " + jsPath + ", " + mapPath + "[.debug]");
                }
              });
            } else {
              if (o.watch || o.debug) {
                sayWithTimestamp(source + " => " + jsPath + ", " + mapPath);
              }
            }
          });
        } else {
          if (o.watch || o.debug) {
            sayWithTimestamp(source + " => " + jsPath);
          }
        }
      });
    }
    fs.stat(dir, function(e){
      if (o.map !== 'none') {
        if (!e) {
          return compileWithMap();
        }
      } else {
        if (!e) {
          return compile();
        }
      }
      require('child_process').exec("mkdir " + [!/^win/.test(process.platform) ? '-p' : void 8] + " " + dir, compile);
    });
  }
  function outputFilename(filename, json){
    return path.basename(filename).replace(/(?:(\.\w+)?\.\w+)?$/, function(){
      return arguments[1] || (json ? '.json' : '.js');
    });
  }
  function printTokens(tokens){
    var lines, i$, len$, ref$, tag, val, lno, l;
    lines = [];
    for (i$ = 0, len$ = tokens.length; i$ < len$; ++i$) {
      ref$ = tokens[i$], tag = ref$[0], val = ref$[1], lno = ref$[2];
      ((ref$ = lines[lno]) != null
        ? ref$
        : lines[lno] = []).push(tag.toLowerCase() === val
        ? tag
        : tag + ":" + val);
    }
    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
      l = lines[i$];
      say(l ? l.join(' ').replace(/\n/g, '\\n') : '');
    }
  }
  function forkNode(){
    var ref$, args, lsArgs, ref1$, nodeArgs;
    ref$ = process.argv, args = slice$.call(ref$, 1);
    ref$ = breakList((function(it){
      return it === '--nodejs' || it === '-n';
    }), args), lsArgs = ref$[0], ref1$ = ref$[1], nodeArgs = slice$.call(ref1$, 1);
    require('child_process').spawn(process.execPath, nodeArgs.concat(lsArgs), {
      cwd: process.cwd(),
      stdio: 'inherit'
    });
  }
});
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}