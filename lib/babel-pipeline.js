// Generated by LiveScript 1.4.0
var lsASTDefs, babel, lsNodeTypes, lsNodeToBabelNode, convertorsByType, out$ = typeof exports != 'undefined' && exports || this;
lsASTDefs = require('./ast');
babel = require('babel-core/lib/api/browser');
lsNodeTypes = Object.keys(lsASTDefs).filter(function(it){
  return it.match(/^[A-Z]+/) != null;
});
function simplifyLsNode(lsNode){
  var simplifiedNode, key, val, ref$, own$ = {}.hasOwnProperty;
  simplifiedNode = {
    __original: lsNode,
    type: lsNode.constructor.name,
    loc: {
      start: {
        column: lsNode.first_column,
        line: lsNode.first_line
      },
      end: {
        column: lsNode.last_column,
        line: lsNode.last_line
      }
    }
  };
  for (key in lsNode) if (own$.call(lsNode, key)) {
    val = lsNode[key];
    if (key === 'column' || key === 'line' || key === 'first_column' || key === 'first_line' || key === 'last_column' || key === 'last_line') {
      continue;
    }
    if (Array.isArray(val)) {
      simplifiedNode[key] = val.map(simplifyLsNode);
    } else if (val == null || ((ref$ = typeof val) === 'string' || ref$ === 'number' || ref$ === 'boolean')) {
      simplifiedNode[key] = val;
    } else if (in$(val.constructor.name, lsNodeTypes)) {
      simplifiedNode[key] = simplifyLsNode(val);
    } else {
      throw "Not sure what to do with this pair";
    }
  }
  return simplifiedNode;
}
out$.lsASTToBabelAST = lsASTToBabelAST;
function lsASTToBabelAST(code){
  var rootLSNode;
  rootLSNode = simplifyLsNode(code);
  return {
    type: 'File',
    comments: [],
    tokens: [],
    loc: rootLSNode.loc,
    start: null,
    end: null,
    program: {
      type: 'Program',
      sourceType: 'module',
      directives: [],
      loc: rootLSNode.loc,
      start: null,
      end: null,
      body: rootLSNode.lines.map(lsNodeToBabelNode)
    }
  };
}
lsNodeToBabelNode = function(lsNode){
  return import$({
    loc: lsNode.loc
  }, convertorsByType[lsNode.type](lsNode));
};
convertorsByType = {
  Block: function(lsNode){
    return {
      type: 'BlockStatement',
      body: lsNode.lines.map(lsNodeToBabelNode)
    };
  },
  Fun: function(lsNode){
    var node;
    node = {
      type: 'FunctionDeclaration',
      id: {
        type: 'Identifier',
        name: lsNode.name,
        start: null,
        end: null,
        loc: {
          start: lsNode.loc.start,
          end: {
            column: lsNode.loc.start.column + lsNode.name.length,
            line: lsNode.loc.start.column
          }
        }
      },
      generator: false,
      expression: false,
      params: lsNode.params.map(function(it){
        return {
          type: 'Identifier',
          loc: it.loc,
          start: null,
          end: null,
          name: it.value
        };
      }),
      body: lsNodeToBabelNode(
      lsNode.body)
    };
    return node;
  },
  Binary: function(lsNode){
    return {
      type: 'BinaryExpression',
      operator: lsNode.op,
      left: lsNodeToBabelNode(lsNode.first),
      right: lsNodeToBabelNode(lsNode.second)
    };
  },
  Var: function(lsNode){
    return {
      type: 'Identifier',
      name: lsNode.value
    };
  }
};
out$.compile = compile;
function compile(lsAst, code, opts){
  var ast;
  ast = lsASTToBabelAST(lsAst);
  return babel.transformFromAst(ast, code, opts);
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}