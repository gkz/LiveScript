// Generated by LiveScript 1.6.0
var fold, ref$, nameFromPath, stripString, SourceNode, SourceMapGenerator, sn, snEmpty, snSafe, snRemoveLeft, Node, Negatable, Block, Atom, Literal, Var, Key, Index, Slice, Chain, Call, List, Obj, Prop, Arr, Yield, Unary, Binary, Assign, Import, In, Existence, Fun, Class, Super, Parens, Splat, Jump, Throw, Return, While, For, StepSlice, Try, Switch, Case, If, Label, Cascade, JS, Require, Util, Vars, CopyL, DECLS, UTILS, LEVEL_TOP, LEVEL_PAREN, LEVEL_LIST, LEVEL_COND, LEVEL_OP, LEVEL_CALL, PREC, TAB, ID, SIMPLENUM, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);}, toString$ = {}.toString;
fold = require('prelude-ls').fold;
ref$ = require('./util'), nameFromPath = ref$.nameFromPath, stripString = ref$.stripString;
ref$ = require('source-map'), SourceNode = ref$.SourceNode, SourceMapGenerator = ref$.SourceMapGenerator;
sn = function(node){
  var parts, res$, i$, to$, result, e;
  node == null && (node = {});
  res$ = [];
  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  parts = res$;
  try {
    result = new SourceNode(node.line, node.column, null, parts);
    result.displayName = node.constructor.displayName;
    return result;
  } catch (e$) {
    e = e$;
    console.dir(parts);
    throw e;
  }
};
snEmpty = function(node){
  var i$, ref$, len$, child;
  if (node instanceof SourceNode) {
    for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {
      child = ref$[i$];
      if (!snEmpty(child)) {
        return false;
      }
    }
    return true;
  } else {
    return !node;
  }
};
snSafe = function(code){
  if (code instanceof SourceNode) {
    return code;
  } else {
    return code.toString();
  }
};
snRemoveLeft = function(node, count){
  var i$, to$, i, child;
  for (i$ = 0, to$ = node.children.length; i$ < to$; ++i$) {
    i = i$;
    child = node.children[i];
    if (child instanceof SourceNode) {
      count = snRemoveLeft(child, count);
    } else {
      child = child.toString();
      node.children[i] = child.slice(count);
      count -= child.length;
    }
    if (count <= 0) {
      return 0;
    }
  }
  return count;
};
SourceNode.prototype.replace = function(){
  var args, res$, i$, to$;
  res$ = [];
  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  args = res$;
  return new SourceNode(this.line, this.column, this.source, (function(){
    var i$, x$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      results$.push(x$.replace.apply(x$, args));
    }
    return results$;
  }.call(this)), this.name);
};
SourceNode.prototype.setFile = function(filename){
  var i$, ref$, len$, child, results$ = [];
  this.source = filename;
  for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
    child = ref$[i$];
    if (child instanceof SourceNode) {
      results$.push(child.setFile(filename));
    }
  }
  return results$;
};
SourceNode.prototype.toStringWithSourceMap = function(){
  var args, res$, i$, to$, gen, genLine, genColumn, stack, code, debugOutput, debugIndent, debugIndentStr, genForNode;
  res$ = [];
  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  args = res$;
  gen = (function(func, args, ctor) {
    ctor.prototype = func.prototype;
    var child = new ctor, result = func.apply(child, args), t;
    return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(SourceMapGenerator, args, function(){});
  genLine = 1;
  genColumn = 0;
  stack = [];
  code = '';
  debugOutput = '';
  debugIndent = '';
  debugIndentStr = '  ';
  genForNode = function(node){
    var valid, i$, ref$, len$, child, cur, to$, i, c, results$ = [];
    if (node instanceof SourceNode) {
      debugOutput += debugIndent + node.displayName;
      valid = node.line && 'column' in node;
      if (valid) {
        stack.push(node);
        debugOutput += '!';
      }
      debugOutput += " " + node.line + ":" + node.column + " " + genLine + ":" + genColumn + "\n";
      debugIndent += debugIndentStr;
      for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {
        child = ref$[i$];
        genForNode(child);
      }
      debugIndent = debugIndent.slice(0, debugIndent.length - debugIndentStr.length);
      if (valid) {
        return stack.pop();
      }
    } else {
      debugOutput += debugIndent + "" + JSON.stringify(node) + "\n";
      code += node;
      cur = stack[stack.length - 1];
      if (cur) {
        gen.addMapping({
          source: cur.source,
          original: {
            line: cur.line,
            column: cur.column
          },
          generated: {
            line: genLine,
            column: genColumn
          },
          name: cur.name
        });
      }
      for (i$ = 0, to$ = node.length; i$ < to$; ++i$) {
        i = i$;
        c = node.charAt(i);
        if (c === "\n") {
          genColumn = 0;
          ++genLine;
          if (cur) {
            results$.push(gen.addMapping({
              source: cur.source,
              original: {
                line: cur.line,
                column: cur.column
              },
              generated: {
                line: genLine,
                column: genColumn
              },
              name: cur.name
            }));
          }
        } else {
          results$.push(++genColumn);
        }
      }
      return results$;
    }
  };
  genForNode(this);
  return {
    code: code,
    map: gen,
    debug: debugOutput
  };
};
/* # Use this to track down places where a SourceNode is being converted into a string and causing the location to be lost
tmp-to-string = SourceNode::to-string
SourceNode::to-string = (...args) ->
    console.log("toString(): ", new Error().stack)
    tmp-to-string.apply this, args
*/
(Node = function(){
  throw Error('unimplemented');
}).prototype = {
  compile: function(options, level){
    var o, node, code, that, i$, len$, tmp;
    o = import$({}, options);
    if (level != null) {
      o.level = level;
    }
    node = this.unfoldSoak(o) || this;
    if (o.level && node.isStatement()) {
      return node.compileClosure(o);
    }
    code = (node.tab = o.indent, node).compileNode(o);
    if (that = node.temps) {
      for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
        tmp = that[i$];
        o.scope.free(tmp);
      }
    }
    return code;
  },
  compileClosure: function(o){
    var that, fun, call, hasArgs, hasThis, out;
    if (that = this.getJump()) {
      that.carp('inconvertible statement');
    }
    fun = Fun([], Block(this));
    call = Call();
    if (o.inAsync) {
      fun.async = true;
    }
    if (o.inGenerator) {
      fun.generator = true;
    }
    this.traverseChildren(function(it){
      switch (it.value) {
      case 'this':
        hasThis = true;
        break;
      case 'arguments':
        hasArgs = it.value = 'args$';
      }
    });
    if (hasThis) {
      call.args.push(Literal('this'));
      call.method = '.call';
    }
    if (hasArgs) {
      call.args.push(Literal('arguments'));
      fun.params.push(Var('args$'));
    }
    out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
    if (o.inGenerator) {
      out = new Yield('yieldfrom', out);
    } else if (o.inAsync) {
      out = new Yield('await', out);
    }
    return out.compile(o);
  },
  compileBlock: function(o, node){
    var code;
    if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
      return sn(null, "{\n", code, "\n" + this.tab + "}");
    } else {
      return sn(node, '{}');
    }
  },
  compileSpreadOver: function(o, list, transform){
    var ob, them, i$, len$, i, node, sp, lat, ref$;
    ob = list instanceof Obj;
    them = list.items;
    for (i$ = 0, len$ = them.length; i$ < len$; ++i$) {
      i = i$;
      node = them[i$];
      if (sp = node instanceof Splat) {
        node = node.it;
      }
      if (ob && !sp) {
        node = node.val;
      }
      node = transform(node);
      if (sp) {
        node = lat = Splat(node);
      }
      if (ob && !sp) {
        them[i].val = node;
      } else {
        them[i] = node;
      }
    }
    if (!lat && (this['void'] || !o.level)) {
      list = (ref$ = Block(ob ? (function(){
        var i$, x$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = them).length; i$ < len$; ++i$) {
          x$ = ref$[i$];
          results$.push(x$.val);
        }
        return results$;
      }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
    }
    return list.compile(o, LEVEL_PAREN);
  },
  cache: function(o, once, level, tempName){
    var ref$, ref, sub, tempvars;
    if (!this.isComplex()) {
      return [ref$ = level != null ? this.compile(o, level) : this, ref$];
    }
    if (ref = this.getRef()) {
      sub = this;
    } else {
      sub = Assign(ref = Var(o.scope.temporary(tempName)), this);
      if (once) {
        ref.temp = true;
      } else {
        tempvars = [ref.value];
      }
    }
    if (level != null) {
      sub = sub.compile(o, level);
      if (once && tempvars) {
        o.scope.free(ref.value);
      }
      return [sub, ref.value];
    }
    return [sub, ref, tempvars];
  },
  compileLoopReference: function(o, name, ret, safeAccess){
    var ref$, code, asn, tmp;
    if (this instanceof Var && o.scope.check(this.value) || this instanceof Unary && ((ref$ = this.op) === '+' || ref$ === '-') && (-1 / 0 < (ref$ = +this.it.value) && ref$ < 1 / 0) || this instanceof Literal && !this.isComplex()) {
      code = this.compile(o, LEVEL_PAREN);
      if (safeAccess && !(this instanceof Var)) {
        code = "(" + code + ")";
      }
      return [code, code];
    }
    asn = Assign(Var(tmp = o.scope.temporary(name)), this);
    ret || (asn['void'] = true);
    return [tmp, asn.compile(o, ret ? LEVEL_CALL : LEVEL_PAREN)];
  },
  eachChild: function(fn){
    var i$, ref$, len$, name, child, j$, len1$, i, node, that;
    for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
      name = ref$[i$];
      if (child = this[name]) {
        if ('length' in child) {
          for (j$ = 0, len1$ = child.length; j$ < len1$; ++j$) {
            i = j$;
            node = child[j$];
            if (that = fn(node, name, i)) {
              return that;
            }
          }
        } else {
          if ((that = fn(child, name)) != null) {
            return that;
          }
        }
      }
    }
  },
  traverseChildren: function(fn, xscope){
    var this$ = this;
    return this.eachChild(function(node, name, index){
      var ref$;
      return (ref$ = fn(node, this$, name, index)) != null
        ? ref$
        : node.traverseChildren(fn, xscope);
    });
  },
  rewriteShorthand: function(o, assign){
    var i$, ref$, len$, name, child, j$, len1$, i, node, that;
    for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
      name = ref$[i$];
      if (child = this[name]) {
        if ('length' in child) {
          for (j$ = 0, len1$ = child.length; j$ < len1$; ++j$) {
            i = j$;
            node = child[j$];
            if (that = node.rewriteShorthand(o, assign)) {
              child[i] = that;
            }
          }
        } else if (that = child.rewriteShorthand(o, assign)) {
          this[name] = that;
        }
      }
    }
  },
  anaphorize: function(){
    var base, name, ref$;
    this.children = this.aTargets;
    if (this.eachChild(hasThat)) {
      if ((base = this)[name = this.aSource] instanceof Existence) {
        base[name].doAnaphorize = true;
      } else if (base[name].value !== 'that') {
        base[name] = Assign(Var('that'), base[name]);
      }
    }
    function hasThat(it){
      var that;
      return it.value === 'that' || ((that = it.aSource)
        ? (that = it[that]) ? hasThat(that) : void 8
        : it.eachChild(hasThat));
    }
    delete this.children;
    return ref$ = this[this.aSource], ref$.cond = true, ref$;
  },
  carp: function(msg, type){
    type == null && (type = SyntaxError);
    throw type(msg + " " + this.lineMsg());
  },
  warn: function(msg){
    if (typeof console != 'undefined' && console !== null) {
      console.warn("WARNING: " + msg + " " + this.lineMsg());
    }
  },
  lineMsg: function(){
    return "on line " + (this.line || this.traverseChildren(function(it){
      return it.line;
    }));
  },
  delegate: function(names, fn){
    var i$, len$;
    for (i$ = 0, len$ = names.length; i$ < len$; ++i$) {
      (fn$.call(this, names[i$]));
    }
    function fn$(name){
      this[name] = function(it){
        return fn.call(this, name, it);
      };
    }
  },
  children: [],
  terminator: ';',
  isComplex: YES,
  isStatement: NO,
  isAssignable: NO,
  isCallable: NO,
  isEmpty: NO,
  isArray: NO,
  isString: NO,
  isRegex: NO,
  isMatcher: function(){
    return this.isString() || this.isRegex();
  },
  assigns: NO,
  ripName: VOID,
  getRef: VOID,
  unfoldSoak: VOID,
  unfoldAssign: VOID,
  unparen: THIS,
  unwrap: THIS,
  maybeKey: VOID,
  varName: String,
  getAccessors: VOID,
  getCall: VOID,
  getDefault: VOID,
  getJump: VOID,
  isNextUnreachable: NO,
  extractKeyRef: function(o, assign){
    return this.maybeKey() || this.carp(assign ? "invalid assign" : "invalid property shorthand");
  },
  invert: function(){
    return Unary('!', this, true);
  },
  invertCheck: function(it){
    if (it.inverted) {
      return this.invert();
    } else {
      return this;
    }
  },
  addElse: function($else){
    this['else'] = $else;
    return this;
  },
  makeReturn: function(ref, obj){
    var items, kv, i, v;
    if (obj) {
      items = this instanceof Arr
        ? (this.items[0] == null || this.items[1] == null && this.carp('must specify both key and value for object comprehension'), this.items)
        : (kv = 'keyValue$', (function(){
          var i$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ < len$; ++i$) {
            i = i$;
            v = ref$[i$];
            results$.push(Chain(v).add(Index(Literal(i))));
          }
          return results$;
        }.call(this)));
      return Assign(Chain(Var(ref)).add(Index(items[0], '.', true)), items[1]);
    } else if (ref) {
      return Call.make(JS(ref + '.push'), [this]);
    } else {
      return Return(this);
    }
  },
  show: String,
  toString: function(idt){
    var tree, that;
    idt || (idt = '');
    tree = '\n' + idt + this.constructor.displayName;
    if (that = this.show()) {
      tree += ' ' + that;
    }
    this.eachChild(function(it){
      tree += it.toString(idt + TAB);
    });
    return tree;
  },
  stringify: function(space){
    return JSON.stringify(this, null, space);
  },
  toJSON: function(){
    return import$({
      type: this.constructor.displayName
    }, this);
  }
};
exports.parse = function(json){
  return exports.fromJSON(JSON.parse(json));
};
exports.fromJSON = (function(){
  function fromJSON(it){
    var that, node, key, val, i$, len$, v, results$ = [];
    if (!(it && typeof it === 'object')) {
      return it;
    }
    if (that = it.type) {
      node = clone$(exports[that].prototype);
      for (key in it) {
        val = it[key];
        node[key] = fromJSON(val);
      }
      return node;
    }
    if (it.length != null) {
      for (i$ = 0, len$ = it.length; i$ < len$; ++i$) {
        v = it[i$];
        results$.push(fromJSON(v));
      }
      return results$;
    } else {
      return it;
    }
  }
  return fromJSON;
}());
Negatable = {
  show: function(){
    return this.negated && '!';
  },
  invert: function(){
    this.negated = !this.negated;
    return this;
  }
};
exports.Block = Block = (function(superclass){
  var prototype = extend$((import$(Block, superclass).displayName = 'Block', Block), superclass).prototype, constructor = Block;
  function Block(body){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    body || (body = []);
    if ('length' in body) {
      this$.lines = body;
    } else {
      this$.lines = [];
      this$.add(body);
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Block.prototype.children = ['lines'];
  Block.prototype.toJSON = function(){
    delete this.back;
    return superclass.prototype.toJSON.call(this);
  };
  Block.prototype.add = function(it){
    var that, ref$;
    it = it.unparen();
    switch (false) {
    case !(that = this.back):
      that.add(it);
      break;
    case !(that = it.lines):
      (ref$ = this.lines).push.apply(ref$, that);
      break;
    default:
      this.lines.push(it);
      if (that = (ref$ = it.back, delete it.back, ref$)) {
        this.back = that;
      }
    }
    return this;
  };
  Block.prototype.prepend = function(){
    var ref$;
    (ref$ = this.lines).splice.apply(ref$, [this.neck(), 0].concat(arrayFrom$(arguments)));
    return this;
  };
  Block.prototype.pipe = function(target, type){
    var args;
    args = type === '|>' ? this.lines.pop() : target;
    if (toString$.call(args).slice(8, -1) !== 'Array') {
      args = [args];
    }
    switch (type) {
    case '|>':
      this.lines.push(Call.make(target, args, {
        pipe: true
      }));
      break;
    case '<|':
      this.lines.push(Call.make(this.lines.pop(), args));
    }
    return this;
  };
  Block.prototype.unwrap = function(){
    if (this.lines.length === 1) {
      return this.lines[0];
    } else {
      return this;
    }
  };
  Block.prototype.chomp = function(){
    var lines, i, that;
    lines = this.lines;
    i = lines.length;
    while (that = lines[--i]) {
      if (!that.comment) {
        break;
      }
    }
    lines.length = i + 1;
    return this;
  };
  Block.prototype.neck = function(){
    var pos, i$, ref$, len$, x;
    pos = 0;
    for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (!(x.comment || x instanceof Literal)) {
        break;
      }
      ++pos;
    }
    return pos;
  };
  Block.prototype.isComplex = function(){
    var ref$;
    return this.lines.length > 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
  };
  prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){
    var ref$, ref1$;
    return (ref$ = (ref1$ = this.lines)[ref1$.length - 1]) != null ? ref$[it]() : void 8;
  });
  Block.prototype.getJump = function(it){
    var i$, ref$, len$, node, that;
    for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (that = node.getJump(it)) {
        return that;
      }
    }
  };
  Block.prototype.isNextUnreachable = function(){
    var i$, ref$, len$, node;
    for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (node.isNextUnreachable()) {
        return true;
      }
    }
    return false;
  };
  Block.prototype.makeReturn = function(){
    var that, ref$, key$;
    this.chomp();
    if (that = (ref$ = this.lines)[key$ = ref$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref$, arguments) : void 8) {
      if (that instanceof Return && !that.it) {
        --this.lines.length;
      }
    }
    return this;
  };
  Block.prototype.compile = function(o, level){
    var tab, codes, i$, ref$, len$, node, that, code;
    level == null && (level = o.level);
    if (level) {
      return this.compileExpressions(o, level);
    }
    o.block = this;
    tab = o.indent;
    codes = [];
    for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (that = node.rewriteShorthand(o)) {
        node = that;
      }
      node = node.unfoldSoak(o) || node;
      if (snEmpty(code = (node.front = true, node).compile(o, level))) {
        continue;
      }
      codes.push(tab);
      codes.push(code);
      node.isStatement() || codes.push(node.terminator);
      codes.push('\n');
    }
    codes.pop();
    return sn.apply(null, [null].concat(arrayFrom$(codes)));
  };
  Block.prototype.compileRoot = function(options){
    var o, that, ref$, bare, prefix, ref1$, ref2$, comment, ref3$, code;
    o = (import$({
      level: LEVEL_TOP,
      scope: this.scope = Scope.root = new Scope
    }, options));
    if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {
      this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);
    }
    delete o.filename;
    o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? '' : TAB;
    if (/^\s*(?:#!|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
      prefix = this.lines.shift().code + '\n';
    }
    if (((ref1$ = this.lines[0]) != null ? (ref2$ = ref1$.code) != null ? ref2$[0] : void 8 : void 8) === '/') {
      comment = this.lines.shift().code + '\n';
    }
    if ((ref3$ = o.eval, delete o.eval, ref3$) && this.chomp().lines.length) {
      if (bare) {
        this.lines.push(Parens(this.lines.pop()));
      } else {
        this.makeReturn();
      }
    }
    code = [this.compileWithDeclarations(o)];
    bare || (code = ["(function(){\n"].concat(arrayFrom$(code), ["\n}).call(this);\n"]));
    return sn(null, prefix || [], options.header || [], comment || [], code);
  };
  Block.prototype.compileWithDeclarations = function(o){
    var pre, i, rest, post, that;
    o.level = LEVEL_TOP;
    pre = [];
    if (i = this.neck()) {
      rest = this.lines.splice(i, 9e9);
      pre = [this.compile(o), "\n"];
      this.lines = rest;
    }
    if (snEmpty(post = this.compile(o))) {
      return sn(this, pre[0] || []);
    }
    return sn.apply(null, [null].concat(arrayFrom$(pre), [(that = this.scope) ? that.emit(post, o.indent) : post]));
  };
  Block.prototype.compileExpressions = function(o, level){
    var lines, i, that, line, code, last, i$, len$, node;
    lines = this.chomp().lines;
    i = -1;
    while (that = lines[++i]) {
      if (that.comment) {
        lines.splice(i--, 1);
      }
    }
    if (!lines.length) {
      lines.push(Literal('void'));
    }
    lines[0].front = this.front;
    lines[lines.length - 1]['void'] = this['void'];
    if (!lines[1]) {
      line = lines[0];
      if (that = line.rewriteShorthand(o)) {
        line = that;
      }
      return line.compile(o, level);
    }
    code = [];
    last = lines.pop();
    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
      node = lines[i$];
      if (that = node.rewriteShorthand(o)) {
        node = that;
      }
      code.push((node['void'] = true, node).compile(o, LEVEL_PAREN), ', ');
    }
    if (that = last.rewriteShorthand(o)) {
      last = that;
    }
    code.push(last.compile(o, LEVEL_PAREN));
    if (level < LEVEL_LIST) {
      return sn.apply(null, [null].concat(arrayFrom$(code)));
    } else {
      return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
    }
  };
  Block.prototype.rewriteShorthand = VOID;
  return Block;
}(Node));
Atom = (function(superclass){
  var prototype = extend$((import$(Atom, superclass).displayName = 'Atom', Atom), superclass).prototype, constructor = Atom;
  Atom.prototype.show = function(){
    return this.value;
  };
  Atom.prototype.isComplex = NO;
  function Atom(){
    Atom.superclass.apply(this, arguments);
  }
  return Atom;
}(Node));
exports.Literal = Literal = (function(superclass){
  var prototype = extend$((import$(Literal, superclass).displayName = 'Literal', Literal), superclass).prototype, constructor = Literal;
  function Literal(value){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.value = value;
    if (value.js) {
      return JS(value + "", true);
    }
    if (value === 'super') {
      return new Super;
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Literal.prototype.isEmpty = function(){
    var ref$;
    return (ref$ = this.value) === 'void' || ref$ === 'null';
  };
  Literal.prototype.isCallable = function(){
    var ref$;
    return (ref$ = this.value) === 'this' || ref$ === 'eval' || ref$ === '..';
  };
  Literal.prototype.isString = function(){
    return 0 <= '\'"'.indexOf((this.value + "").charAt());
  };
  Literal.prototype.isRegex = function(){
    return (this.value + "").charAt() === '/';
  };
  Literal.prototype.isComplex = function(){
    return this.isRegex() || this.value === 'debugger';
  };
  Literal.prototype.isWhat = function(){
    switch (false) {
    case !this.isEmpty():
      return 'empty';
    case !this.isCallable():
      return 'callable';
    case !this.isString():
      return 'string';
    case !this.isRegex():
      return 'regex';
    case !this.isComplex():
      return 'complex';
    default:

    }
  };
  Literal.prototype.varName = function(){
    if (/^\w+$/.test(this.value)) {
      return '$' + this.value;
    } else {
      return '';
    }
  };
  Literal.prototype.makeReturn = function(it){
    if (!it && this.value === 'debugger') {
      return this;
    } else {
      return superclass.prototype.makeReturn.apply(this, arguments);
    }
  };
  Literal.prototype.maybeKey = function(){
    var ref$;
    if (ID.test(this.value)) {
      return Key(this.value, (ref$ = this.value) !== 'arguments' && ref$ !== 'eval');
    } else {
      return this;
    }
  };
  Literal.prototype.compile = function(o, level){
    var val, ref$;
    level == null && (level = o.level);
    switch (val = this.value + "") {
    case 'this':
      return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);
    case 'void':
      if (!level) {
        return sn(this, '');
      }
      val += ' 8';
      // fallthrough
    case 'null':
      if (level === LEVEL_CALL) {
        this.carp('invalid use of ' + this.value);
      }
      break;
    case 'on':
    case 'yes':
      val = 'true';
      break;
    case 'off':
    case 'no':
      val = 'false';
      break;
    case '*':
      this.carp('stray star');
      break;
    case '..':
      if (!(val = o.ref)) {
        this.carp('stray reference');
      }
      this.cascadee || (val.erred = true);
      break;
    case 'debugger':
      if (level) {
        return sn(this, "(function(){ debugger; }())");
      }
    }
    return sn(this, snSafe(val));
  };
  return Literal;
}(Atom));
exports.Var = Var = (function(superclass){
  var prototype = extend$((import$(Var, superclass).displayName = 'Var', Var), superclass).prototype, constructor = Var;
  function Var(value){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.value = value;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  prototype.isAssignable = prototype.isCallable = YES;
  Var.prototype.assigns = function(){
    return [this.value];
  };
  Var.prototype.maybeKey = function(){
    var ref$;
    return ref$ = Key(this.value), ref$.line = this.line, ref$;
  };
  Var.prototype.varName = prototype.show;
  Var.prototype.compile = function(o){
    return sn(this, this.temp
      ? o.scope.free(this.value)
      : this.value);
  };
  return Var;
}(Atom));
exports.Key = Key = (function(superclass){
  var prototype = extend$((import$(Key, superclass).displayName = 'Key', Key), superclass).prototype, constructor = Key;
  function Key(name, reserved){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.reserved = reserved || name.reserved;
    this$.name = '' + name;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Key.prototype.isComplex = NO;
  Key.prototype.assigns = function(){
    return [this.name];
  };
  Key.prototype.maybeKey = THIS;
  Key.prototype.varName = function(){
    var name;
    name = this.name;
    if (this.reserved || (name === 'arguments' || name === 'eval')) {
      return "$" + name;
    } else {
      return name;
    }
  };
  Key.prototype.show = function(){
    if (this.reserved) {
      return "'" + this.name + "'";
    } else {
      return this.name;
    }
  };
  Key.prototype.compile = function(){
    return sn(this, this.show());
  };
  return Key;
}(Node));
exports.Index = Index = (function(superclass){
  var prototype = extend$((import$(Index, superclass).displayName = 'Index', Index), superclass).prototype, constructor = Index;
  function Index(key, symbol, init){
    var k, this$ = this instanceof ctor$ ? this : new ctor$;
    symbol || (symbol = '.');
    if (init && key instanceof Arr) {
      switch (key.items.length) {
      case 1:
        if (!((k = key.items[0]) instanceof Splat)) {
          key = Parens(k);
        }
      }
    }
    switch (symbol) {
    case '[]':
      this$.vivify = Arr;
      break;
    case '{}':
      this$.vivify = Obj;
      break;
    default:
      if ('=' === symbol.slice(-1)) {
        this$.assign = symbol.slice(1);
      }
    }
    this$.key = key;
    this$.symbol = symbol;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Index.prototype.children = ['key'];
  Index.prototype.show = function(){
    return [this.soak ? '?' : void 8] + this.symbol;
  };
  Index.prototype.isComplex = function(){
    return this.key.isComplex() || this.vivify != null;
  };
  Index.prototype.varName = function(){
    var ref$;
    return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) && this.key.varName();
  };
  Index.prototype.compile = function(o){
    var code;
    code = this.key.compile(o, LEVEL_PAREN);
    if (this.key instanceof Key && '\'' !== code.toString().charAt(0)) {
      return sn(this, ".", code);
    } else {
      return sn(this, "[", code, "]");
    }
  };
  return Index;
}(Node));
exports.Slice = Slice = (function(superclass){
  var prototype = extend$((import$(Slice, superclass).displayName = 'Slice', Slice), superclass).prototype, constructor = Slice;
  function Slice(arg$){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
    this$.from == null && (this$.from = Literal(0));
    if (this$.to && this$.type === 'to') {
      this$.to = Binary('+', this$.to, Literal('1'));
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Slice.prototype.children = ['target', 'from', 'to'];
  Slice.prototype.show = function(){
    return this.type;
  };
  Slice.prototype.compileNode = function(o){
    var args;
    if (this.to && this.type === 'to') {
      this.to = Binary('||', this.to, Literal('9e9'));
    }
    args = [this.target, this.from];
    if (this.to) {
      args.push(this.to);
    }
    return Chain(Var(util('slice'))).add(Index(Key('call'), '.', true)).add(Call(args)).compile(o);
  };
  return Slice;
}(Node));
exports.Chain = Chain = (function(superclass){
  var prototype = extend$((import$(Chain, superclass).displayName = 'Chain', Chain), superclass).prototype, constructor = Chain;
  function Chain(head, tails){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    if (!tails && head instanceof Chain) {
      return head;
    }
    this$.head = head;
    this$.tails = tails || [];
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Chain.prototype.children = ['head', 'tails'];
  Chain.prototype.add = function(it){
    var last, ref$, index, ref1$, bi, logics, call, f;
    if (this.tails.length) {
      last = (ref$ = this.tails)[ref$.length - 1];
      if (last instanceof Call && ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 && it.args.length === 1) {
        index = last.partialized[0].head.value;
        delete last.partialized;
        last.args[index] = it.args[0];
        return this;
      }
    }
    if (this.head instanceof Existence) {
      ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;
      it.soak = true;
    }
    this.tails.push(it);
    bi = this.head instanceof Parens && this.head.it instanceof Binary && !this.head.it.partial
      ? this.head.it
      : this.head instanceof Binary && !this.head.partial ? this.head : void 8;
    if (this.head instanceof Super) {
      if (!this.head.called && it instanceof Call && !it.method) {
        it.method = '.call';
        it.args.unshift(Literal('this'));
        this.head.called = true;
      } else if (!this.tails[1] && ((ref1$ = it.key) != null ? ref1$.name : void 8) === 'prototype') {
        this.head.sproto = true;
      }
    } else if (it instanceof Call && this.tails.length === 1 && bi && in$(bi.op, logics = ['&&', '||', 'xor'])) {
      call = it;
      f = function(x, key){
        var y;
        y = x[key];
        if (y instanceof Binary && in$(y.op, logics)) {
          f(y, 'first');
          return f(y, 'second');
        } else {
          return x[key] = Chain(y).autoCompare(call.args);
        }
      };
      f(bi, 'first');
      f(bi, 'second');
      return bi;
    }
    return this;
  };
  Chain.prototype.autoCompare = function(target){
    var test;
    if (!this.tails.length) {
      test = this.head;
    }
    switch (false) {
    case !(test instanceof Literal):
      return Binary('===', test, target[0]);
    case !(test instanceof Unary && test.it instanceof Literal):
      return Binary('===', test, target[0]);
    case !(test instanceof Arr || test instanceof Obj):
      return Binary('====', test, target[0]);
    case !(test instanceof Var && test.value === '_'):
      return Literal('true');
    default:
      return this.add(Call(target)) || [];
    }
  };
  Chain.prototype.flipIt = function(){
    this.flip = true;
    return this;
  };
  Chain.prototype.unwrap = function(){
    if (this.tails.length) {
      return this;
    } else {
      return this.head;
    }
  };
  prototype.delegate(['getJump', 'assigns', 'isStatement', 'isString'], function(it, arg){
    return !this.tails.length && this.head[it](arg);
  });
  Chain.prototype.isComplex = function(){
    return this.tails.length || this.head.isComplex();
  };
  Chain.prototype.isCallable = function(){
    var that, ref$;
    if (that = (ref$ = this.tails)[ref$.length - 1]) {
      return !((ref$ = that.key) != null && ref$.items);
    } else {
      return this.head.isCallable();
    }
  };
  Chain.prototype.isArray = function(){
    var that, ref$;
    if (that = (ref$ = this.tails)[ref$.length - 1]) {
      return that.key instanceof Arr;
    } else {
      return this.head.isArray();
    }
  };
  Chain.prototype.isRegex = function(){
    return this.head.value === 'RegExp' && !this.tails[1] && this.tails[0] instanceof Call;
  };
  Chain.prototype.isAssignable = function(){
    var tail, ref$, i$, len$;
    if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
      return this.head.isAssignable();
    }
    if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
      return false;
    }
    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
      tail = ref$[i$];
      if (tail.assign) {
        return false;
      }
    }
    return true;
  };
  Chain.prototype.isSimpleAccess = function(){
    return this.tails.length === 1 && !this.head.isComplex() && !this.tails[0].isComplex();
  };
  Chain.prototype.makeReturn = function(){
    var ref$;
    if (this.tails.length) {
      return superclass.prototype.makeReturn.apply(this, arguments);
    } else {
      return (ref$ = this.head).makeReturn.apply(ref$, arguments);
    }
  };
  Chain.prototype.getCall = function(){
    var tail, ref$;
    return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call && tail;
  };
  Chain.prototype.varName = function(){
    var ref$, ref1$;
    return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
  };
  Chain.prototype.cacheReference = function(o){
    var name, ref$, base, bref, nref, key;
    name = (ref$ = this.tails)[ref$.length - 1];
    if (!this.isAssignable()) {
      return this.unwrap().cache(o, true);
    }
    if (this.tails.length < 2 && !this.head.isComplex() && !(name != null && name.isComplex())) {
      return [this, this];
    }
    base = Chain(this.head, this.tails.slice(0, -1));
    if (base.isComplex()) {
      ref$ = base.unwrap().cache(o, true), base = ref$[0], bref = ref$[1];
      base = Chain(base);
    }
    if (!name) {
      return [base, bref];
    }
    nref = name;
    if (name.symbol !== '.') {
      nref = name;
      name = Index(name.key, '.');
    }
    if (name.isComplex()) {
      ref$ = name.key.unwrap().cache(o, true, void 8, 'key'), key = ref$[0], nref.key = ref$[1];
      name = Index(key);
    }
    return [base.add(name), Chain(bref || base.head, [nref])];
  };
  Chain.prototype.compileNode = function(o){
    var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
    if (this.flip) {
      util('flip');
      util('curry');
    }
    head = this.head, tails = this.tails;
    head.front = this.front;
    head.newed = this.newed;
    if (!tails.length) {
      return head.compile(o);
    }
    if (that = this.unfoldAssign(o)) {
      return that.compile(o);
    }
    for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {
      t = tails[i$];
      if (t.partialized) {
        hasPartial = true;
        break;
      }
    }
    if (hasPartial) {
      util('slice');
      pre = [];
      rest = [];
      for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {
        t = tails[i$];
        broken = broken || t.partialized != null;
        if (broken) {
          rest.push(t);
        } else {
          pre.push(t);
        }
      }
      if (rest != null) {
        partial = rest[0], post = slice$.call(rest, 1);
      }
      this.tails = pre;
      context = pre.length
        ? Chain(head, slice$.call(pre, 0, -1))
        : Literal('this');
      return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial.partialized)])])), post).compile(o);
    }
    if (tails[0] instanceof Call && !head.isCallable()) {
      this.carp('invalid callee');
    }
    this.expandVivify();
    this.expandBind(o);
    this.expandSplat(o);
    this.expandStar(o);
    if (this.splattedNewArgs) {
      idt = o.indent + TAB;
      func = Chain(this.head, tails.slice(0, -1));
      return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
    }
    if (!this.tails.length) {
      return this.head.compile(o);
    }
    base = [this.head.compile(o, LEVEL_CALL)];
    news = [];
    rest = [];
    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
      t = ref$[i$];
      if (t['new']) {
        news.push('new ');
      }
      rest.push(t.compile(o));
    }
    if ('.' === rest.join("").charAt(0) && SIMPLENUM.test(base[0].toString())) {
      base.push(' ');
    }
    return sn.apply(null, [null].concat(arrayFrom$(news), arrayFrom$(base), arrayFrom$(rest)));
  };
  Chain.prototype.unfoldSoak = function(o){
    var that, ref$, i$, len$, i, node, ref1$, bust, test;
    if (that = this.head.unfoldSoak(o)) {
      (ref$ = that.then.tails).push.apply(ref$, this.tails);
      return that;
    }
    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
      i = i$;
      node = ref$[i$];
      if (ref1$ = node.soak, delete node.soak, ref1$) {
        bust = Chain(this.head, this.tails.splice(0, i));
        if (node.assign && !bust.isAssignable()) {
          node.carp('invalid accessign');
        }
        if (i && (node.assign || node instanceof Call)) {
          ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];
          if (bust instanceof Chain) {
            (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
            bust = bust.head;
          }
          this.head = bust;
        } else {
          ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
        }
        test = node instanceof Call
          ? JS("typeof " + test.compile(o, LEVEL_OP) + " == 'function'")
          : Existence(test);
        return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$['void'] = this['void'], ref1$;
      }
    }
  };
  Chain.prototype.unfoldAssign = function(o){
    var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
    if (that = this.head.unfoldAssign(o)) {
      (ref$ = that.right.tails).push.apply(ref$, this.tails);
      return that;
    }
    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
      i = i$;
      index = ref$[i$];
      if (op = index.assign) {
        index.assign = '';
        left = Chain(this.head, this.tails.splice(0, i)).unwrap();
        if (left instanceof Arr) {
          lefts = left.items;
          rites = (this.head = Arr()).items;
          for (j$ = 0, len1$ = lefts.length; j$ < len1$; ++j$) {
            i = j$;
            node = lefts[j$];
            ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
          }
        } else {
          ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
        }
        if (op === '=') {
          op = ':=';
        }
        return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
      }
    }
  };
  Chain.prototype.expandSplat = function(o){
    var tails, i, call, args, ctx, ref$;
    tails = this.tails;
    i = -1;
    while (call = tails[++i]) {
      if (!(args = call.args)) {
        continue;
      }
      ctx = call.method === '.call' && (args = args.concat()).shift();
      if (!!snEmpty(args = Splat.compileArray(o, args, true))) {
        continue;
      }
      if (call['new']) {
        this.splattedNewArgs = args;
      } else {
        if (!ctx && tails[i - 1] instanceof Index) {
          ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
          i = 0;
        }
        call.method = '.apply';
        call.args = [ctx || Literal('null'), JS(args)];
      }
    }
  };
  Chain.prototype.expandVivify = function(){
    var tails, i, that, ref$, ref1$;
    tails = this.tails;
    i = 0;
    while (i < tails.length) {
      if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {
        this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), '=', '||');
        i = 0;
      }
    }
  };
  Chain.prototype.expandBind = function(o){
    var tails, i, that, obj, key, call;
    tails = this.tails;
    i = -1;
    while (that = tails[++i]) {
      if (that.symbol !== '.~') {
        continue;
      }
      that.symbol = '';
      obj = Chain(this.head, tails.splice(0, i)).unwrap();
      key = tails.shift().key;
      call = Call.make(Util('bind'), [obj, (key.reserved = true, key)]);
      this.head = this.newed ? Parens(call, true) : call;
      i = -1;
    }
  };
  Chain.prototype.expandStar = function(o){
    var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
    tails = this.tails;
    i = -1;
    while (that = tails[++i]) {
      if (that.args || that.stars || that.key instanceof Key) {
        continue;
      }
      stars = that.stars = [];
      that.eachChild(seek);
      if (!stars.length) {
        continue;
      }
      ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
      value = Chain(ref, [Index(Key('length'))]).compile(o);
      for (i$ = 0, len$ = stars.length; i$ < len$; ++i$) {
        star = stars[i$];
        star.value = value;
        star.isAssignable = YES;
      }
      this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
      if (temps) {
        o.scope.free(temps[0]);
      }
      i = -1;
    }
    function seek(it){
      if (it.value === '*') {
        stars.push(it);
      } else if (!(it instanceof Index)) {
        it.eachChild(seek);
      }
    }
  };
  Chain.prototype.rewriteShorthand = function(o, assign){
    var that, i$, ref$, len$, i, item;
    if (that = this.head.rewriteShorthand(o)) {
      this.head = that;
    }
    for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
      i = i$;
      item = ref$[i$];
      if (that = item.rewriteShorthand(o, assign)) {
        this.tails[i] = that;
      }
    }
    this.expandSlice(o, assign);
    return this.unwrap();
  };
  Chain.prototype.expandSlice = function(o, assign){
    var tails, i, tail, ref$, x;
    tails = this.tails;
    i = -1;
    while (tail = tails[++i]) {
      if ((ref$ = tail.key) != null && ref$.items) {
        if (tails[i + 1] instanceof Call) {
          tail.carp('calling a slice');
        }
        x = tails.splice(0, i + 1);
        x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
        this.head = (x.front = this.front, x);
        i = -1;
      }
    }
    return this;
  };
  Chain.prototype.extractKeyRef = function(o, assign){
    var ref$, ref1$;
    return ((ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? (ref1$ = ref$.key) != null ? ref1$.extractKeyRef(o, assign) : void 8 : void 8) || superclass.prototype.extractKeyRef.apply(this, arguments);
  };
  return Chain;
}(Node));
exports.Call = Call = (function(superclass){
  var prototype = extend$((import$(Call, superclass).displayName = 'Call', Call), superclass).prototype, constructor = Call;
  function Call(args){
    var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
    args || (args = []);
    if (args.length === 1 && (splat = args[0]) instanceof Splat) {
      if (splat.filler) {
        this$.method = '.call';
        args[0] = Literal('this');
        args[1] = Splat(Literal('arguments'));
      } else if (splat.it instanceof Arr) {
        args = splat.it.items;
      }
    } else {
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        i = i$;
        a = args[i$];
        if (a.value === '_') {
          args[i] = Chain(Literal('void'));
          args[i].placeholder = true;
          ((ref$ = this$.partialized) != null
            ? ref$
            : this$.partialized = []).push(Chain(Literal(i)));
        }
      }
    }
    this$.args = args;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Call.prototype.children = ['args'];
  Call.prototype.show = function(){
    return [this['new']] + [this.method] + [this.soak ? '?' : void 8];
  };
  Call.prototype.compile = function(o){
    var code, i$, ref$, len$, i, a;
    code = [sn(this, this.method || '', '(') + (this.pipe ? "\n" + o.indent : '')];
    for (i$ = 0, len$ = (ref$ = this.args).length; i$ < len$; ++i$) {
      i = i$;
      a = ref$[i$];
      code.push(i ? ', ' : '', a.compile(o, LEVEL_LIST));
    }
    code.push(sn(this, ')'));
    return sn.apply(null, [null].concat(arrayFrom$(code)));
  };
  Call.make = function(callee, args, opts){
    var call;
    call = Call(args);
    if (opts) {
      import$(call, opts);
    }
    return Chain(callee).add(call);
  };
  Call.block = function(fun, args, method){
    var ref$, ref1$;
    return ref$ = Parens(Chain(fun, [(ref1$ = Call(args), ref1$.method = method, ref1$)]), true), ref$.calling = true, ref$;
  };
  Call.back = function(params, node, bound, curried, hushed, generator){
    var fun, ref$, args, index, i$, len$, a;
    fun = Fun(params, void 8, bound, curried, hushed, generator);
    if (node instanceof Label) {
      fun.name = node.label;
      fun.labeled = true;
      node = node.it;
    }
    if (!fun.hushed && (fun.hushed = node.op === '!')) {
      node = node.it;
    }
    if ((ref$ = node.getCall()) != null) {
      ref$.partialized = null;
    }
    args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
    index = 0;
    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
      a = args[i$];
      if (a.placeholder) {
        break;
      }
      ++index;
    }
    return node.back = (args[index] = fun).body, node;
  };
  Call['let'] = function(args, body){
    var hasYield, hasAwait, params, res$, i$, len$, i, a, that, gotThis;
    hasYield = false;
    hasAwait = false;
    body.traverseChildren(function(child){
      if (child instanceof Yield) {
        switch (child.op) {
        case 'yield':
        case 'yieldfrom':
          hasYield = true;
          break;
        case 'await':
          hasAwait = true;
        }
      }
      if (hasYield && hasAwait) {
        return true;
      }
    });
    res$ = [];
    for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
      i = i$;
      a = args[i$];
      if (that = a.op === '=' && !a.logic && a.right) {
        args[i] = that;
        if (i === 0 && (gotThis = a.left.value === 'this')) {
          continue;
        }
        res$.push(a.left);
      } else {
        res$.push(Var(a.varName() || a.carp('invalid "let" argument')));
      }
    }
    params = res$;
    gotThis || args.unshift(Literal('this'));
    body = this.block(Fun(params, body, null, null, null, hasYield, hasAwait), args, '.call');
    if (hasYield || hasAwait) {
      return Block(Yield(hasYield ? 'yieldfrom' : 'await', body));
    } else {
      return body;
    }
  };
  return Call;
}(Node));
List = (function(superclass){
  var prototype = extend$((import$(List, superclass).displayName = 'List', List), superclass).prototype, constructor = List;
  List.prototype.children = ['items'];
  List.prototype.show = function(){
    return this.name;
  };
  List.prototype.named = function(name){
    this.name = name;
    return this;
  };
  List.prototype.isEmpty = function(){
    return !this.items.length;
  };
  List.prototype.assigns = function(){
    var x$, res$, i$, ref$, len$, node, that, j$, len1$, x;
    res$ = [];
    for (i$ = 0, len$ = (ref$ = this.items).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (that = node.assigns()) {
        for (j$ = 0, len1$ = that.length; j$ < len1$; ++j$) {
          x = that[j$];
          res$.push(x);
        }
      }
    }
    x$ = res$;
    if (that = this.name) {
      x$.push(that);
    }
    return x$;
  };
  List.compile = function(o, items, deepEq){
    var indent, level, code, i, that, target;
    switch (items.length) {
    case 0:
      return '';
    case 1:
      return items[0].compile(o, LEVEL_LIST);
    }
    indent = o.indent, level = o.level;
    o.indent = indent + TAB;
    o.level = LEVEL_LIST;
    code = [items[i = 0].compile(o)];
    while (that = items[++i]) {
      code.push(', ');
      target = that;
      if (deepEq) {
        if (target instanceof Var && target.value === '_') {
          target = Obj([Prop(Key('__placeholder__'), Literal(true))]);
        } else if (target instanceof Obj || target instanceof Arr) {
          target.deepEq = true;
        }
      }
      code.push(target.compile(o));
    }
    if (~code.join("").indexOf('\n')) {
      code = ["\n" + o.indent].concat(arrayFrom$(code), ["\n" + indent]);
    }
    o.indent = indent;
    o.level = level;
    return sn.apply(null, [this].concat(arrayFrom$(code)));
  };
  List.prototype.toSlice = function(o, base, symbol, assign){
    var items, isObj, ref$, ref, temps, i$, len$, i, item, val, splat, chain;
    items = this.items;
    isObj = this instanceof Obj;
    if (items.length > 1) {
      ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
    } else {
      ref = base;
    }
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      i = i$;
      item = items[i$];
      if (!item.comment) {
        if (isObj) {
          val = item.val;
          if (!(val instanceof List)) {
            (val = val.maybeKey()) || this.carp("value in object slice is not a key");
          }
        } else {
          val = item;
          if (splat = val instanceof Splat) {
            val = val.it;
          }
          if (val.isEmpty()) {
            continue;
          }
        }
        chain = val instanceof List
          ? val.toSlice(o, base, symbol, assign)
          : Chain(base, [Index(val, symbol)]);
        if (isObj) {
          item.val = chain;
        } else {
          items[i] = splat ? Splat(chain) : chain;
        }
        base = ref;
      }
    }
    chain || this.carp('empty slice');
    if (temps) {
      (this.temps || (this.temps = [])).push(temps[0]);
    }
    return this;
  };
  List.prototype.extractKeyRef = function(){
    var that;
    if ((that = this.name) != null) {
      return Key(that);
    } else {
      return superclass.prototype.extractKeyRef.apply(this, arguments);
    }
  };
  function List(){
    List.superclass.apply(this, arguments);
  }
  return List;
}(Node));
exports.Obj = Obj = (function(superclass){
  var prototype = extend$((import$(Obj, superclass).displayName = 'Obj', Obj), superclass).prototype, constructor = Obj;
  function Obj(items){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.items = items || [];
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Obj.prototype.asObj = THIS;
  Obj.prototype.compileNode = function(o){
    var items, code, idt, dic, i$, len$, i, node, ref$, rest, multi, key, val;
    if (this.name != null) {
      this.carp("unexpected label");
    }
    items = this.items;
    if (!items.length) {
      return sn(this, this.front ? '({})' : '{}');
    }
    code = [];
    idt = '\n' + (o.indent += TAB);
    dic = {};
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      i = i$;
      node = items[i$];
      if (node.comment) {
        code.push(idt, node.compile(o));
        continue;
      }
      if ((ref$ = node.key) instanceof Splat || ref$ instanceof Parens) {
        rest = items.slice(i);
        break;
      }
      if (node.logic) {
        node.val = (ref$ = node.logic, ref$.first = node.val, ref$);
      }
      if (this.deepEq) {
        if (node.val instanceof Var && node.val.value === '_') {
          node.val = Obj([Prop(Key('__placeholder__'), Literal(true))]);
        } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
          node.val.deepEq = true;
        }
      }
      if (multi) {
        code.push(',');
      } else {
        multi = true;
      }
      code.push(idt);
      key = node.key, val = node.val;
      if (node.accessor) {
        code.push(node.compileAccessor(o, key = key.compile(o)));
      } else {
        val.ripName(key);
        code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
      }
      ID.test(key) || (key = Function("return " + key)());
      if (!(dic[key + "."] ^= 1)) {
        node.carp("duplicate property \"" + key + "\"");
      }
    }
    if (code.join("")) {
      code.push('\n' + this.tab);
    }
    code = sn.apply(null, [null, sn(this, "{")].concat(arrayFrom$(code), [sn(this, "}")]));
    rest && (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
    if (this.front && '{' === code.toString().charAt()) {
      return sn(null, "(", code, ")");
    } else {
      return code;
    }
  };
  return Obj;
}(List));
exports.Prop = Prop = (function(superclass){
  var prototype = extend$((import$(Prop, superclass).displayName = 'Prop', Prop), superclass).prototype, constructor = Prop;
  function Prop(key, val){
    var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
    this$.key = key;
    this$.val = val;
    if ((key != null ? key.value : void 8) === '...') {
      this$.key = Splat();
    }
    if (that = val.getAccessors()) {
      this$.val = that;
      for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
        fun = that[i$];
        fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';
      }
      this$['accessor'] = 'accessor';
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Prop.prototype.children = ['key', 'val', 'logic'];
  Prop.prototype.show = function(){
    return this.accessor;
  };
  Prop.prototype.assigns = function(){
    var ref$;
    return typeof (ref$ = this.val).assigns == 'function' ? ref$.assigns() : void 8;
  };
  Prop.prototype.compileAccessor = function(o, key){
    var funs, code, i$, len$, fun;
    funs = this.val;
    if (funs[1] && funs[0].params.length + funs[1].params.length !== 1) {
      funs[0].carp('invalid accessor parameter');
    }
    code = [];
    for (i$ = 0, len$ = funs.length; i$ < len$; ++i$) {
      fun = funs[i$];
      fun.accessor = true;
      code.push(fun.x, "et ", key, fun.compile(o, LEVEL_LIST).toString().slice(8), ',\n' + o.indent);
    }
    code.pop();
    return sn.apply(null, [null].concat(arrayFrom$(code)));
  };
  Prop.prototype.compileDescriptor = function(o){
    var obj, i$, ref$, len$, fun;
    obj = Obj();
    for (i$ = 0, len$ = (ref$ = this.val).length; i$ < len$; ++i$) {
      fun = ref$[i$];
      obj.items.push(Prop(Key(fun.x + 'et'), fun));
    }
    obj.items.push(Prop(Key('configurable'), Literal(true)));
    obj.items.push(Prop(Key('enumerable'), Literal(true)));
    return obj.compile(o);
  };
  Prop.prototype.rewriteShorthand = function(o, assign){
    var ref$, that;
    superclass.prototype.rewriteShorthand.apply(this, arguments);
    if (this.key == null && this.val instanceof Assign) {
      this.val = this.val.maybeLogic();
    }
    if (this.key == null && this.val instanceof Unary && ((ref$ = this.val.op) === '+' || ref$ === '-')) {
      this.key = this.val.it.maybeKey() || this.carp("invalid property flag shorthand");
      this.val = Literal(this.val.op === '+');
    }
    if (that = this.val instanceof Binary && this.val.getDefault()) {
      this.val = this.val.first;
      this.logic = (that.first = null, that);
    }
    this.key == null && (this.key = this.val.extractKeyRef(o, assign));
  };
  return Prop;
}(Node));
exports.Arr = Arr = (function(superclass){
  var prototype = extend$((import$(Arr, superclass).displayName = 'Arr', Arr), superclass).prototype, constructor = Arr;
  function Arr(items){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.items = items || [];
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Arr.prototype.isArray = YES;
  Arr.prototype.asObj = function(){
    var i, item;
    return Obj((function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = this.items).length; i$ < len$; ++i$) {
        i = i$;
        item = ref$[i$];
        results$.push(Prop(Literal(i), item));
      }
      return results$;
    }.call(this)));
  };
  Arr.prototype.compile = function(o){
    var items, code;
    if (this.name != null) {
      this.carp("unexpected label");
    }
    items = this.items;
    if (!items.length) {
      return sn(this, '[]');
    }
    if (!snEmpty(code = Splat.compileArray(o, items))) {
      return this.newed
        ? sn(this, "(", code, ")")
        : sn(this, code);
    }
    return sn(null, sn(this, "["), List.compile(o, items, this.deepEq), sn(this, "]"));
  };
  Arr.maybe = function(nodes){
    if (nodes.length === 1 && !(nodes[0] instanceof Splat)) {
      return nodes[0];
    }
    return constructor(nodes);
  };
  Arr.wrap = function(it){
    return constructor([Splat((it.isArray = YES, it))]);
  };
  return Arr;
}(List));
exports.Yield = Yield = (function(superclass){
  var prototype = extend$((import$(Yield, superclass).displayName = 'Yield', Yield), superclass).prototype, constructor = Yield;
  function Yield(op, it){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.op = op;
    this$.it = it;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Yield.prototype.children = ['it'];
  Yield.prototype.show = function(){
    switch (this.op) {
    case 'yield':
      return '';
    case 'yieldfrom':
      return 'from';
    case 'await':
      return 'await';
    }
  };
  prototype.delegate(['isCallable'], function(){
    return true;
  });
  Yield.prototype.compileNode = function(o){
    var code;
    code = [(function(){
      switch (this.op) {
      case 'yield':
        return 'yield';
      case 'yieldfrom':
        return 'yield*';
      case 'await':
        return 'await';
      }
    }.call(this))];
    if (this.it) {
      code.push(" " + this.it.compile(o, LEVEL_OP + PREC.unary));
    }
    return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
  };
  return Yield;
}(Node));
exports.Unary = Unary = (function(superclass){
  var prototype = extend$((import$(Unary, superclass).displayName = 'Unary', Unary), superclass).prototype, constructor = Unary;
  function Unary(op, it, flag){
    var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
    if (it != null) {
      if (that = !flag && it.unaries) {
        that.push(op);
        return it;
      }
      switch (op) {
      case '!':
        if (flag) {
          break;
        }
        if (it instanceof Fun && !it.hushed) {
          return it.hushed = true, it;
        }
        return it.invert();
      case '++':
      case '--':
        if (flag) {
          this$.post = true;
        }
        break;
      case 'new':
        if (it instanceof Existence && !it.negated) {
          it = Chain(it).add(Call());
        }
        it.newed = true;
        for (i$ = 0, len$ = (ref$ = it.tails || '').length; i$ < len$; ++i$) {
          node = ref$[i$];
          if (node instanceof Call && !node['new']) {
            if (node.method === '.call') {
              node.args.shift();
            }
            node['new'] = 'new';
            node.method = '';
            return it;
          }
        }
        break;
      case '~':
        if (it instanceof Fun && it.statement && !it.bound) {
          return it.bound = 'this$', it;
        }
      }
    }
    this$.op = op;
    this$.it = it;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Unary.prototype.children = ['it'];
  Unary.prototype.show = function(){
    return [this.post ? '@' : void 8] + this.op;
  };
  Unary.prototype.isCallable = function(){
    var ref$;
    return ((ref$ = this.op) === 'do' || ref$ === 'new' || ref$ === 'delete') || this.it == null;
  };
  Unary.prototype.isArray = function(){
    return this.it instanceof Arr && this.it.items.length || this.it instanceof Chain && this.it.isArray();
  };
  Unary.prototype.isString = function(){
    var ref$;
    return (ref$ = this.op) === 'typeof' || ref$ === 'classof';
  };
  Unary.prototype.invert = function(){
    var ref$;
    if (this.op === '!' && ((ref$ = this.it.op) === '!' || ref$ === '<' || ref$ === '>' || ref$ === '<=' || ref$ === '>=' || ref$ === 'of' || ref$ === 'instanceof')) {
      return this.it;
    }
    return constructor('!', this, true);
  };
  Unary.prototype.unfoldSoak = function(o){
    var ref$;
    return ((ref$ = this.op) === '++' || ref$ === '--' || ref$ === 'delete' || ref$ === 'jsdelete') && this.it != null && If.unfoldSoak(o, this, 'it');
  };
  Unary.prototype.getAccessors = function(){
    var items;
    if (this.op !== '~') {
      return;
    }
    if (this.it instanceof Fun) {
      return [this.it];
    }
    if (this.it instanceof Arr) {
      items = this.it.items;
      if (!items[2] && items[0] instanceof Fun && items[1] instanceof Fun) {
        return items;
      }
    }
  };
  function crement(it){
    return {
      '++': 'in',
      '--': 'de'
    }[it] + 'crement';
  }
  Unary.prototype.compileNode = function(o){
    var that, op, it, x, code;
    if (this.it == null) {
      return this.compileAsFunc(o);
    }
    if (that = this.compileSpread(o)) {
      return that;
    }
    op = this.op, it = this.it;
    switch (op) {
    case '!':
      it.cond = true;
      break;
    case 'new':
      it.isCallable() || it.carp('invalid constructor');
      break;
    case 'do':
      if (o.level === LEVEL_TOP && it instanceof Fun && it.isStatement()) {
        return sn(this, it.compile(o), " ", Unary('do', Var(it.name)).compile(o));
      }
      x = Parens(it instanceof Existence && !it.negated
        ? Chain(it).add(Call())
        : Call.make(it));
      return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
    case 'delete':
      if (it instanceof Var || !it.isAssignable()) {
        this.carp('invalid delete');
      }
      if (o.level && !this['void']) {
        return this.compilePluck(o);
      }
      break;
    case '++':
    case '--':
      it.isAssignable() || this.carp('invalid ' + crement(op));
      if (that = it instanceof Var && o.scope.checkReadOnly(it.value)) {
        this.carp(crement(op) + " of " + that + " \"" + it.value + "\"", ReferenceError);
      }
      if (this.post) {
        it.front = this.front;
      }
      break;
    case '^^':
      return sn(this, util('clone'), "(", it.compile(o, LEVEL_LIST), ")");
    case 'jsdelete':
      return sn(this, "delete ", it.compile(o, LEVEL_LIST));
    case 'classof':
      return sn(this, util('toString'), ".call(", it.compile(o, LEVEL_LIST), ").slice(8, -1)");
    }
    code = [it.compile(o, LEVEL_OP + PREC.unary)];
    if (this.post) {
      code.push(op);
    } else {
      if ((op === 'new' || op === 'typeof' || op === 'delete') || (op === '+' || op === '-') && op === code.join("").charAt()) {
        op += ' ';
      }
      code.unshift(op);
    }
    if (o.level < LEVEL_CALL) {
      return sn.apply(null, [this].concat(arrayFrom$(code)));
    } else {
      return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
    }
  };
  Unary.prototype.compileSpread = function(o){
    var it, ops;
    it = this.it;
    ops = [this];
    for (; it instanceof constructor; it = it.it) {
      ops.push(it);
    }
    if (!(it instanceof Splat && (it = it.it) instanceof List)) {
      return '';
    }
    return this.compileSpreadOver(o, it, function(node){
      var i$, ref$, op;
      for (i$ = (ref$ = ops).length - 1; i$ >= 0; --i$) {
        op = ref$[i$];
        node = constructor(op.op, node, op.post);
      }
      return node;
    });
  };
  Unary.prototype.compilePluck = function(o){
    var ref$, get, del, code, ref;
    ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
    code = [ref = o.scope.temporary(), " = ", get.compile(o, LEVEL_LIST), ", delete ", del.compile(o, LEVEL_LIST), ", ", o.scope.free(ref)];
    if (o.level < LEVEL_LIST) {
      return sn.apply(null, [this].concat(arrayFrom$(code)));
    } else {
      return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
    }
  };
  Unary.prototype.compileAsFunc = function(o){
    if (this.op === '!') {
      return sn(this, util('not'));
    } else {
      return sn(this, "(", Fun([], Block(Unary(this.op, Chain(Var('it'))))).compile(o), ")");
    }
  };
  return Unary;
}(Node));
exports.Binary = Binary = (function(superclass){
  var COMPARER, INVERSIONS, prototype = extend$((import$(Binary, superclass).displayName = 'Binary', Binary), superclass).prototype, constructor = Binary;
  function Binary(op, first, second){
    var ref$, this$ = this instanceof ctor$ ? this : new ctor$;
    this$.partial = first == null || second == null;
    if (!this$.partial) {
      if ('=' === op.charAt(op.length - 1) && ((ref$ = op.charAt(op.length - 2)) !== '=' && ref$ !== '<' && ref$ !== '>' && ref$ !== '!')) {
        return Assign(first.unwrap(), second, op);
      }
      switch (op) {
      case 'in':
        return new In(first, second);
      case 'with':
        return new Import(Unary('^^', first), second, false);
      case '<<<':
      case '<<<<':
        return Import(first, second, op === '<<<<');
      case '<|':
        return Block(first).pipe(second, op);
      case '|>':
        return Block(second).pipe(first, '<|');
      case '.':
      case '.~':
        return Chain(first).add(Index(second, op));
      }
    }
    this$.op = op;
    this$.first = first;
    this$.second = second;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Binary.prototype.children = ['first', 'second'];
  Binary.prototype.show = function(){
    return this.op;
  };
  Binary.prototype.isCallable = function(){
    var ref$;
    return this.partial || ((ref$ = this.op) === '&&' || ref$ === '||' || ref$ === '?' || ref$ === '<<' || ref$ === '>>') && this.first.isCallable() && this.second.isCallable();
  };
  Binary.prototype.isArray = function(){
    switch (this.op) {
    case '*':
      return this.first.isArray();
    case '/':
      return this.second.isMatcher();
    }
  };
  Binary.prototype.isString = function(){
    switch (this.op) {
    case '+':
    case '*':
      return this.first.isString() || this.second.isString();
    case '-':
      return this.second.isMatcher();
    }
  };
  COMPARER = /^(?:[!=]=|[<>])=?$/;
  INVERSIONS = {
    '===': '!==',
    '!==': '===',
    '==': '!=',
    '!=': '=='
  };
  Binary.prototype.invert = function(){
    var that;
    if (that = !COMPARER.test(this.second.op) && INVERSIONS[this.op]) {
      this.op = that;
      this.wasInverted = true;
      return this;
    }
    return Unary('!', Parens(this), true);
  };
  Binary.prototype.invertIt = function(){
    this.inverted = true;
    return this;
  };
  Binary.prototype.getDefault = function(){
    switch (this.op) {
    case '?':
    case '||':
    case '&&':
      return this;
    }
  };
  Binary.prototype.xorChildren = function(test){
    var ref$, first;
    if (!(!(first = test(this.first)) !== !(ref$ = test(this.second)) && (first || ref$))) {
      return false;
    }
    return first
      ? [this.first, this.second]
      : [this.second, this.first];
  };
  Binary.prototype.compileNode = function(o){
    var top, rite, items, that, ref$, code, level;
    if (this.partial) {
      return this.compilePartial(o);
    }
    switch (this.op) {
    case '?':
      return this.compileExistence(o);
    case '*':
      if (this.second.isString()) {
        return this.compileJoin(o);
      }
      if (this.first.isString() || this.first.isArray()) {
        return this.compileRepeat(o);
      }
      break;
    case '-':
      if (this.second.isMatcher()) {
        return this.compileRemove(o);
      }
      break;
    case '/':
      if (this.second.isMatcher()) {
        return this.compileSplit(o);
      }
      break;
    case '**':
    case '^':
      return this.compilePow(o);
    case '<?':
    case '>?':
      return this.compileMinMax(o);
    case '<<':
    case '>>':
      return this.compileCompose(o);
    case '++':
      return this.compileConcat(o);
    case '%%':
      return this.compileMod(o);
    case 'xor':
      return this.compileXor(o);
    case '&&':
    case '||':
      if (top = this['void'] || !o.level) {
        this.second['void'] = true;
      }
      if (top || this.cond) {
        this.first.cond = true;
        this.second.cond = true;
      }
      break;
    case 'instanceof':
      rite = this.second, items = rite.items;
      if (rite instanceof Arr) {
        if (items[1]) {
          return this.compileAnyInstanceOf(o, items);
        }
        this.second = items[0] || rite;
      }
      this.second.isCallable() || this.second.carp('invalid instanceof operand');
      break;
    case '====':
    case '!===':
      this.op = this.op.slice(0, 3);
      // fallthrough
    case '<==':
    case '>==':
    case '<<=':
    case '>>=':
      return this.compileDeepEq(o);
    default:
      if (COMPARER.test(this.op)) {
        if (that = ((ref$ = this.op) === '===' || ref$ === '!==') && this.xorChildren(function(it){
          return it.isRegex();
        })) {
          return this.compileRegexEquals(o, that);
        }
        if (this.op === '===' && (this.first instanceof Literal && this.second instanceof Literal) && this.first.isWhat() !== this.second.isWhat()) {
          if (o.warn) {
            this.warn("strict comparison of two different types will always be false: " + this.first.value + " == " + this.second.value);
          }
        }
      }
      if (COMPARER.test(this.op) && COMPARER.test(this.second.op)) {
        return this.compileChain(o);
      }
    }
    this.first.front = this.front;
    code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), " ", this.mapOp(this.op), " ", this.second.compile(o, level)];
    if (o.level <= level) {
      return sn.apply(null, [this].concat(arrayFrom$(code)));
    } else {
      return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
    }
  };
  Binary.prototype.mapOp = function(op){
    var that;
    switch (false) {
    case !(that = op.match(/\.([&\|\^]|<<|>>>?)\./)):
      return that[1];
    case op !== 'of':
      return 'in';
    default:
      return op;
    }
  };
  Binary.prototype.compileChain = function(o){
    var code, level, ref$, sub;
    code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];
    ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
    code.push(" ", this.op, " ", sub.compile(o, level), " && ", this.second.compile(o, LEVEL_OP));
    if (o.level <= LEVEL_OP) {
      return sn.apply(null, [this].concat(arrayFrom$(code)));
    } else {
      return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
    }
  };
  Binary.prototype.compileExistence = function(o){
    var x;
    if (this['void'] || !o.level) {
      x = Binary('&&', Existence(this.first, true), Parens(this.second.unwrap()));
      return (x['void'] = true, x).compileNode(o);
    }
    x = this.first.cache(o, true);
    return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));
  };
  Binary.prototype.compileAnyInstanceOf = function(o, items){
    var ref$, sub, ref, test, i$, len$, item;
    ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
    test = Binary('instanceof', sub, items.shift());
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      item = items[i$];
      test = Binary('||', test, Binary('instanceof', ref, item));
    }
    return sn(this, Parens(test).compile(o));
  };
  Binary.prototype.compileMinMax = function(o){
    var lefts, rites, x;
    lefts = this.first.cache(o, true);
    rites = this.second.cache(o, true);
    x = Binary(this.op.charAt(), lefts[0], rites[0]);
    return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));
  };
  Binary.prototype.compileMethod = function(o, klass, method, arg){
    var args;
    args = [this.second].concat(arg || []);
    if (this.first["is" + klass]()) {
      return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
    } else {
      args.unshift(this.first);
      return sn(this, Call.make(JS(util(method) + '.call'), args).compile(o));
    }
  };
  Binary.prototype.compileJoin = function(it){
    return this.compileMethod(it, 'Array', 'join');
  };
  Binary.prototype.compileRemove = function(it){
    return this.compileMethod(it, 'String', 'replace', JS("''"));
  };
  Binary.prototype.compileSplit = function(it){
    return this.compileMethod(it, 'String', 'split');
  };
  Binary.prototype.compileRepeat = function(o){
    var x, items, n, arr, arrCode, refs, i$, len$, i, item, ref$, q;
    x = this.first, items = x.items, n = this.second;
    arr = x.isArray() && 'Array';
    if (items && !snEmpty(arrCode = Splat.compileArray(o, items))) {
      x = JS(arrCode);
      items = null;
    }
    if (arr && !items || !(n instanceof Literal && n.value < 0x20)) {
      return sn(this, Call.make(Util('repeat' + (arr || 'String')), [x, n]).compile(o));
    }
    n = +n.value;
    if (1 <= n && n < 2) {
      return sn(this, x.compile(o));
    }
    if (items) {
      if (n < 1) {
        return sn(this, Block(items).add(JS('[]')).compile(o));
      }
      refs = [];
      for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
        i = i$;
        item = items[i$];
        ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
      }
      items.push((ref$ = JS(), ref$.compile = function(){
        return sn.apply(null, [this].concat(arrayFrom$((repeatArray$([", ", List.compile(o, refs)], n - 1)).slice(1))));
      }, ref$));
      return sn(this, x.compile(o));
    } else if (x instanceof Literal) {
      return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + "", n) + q);
    } else {
      if (n < 1) {
        return sn(this, Block(x.it).add(JS("''")).compile(o));
      }
      x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(" + " + refs[1], n - 1);
      if (o.level < LEVEL_OP + PREC['+']) {
        return sn(this, x);
      } else {
        return sn(this, "(", x, ")");
      }
    }
  };
  Binary.prototype.compilePow = function(o){
    return sn(null, Call.make(CopyL(this, JS('Math.pow')), [this.first, this.second]).compile(o));
  };
  Binary.prototype.compileConcat = function(o){
    var f;
    f = function(x){
      switch (false) {
      case !(x instanceof Binary && x.op === '++'):
        return f(x.first).concat(f(x.second));
      default:
        return [x];
      }
    };
    return sn(null, Chain(this.first).add(CopyL(this, Index(Key('concat'), '.', true))).add(Call(f(this.second))).compile(o));
  };
  Binary.prototype.compileCompose = function(o){
    var op, functions, x;
    op = this.op;
    functions = [this.first];
    x = this.second;
    while (x instanceof Binary && x.op === op && !x.partial) {
      functions.push(x.first);
      x = x.second;
    }
    functions.push(x);
    if (op === '<<') {
      functions.reverse();
    }
    return sn(this, Chain(Var(util('compose'))).add(Call(functions)).compile(o));
  };
  Binary.prototype.compileMod = function(o){
    var ref, code;
    ref = o.scope.temporary();
    code = [sn(this, "(("), this.first.compile(o), sn(this, ") % ("), sn(this, ref, " = "), this.second.compile(o), sn(this, ") + ", ref, ") % ", ref)];
    o.scope.free(ref);
    if (o.level < LEVEL_OP + PREC['%']) {
      return sn.apply(null, [null].concat(arrayFrom$(code)));
    } else {
      return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
    }
  };
  Binary.prototype.compilePartial = function(o){
    var vit, x, y;
    vit = Var('it');
    switch (false) {
    case !(this.first == null && this.second == null):
      x = Var('x$');
      y = Var('y$');
      return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o));
    case this.first == null:
      return sn(this, "(", Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), ")");
    default:
      return sn(this, "(", Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), ")");
    }
  };
  Binary.prototype.compileRegexEquals = function(o, arg$){
    var regex, target, method;
    regex = arg$[0], target = arg$[1];
    if (this.op === '===') {
      method = this.wasInverted ? 'test' : 'exec';
      return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));
    } else {
      return sn(this, Unary('!', Chain(regex).add(Index(Key('test'))).add(Call([target]))).compile(o));
    }
  };
  Binary.prototype.compileDeepEq = function(o){
    var ref$, negate, i$, len$, x, r;
    if ((ref$ = this.op) === '>==' || ref$ === '>>=') {
      ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
      this.op = this.op === '>==' ? '<==' : '<<=';
    }
    if (this.op === '!==') {
      this.op = '===';
      negate = true;
    }
    for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (x instanceof Obj || x instanceof Arr) {
        x.deepEq = true;
      }
    }
    r = Chain(Var(util('deepEq'))).add(Call([this.first, this.second, Literal("'" + this.op + "'")]));
    return sn(this, (negate ? Unary('!', r) : r).compile(o));
  };
  Binary.prototype.compileXor = function(o){
    var left, right;
    left = Chain(this.first).cacheReference(o);
    right = Chain(this.second).cacheReference(o);
    return sn(this, Binary('&&', Binary('!==', Unary('!', left[0]), Unary('!', right[0])), Parens(Binary('||', left[1], right[1]))).compile(o));
  };
  return Binary;
}(Node));
exports.Assign = Assign = (function(superclass){
  var prototype = extend$((import$(Assign, superclass).displayName = 'Assign', Assign), superclass).prototype, constructor = Assign;
  function Assign(left, rite, op, logic, defParam){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.left = left;
    this$.op = op || '=';
    this$.logic = logic || this$.op.logic;
    this$.defParam = defParam;
    this$.opLoc = this$.op;
    this$.op += '';
    this$[rite instanceof Node ? 'right' : 'unaries'] = rite;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Assign.prototype.children = ['left', 'right'];
  Assign.prototype.show = function(){
    return [void 8].concat(this.unaries).reverse().join(' ') + [this.logic] + this.op;
  };
  Assign.prototype.assigns = function(){
    return this.left.assigns();
  };
  Assign.prototype.getRef = function(){
    if (!this.left.isComplex()) {
      return this.left;
    }
  };
  prototype.delegate(['isCallable', 'isRegex'], function(it){
    var ref$;
    return ((ref$ = this.op) === '=' || ref$ === ':=') && this.right && this.right[it]();
  });
  Assign.prototype.isArray = function(){
    switch (this.op) {
    case '=':
    case ':=':
      return this.right && this.right.isArray();
    case '/=':
      return this.right && this.right.isMatcher();
    }
  };
  Assign.prototype.isString = function(){
    switch (this.op) {
    case '=':
    case ':=':
    case '+=':
    case '*=':
      return this.right && this.right.isString();
    case '-=':
      return this.right && this.right.isMatcher();
    }
  };
  Assign.prototype.unfoldSoak = function(o){
    var that, ref$, ref1$, rite, temps;
    if (this.left instanceof Existence) {
      if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {
        rite = this.right;
        rite = Assign(this.right = Var(that), rite);
      } else {
        ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
      }
      return ref$ = If(Existence(rite), this), ref$.soak = true, ref$.temps = temps, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
    }
    return If.unfoldSoak(o, this, 'left');
  };
  Assign.prototype.unfoldAssign = function(){
    return this.access && this;
  };
  Assign.prototype.compileNode = function(o){
    var left, sp, ref$, i$, len$, op, that, right, reft, sign, name, lvar, protoSplit, dotSplit, code, empty, res;
    if (this.left instanceof Slice && this.op === '=') {
      return this.compileSplice(o);
    }
    left = this.left;
    if (sp = this.left instanceof Splat) {
      left = left.it;
    }
    if (sp) {
      left instanceof List || this.left.carp('invalid splat');
      return this.compileSpread(o, left);
    }
    if (!this.right) {
      left.isAssignable() || left.carp('invalid unary assign');
      ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
      for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ < len$; ++i$) {
        op = ref$[i$];
        this.right = Unary(op, this.right);
      }
    }
    if (left.isEmpty()) {
      return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
    }
    if (left.getDefault()) {
      this.right = Binary(left.op, this.right, left.second);
      left = left.first;
    }
    if (that = left.unfoldSoak(o)) {
      left = that;
      this.left = left.then;
      left.then = this;
      return left.compile(o);
    }
    if (left.items) {
      return this.compileDestructuring(o, left);
    }
    left.isAssignable() || left.carp('invalid assign');
    if (this.logic) {
      return this.compileConditional(o, left);
    }
    op = this.op, right = this.right;
    if (op === '<?=' || op === '>?=') {
      return this.compileMinMax(o, left, right);
    }
    if ((op === '**=' || op === '^=' || op === '%%=' || op === '++=' || op === '|>=') || op === '*=' && right.isString() || (op === '-=' || op === '/=') && right.isMatcher()) {
      ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
      right = Binary(op.slice(0, -1), reft, right);
      op = ':=';
    }
    if (op === '.&.=' || op === '.|.=' || op === '.^.=' || op === '.<<.=' || op === '.>>.=' || op === '.>>>.=') {
      op = op.slice(1, -2) + '=';
    }
    (right = right.unparen()).ripName(left = left.unwrap());
    if (left instanceof Chain) {
      left.expandVivify();
      if ((left = left.unwrap()) instanceof Assign) {
        ref$ = Chain(left.left).cacheReference(o), left.left = ref$[0], this.left = ref$[1];
        return Block([left, (ref$ = clone$(this), ref$.terminator = '', ref$)]).compile(o);
      }
    }
    sign = sn(this.opLoc, " ", op.replace(':', ''), " ");
    name = (left.front = true, left).compile(o, LEVEL_LIST);
    if (lvar = left instanceof Var) {
      if (op === '=') {
        o.scope.declare(name.toString(), left, this['const'] || !this.defParam && o['const'] && '$' !== name.toString().slice(-1));
      } else if (that = o.scope.checkReadOnly(name.toString())) {
        left.carp("assignment to " + that + " \"" + name + "\"", ReferenceError);
      }
    }
    if (left instanceof Chain && right instanceof Fun) {
      protoSplit = name.toString().split('.prototype.');
      dotSplit = name.toString().split('.');
      if (protoSplit.length > 1) {
        right.inClass = protoSplit[0];
      } else if (dotSplit.length > 1) {
        right.inClassStatic = slice$.call(dotSplit, 0, -1).join('');
      }
    }
    code = !o.level && right instanceof While && !right['else'] && (lvar || left instanceof Chain && left.isSimpleAccess())
      ? (empty = right.objComp ? '{}' : '[]', [res = o.scope.temporary('res'), " = " + empty + ";\n" + this.tab, right.makeReturn(res).compile(o), "\n" + this.tab, name, sign, o.scope.free(res)])
      : [name, sign, right.compile(o, LEVEL_LIST)];
    if (o.level > LEVEL_LIST) {
      code = ["("].concat(arrayFrom$(code), [")"]);
    }
    return sn.apply(null, [null].concat(arrayFrom$(code)));
  };
  Assign.prototype.compileConditional = function(o, left){
    var ref$, lcache, morph;
    if (left instanceof Var && this.logic === '?' && this.op === '=') {
      o.scope.declare(left.value, left);
    }
    ref$ = Chain(left).cacheReference(o), lcache = ref$[0], left = ref$[1];
    o.level += LEVEL_OP < o.level;
    if (this.logic === '?' && ((ref$ = this.op) !== '=' && ref$ !== ':=')) {
      this.logic = '&&';
      lcache = Existence(lcache);
    }
    morph = Binary(this.logic, lcache, (this.logic = false, this.left = left, this));
    return sn(this, (morph['void'] = this['void'], morph).compileNode(o));
  };
  Assign.prototype.compileMinMax = function(o, left, right){
    var lefts, rites, test, put, ref$;
    lefts = Chain(left).cacheReference(o);
    rites = right.cache(o, true);
    test = Binary(this.op.replace('?', ''), lefts[0], rites[0]);
    put = Assign(lefts[1], rites[1], ':=');
    if (this['void'] || !o.level) {
      return Parens(Binary('||', test, put)).compile(o);
    }
    ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
    return sn(this, If(test, left).addElse(put).compileExpression(o));
  };
  Assign.prototype.compileDestructuring = function(o, left){
    var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;
    items = left.items, len = items.length;
    ret = o.level && !this['void'];
    rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
    if (that = left.name) {
      cache = sn(this, that, " = ", rite);
      o.scope.declare(rite = that, left);
    } else if ((ret || len > 1) && (!ID.test(rite.toString()) || ((that = left.assigns()) && in$(rite.toString(), that)))) {
      cache = sn(this, rref = o.scope.temporary(), " = ", rite);
      rite = rref;
    }
    if (rite.toString() === 'arguments' && !ret) {
      destructureArgs = true;
      if (!(left instanceof Arr)) {
        this.carp('arguments can only destructure to array');
      }
    }
    list = this["rend" + left.constructor.displayName](o, items, rite, destructureArgs);
    if (rref) {
      o.scope.free(rref);
    }
    if (cache) {
      list.unshift(cache);
    }
    if (ret || !list.length) {
      list.push(rite);
    }
    code = [];
    sep = destructureArgs ? '; ' : ', ';
    for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
      item = list[i$];
      code.push(item, sep);
    }
    code.pop();
    if ((o.level < LEVEL_OP && list.length < 2) || o.level < LEVEL_LIST) {
      return sn.apply(null, [this].concat(arrayFrom$(code)));
    } else {
      return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
    }
  };
  Assign.prototype.compileSplice = function(o){
    var ref$, fromExpNode, fromExp, rightNode, right, toExp;
    ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
    ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
    toExp = Binary('-', this.left.to, fromExp);
    return sn(this, Block([Chain(Var(util('splice'))).add(Index(Key('apply'), '.', true)).add(Call([this.left.target, Chain(Arr([fromExpNode, toExp])).add(Index(Key('concat'), '.', true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST));
  };
  Assign.prototype.compileSpread = function(o, left){
    var that, ref$, rite, rref, this$ = this;
    ref$ = (that = this.unaries)
      ? [that, that]
      : left.items.length <= 1
        ? [ref$ = this.right, ref$]
        : this.right.cache(o, true), rite = ref$[0], rref = ref$[1];
    return this.compileSpreadOver(o, left, function(it){
      var result;
      result = constructor(it, rite, this$.op, this$.logic);
      rite = rref;
      return result;
    });
  };
  Assign.prototype.rendArr = function(o, nodes, rite, destructureArgs){
    var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$;
    function argsSlice(begin, end){
      return new For({
        ref: true,
        from: begin,
        op: 'til',
        to: end
      }).makeComprehension(Chain(Var('arguments')).add(Index(Literal('..'))), []);
    }
    ret = [];
    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
      i = i$;
      node = nodes[i$];
      if (node.isEmpty()) {
        continue;
      }
      if (node instanceof Splat) {
        len && node.carp('multiple splat in an assignment');
        skip = (node = node.it).isEmpty();
        if (i + 1 === (len = nodes.length)) {
          if (skip) {
            break;
          }
          if (destructureArgs) {
            val = argsSlice(Literal(i), Chain(Var('arguments')).add(Index(Key('length'))));
          } else {
            val = Arr.wrap(JS(util('slice') + '.call(' + rite + (i ? ", " + i + ")" : ')')));
          }
        } else {
          val = ivar = rite + ".length - " + (len - i - 1);
          if (skip && i + 2 === len) {
            continue;
          }
          start = i + 1;
          (this.temps || (this.temps = [])).push(ivar = o.scope.temporary('i'));
          val = (fn$());
        }
      } else {
        (inc = ivar) && start < i && (inc += " + " + (i - start));
        val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
      }
      if (destructureArgs) {
        if (!(node instanceof Var) && val instanceof For) {
          (this.temps || (this.temps = [])).push(tmp = o.scope.temporary('ref'));
          vtmp = Var(tmp);
          ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
          ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
        } else {
          ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
        }
      } else {
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
      }
    }
    return ret;
    function fn$(){
      switch (false) {
      case !skip:
        return Arr.wrap(JS(i + " < (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"));
      case !destructureArgs:
        return argsSlice(JS(i + " < (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"), Var(ivar));
      default:
        return Arr.wrap(JS(i + " < (" + ivar + " = " + val + ")\ ? " + util('slice') + ".call(" + rite + ", " + i + ", " + ivar + ")\ : (" + ivar + " = " + i + ", [])"));
      }
    }
  };
  Assign.prototype.rendObj = function(o, nodes, rite){
    var keys, pairs, rvar, i$, len$, ref$, key, lval, logic, excludes, val, left, right, results$ = [];
    keys = [];
    pairs = [];
    rvar = Var(rite);
    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
      ref$ = nodes[i$], key = ref$.key, lval = ref$.val, logic = ref$.logic;
      lval = lval.unparen();
      if (key instanceof Splat) {
        logic != null && this.carp("invalid assign");
        excludes = Obj((fn$.call(this)));
        val = Chain(Var(util('copyWithout'))).add(Call([rvar, excludes]));
      } else {
        keys.push(key);
        if (logic) {
          lval = (logic.first = lval, logic);
        }
        val = Chain(rvar, [Index(key)]);
      }
      pairs.push([lval, val]);
    }
    for (i$ = 0, len$ = pairs.length; i$ < len$; ++i$) {
      ref$ = pairs[i$], left = ref$[0], right = ref$[1];
      results$.push((ref$ = clone$(this), ref$.left = left, ref$.right = right, ref$['void'] = true, ref$.temps = [], ref$).compile(o, LEVEL_PAREN));
    }
    return results$;
    function fn$(){
      var i$, x$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = keys).length; i$ < len$; ++i$) {
        x$ = ref$[i$];
        results$.push(Prop(x$.extractKeyRef(o, true, this), Literal(0)));
      }
      return results$;
    }
  };
  Assign.prototype.rewriteShorthand = function(o, assign){
    var bin, ref$, that, ref1$;
    if (assign) {
      if (this === (bin = this.maybeLogic())) {
        this.carp("invalid assign");
      }
      return (ref$ = bin.rewriteShorthand(o, true)) != null ? ref$ : bin;
    }
    if (that = (ref$ = this.left) != null ? ref$.rewriteShorthand(o, true) : void 8) {
      this.left = that;
    }
    if (that = (ref1$ = this.right) != null ? ref1$.rewriteShorthand(o) : void 8) {
      this.right = that;
    }
  };
  Assign.prototype.maybeLogic = function(){
    if (this.op === '=') {
      return Binary(this.logic || '?', this.left, this.right);
    } else {
      return this;
    }
  };
  return Assign;
}(Node));
exports.Import = Import = (function(superclass){
  var prototype = extend$((import$(Import, superclass).displayName = 'Import', Import), superclass).prototype, constructor = Import;
  function Import(left, right, all){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.left = left;
    this$.right = right;
    this$.all = all && 'All';
    if (!all && left instanceof Obj && right.items) {
      return Obj(left.items.concat(right.asObj().items));
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Import.prototype.children = ['left', 'right'];
  Import.prototype.show = function(){
    return this.all;
  };
  prototype.delegate(['isCallable', 'isArray'], function(it){
    return this.left[it]();
  });
  Import.prototype.unfoldSoak = function(o){
    var left, value, ref$, temps;
    left = this.left;
    if (left instanceof Existence && !left.negated) {
      if ((left = left.it) instanceof Var) {
        value = (this.left = left).value;
        if (!o.scope.check(value, true)) {
          left = JS("typeof " + value + " != 'undefined' && " + value);
        }
      } else {
        ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
      }
      return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
    }
    return If.unfoldSoak(o, this, 'left') || (this['void'] || !o.level) && If.unfoldSoak(o, this, 'right');
  };
  Import.prototype.compileNode = function(o){
    var right;
    right = this.right;
    if (!this.all) {
      if (right instanceof Chain) {
        right = right.unfoldSoak(o) || right.unfoldAssign(o) || right;
      }
      if (right instanceof List) {
        return this.compileAssign(o, right.asObj().items);
      }
    }
    return CopyL(this, Call.make(Util("import" + (this.all || '')), [this.left, right])).compileNode(o);
  };
  Import.prototype.compileAssign = function(o, items){
    var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, key, val, logic;
    if (!items.length) {
      return this.left.compile(o);
    }
    top = !o.level;
    if (this.proto || (items.length < 2 && (top || this['void'] || items[0].key instanceof Splat))) {
      reft = this.left;
      if (reft.isComplex()) {
        reft = Parens(reft);
      }
    } else {
      ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
    }
    ref$ = top
      ? [';', '\n' + this.tab]
      : [',', ' '], delim = ref$[0], space = ref$[1];
    delim += space;
    code = this.temps
      ? [left.compile(o, LEVEL_PAREN), delim]
      : [];
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      i = i$;
      node = items[i$];
      i && code.push(com ? space : delim);
      if (com = node.comment) {
        code.push(node.compile(o));
        continue;
      }
      key = node.key, val = node.val, logic = node.logic;
      if (key instanceof Splat) {
        code.push(CopyL(this, Import(reft, val)).compile(o));
        continue;
      }
      if (node.accessor) {
        if (key instanceof Key) {
          key = JS("'" + key.name + "'");
        }
        code.push("Object.defineProperty(", reft.compile(o, LEVEL_LIST), ", ", key.compile(o, LEVEL_LIST), ", ", node.compileDescriptor(o), ")");
        continue;
      }
      logic && (val = (logic.first = val, logic));
      code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));
    }
    if (top) {
      return sn.apply(null, [null].concat(arrayFrom$(code)));
    }
    this['void'] || key instanceof Splat || code.push(com ? ' ' : ', ', reft.compile(o, LEVEL_PAREN));
    if (o.level < LEVEL_LIST) {
      return sn.apply(null, [null].concat(arrayFrom$(code)));
    } else {
      return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
    }
  };
  Import.prototype.rewriteShorthand = function(o, assign){
    var that, ref$, ref1$;
    if (that = (ref$ = this.left) != null ? ref$.rewriteShorthand(o, assign) : void 8) {
      this.left = that;
    }
    if (that = (ref1$ = this.right) != null ? ref1$.rewriteShorthand(o) : void 8) {
      this.right = that;
    }
  };
  return Import;
}(Node));
exports.In = In = (function(superclass){
  var prototype = extend$((import$(In, superclass).displayName = 'In', In), superclass).prototype, constructor = In;
  importAll$(prototype, arguments[1]);
  function In(item, array){
    this.item = item;
    this.array = array;
  }
  In.prototype.children = ['item', 'array'];
  In.prototype.compileNode = function(o){
    var array, items, value, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
    items = (array = this.array).items;
    if (!(array instanceof Arr)) {
      return sn(this, this.negated ? '!' : '', util('in'), "(", this.item.compile(o, LEVEL_LIST), ", ", array.compile(o, LEVEL_LIST), ")");
    }
    if (items.length === 0) {
      if (o.warn) {
        this.warn("value can never be `in` an empty array");
      }
      value = !!this.negated + "";
      return this.item.isComplex()
        ? sn(this, "(", this.item.compile(o, LEVEL_LIST), ", ", value, ")")
        : sn(this, value);
    }
    code = [];
    ref$ = items.length === 1
      ? [ref$ = this.item.compile(o, LEVEL_PAREN), ref$]
      : this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
    ref$ = this.negated
      ? [' !== ', ' && ']
      : [' === ', ' || '], cmp = ref$[0], cnj = ref$[1];
    for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
      i = i$;
      test = items[i$];
      if (code.length > 0) {
        code.push(cnj);
      }
      if (test instanceof Splat) {
        code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));
        if (!(i || sub === ref)) {
          code = ["(" + sub + ", "].concat(arrayFrom$(code), [")"]);
        }
      } else {
        code.push(i || sub === ref
          ? ref
          : "(" + sub + ")", cmp, test.compile(o, LEVEL_OP + PREC['==']));
      }
    }
    sub === ref || o.scope.free(ref);
    if (o.level < LEVEL_OP + PREC[items.length === 1 ? '===' : '||']) {
      return sn.apply(null, [this].concat(arrayFrom$(code)));
    } else {
      return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
    }
  };
  return In;
}(Node, Negatable));
exports.Existence = Existence = (function(superclass){
  var prototype = extend$((import$(Existence, superclass).displayName = 'Existence', Existence), superclass).prototype, constructor = Existence;
  importAll$(prototype, arguments[1]);
  function Existence(it, negated){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.it = it;
    this$.negated = negated;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Existence.prototype.children = ['it'];
  Existence.prototype.compileNode = function(o){
    var node, ref$, code, op, eq, anaphPre, anaphPost, that;
    node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
    code = [node.compile(o, LEVEL_OP + PREC['=='])];
    if (this.doAnaphorize) {
      o.scope.declare('that', Var('that'));
    }
    if (node instanceof Var && !o.scope.check(code.join(""), true)) {
      ref$ = this.negated
        ? ['||', '=']
        : ['&&', '!'], op = ref$[0], eq = ref$[1];
      if (this.doAnaphorize) {
        ref$ = this.negated
          ? [["(that = undefined) || "], []]
          : [[], [" && (that = "].concat(arrayFrom$(code), [", true)"])], anaphPre = ref$[0], anaphPost = ref$[1];
      }
      code = ["typeof "].concat(arrayFrom$(code), [" " + eq + "= 'undefined' " + op + " "], arrayFrom$(code), [" " + eq + "== null"]);
      if ((that = anaphPre) != null) {
        code = that.concat(code);
      }
      if ((that = anaphPost) != null) {
        code = code.concat(that);
      }
    } else {
      if (this.doAnaphorize) {
        code = ["(that = "].concat(arrayFrom$(code), [")"]);
      }
      code.push(" " + (op = this.negated ? '==' : '!=') + " null");
    }
    if (o.level < LEVEL_OP + PREC[op]) {
      return sn.apply(null, [this].concat(arrayFrom$(code)));
    } else {
      return sn(this, "(", code, ")");
    }
  };
  return Existence;
}(Node, Negatable));
exports.Fun = Fun = (function(superclass){
  var prototype = extend$((import$(Fun, superclass).displayName = 'Fun', Fun), superclass).prototype, constructor = Fun;
  function Fun(params, body, bound, curried, hushed, generator, async){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.params = params || [];
    this$.body = body || Block();
    this$.bound = bound && 'this$';
    this$.curried = curried || false;
    this$.hushed = hushed != null ? hushed : false;
    this$.generator = generator != null ? generator : false;
    this$.async = async != null ? async : false;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Fun.prototype.children = ['params', 'body'];
  Fun.prototype.show = function(){
    var that;
    return [this.name] + [(that = this.bound) ? "~" + that : void 8];
  };
  Fun.prototype.named = function(it){
    return this.name = it, this.statement = true, this;
  };
  Fun.prototype.isCallable = YES;
  Fun.prototype.isStatement = function(){
    return !!this.statement;
  };
  Fun.prototype.traverseChildren = function(arg$, xscope){
    if (xscope) {
      return superclass.prototype.traverseChildren.apply(this, arguments);
    }
  };
  Fun.prototype.rewriteShorthand = VOID;
  Fun.prototype.makeReturn = function(){
    if (this.statement) {
      return this.returns = true, this;
    } else {
      return superclass.prototype.makeReturn.apply(this, arguments);
    }
  };
  Fun.prototype.ripName = function(it){
    this.name || (this.name = it.varName());
  };
  Fun.prototype.compileNode = function(o){
    var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this;
    pscope = o.scope;
    sscope = pscope.shared || pscope;
    scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper && sscope);
    scope.fun = this;
    if (that = this.proto) {
      scope.assign('prototype', that.compile(o) + ".prototype");
    }
    if (that = this.cname) {
      scope.assign('constructor', that);
    }
    if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {
      o.indent = this.tab = '';
    }
    o.indent += TAB;
    body = this.body, name = this.name, tab = this.tab;
    code = ['function'];
    if (this.async) {
      this.ctor && this.carp("a constructor can't be async");
      o.inAsync = true;
      code.unshift('async ');
    } else if (!this.wrapper) {
      o.inAsync = false;
    }
    if (this.generator) {
      this.ctor && this.carp("a constructor can't be a generator");
      o.inGenerator = true;
      code.push('*');
    } else if (!this.wrapper) {
      o.inGenerator = false;
    }
    if (this.bound === 'this$') {
      if (this.ctor) {
        scope.assign('this$', 'this instanceof ctor$ ? this : new ctor$');
        body.lines.push(Return(Literal('this$')));
      } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
        this.bound = that;
      } else if (this.usesThis()) {
        sscope.assign('this$', 'this');
      }
    }
    if (this.statement) {
      name || this.carp('nameless function declaration');
      pscope === o.block.scope || this.carp('misplaced function declaration');
      this.accessor && this.carp('named accessor');
      pscope.add(name, 'function', this);
    }
    if (this.statement || name && this.labeled) {
      code.push(' ', scope.add(name, 'function', this));
    }
    this.hushed || this.ctor || this.newed || body.makeReturn();
    code.push("(", this.compileParams(o, scope), ")");
    code = [sn.apply(null, [this].concat(arrayFrom$(code)))];
    code.push("{");
    if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
      code.push("\n", bodyCode, "\n" + tab);
    }
    code.push('}');
    curryCodeCheck = function(){
      if (this$.curried && this$.hasSplats) {
        this$.carp('cannot curry a function with a variable number of arguments');
      }
      if (this$.curried && this$.params.length > 1 && !this$.classBound) {
        if (this$.bound) {
          return [util('curry'), "(("].concat(arrayFrom$(code), ["), true)"]);
        } else {
          return [util('curry'), "("].concat(arrayFrom$(code), [")"]);
        }
      } else {
        return code;
      }
    };
    if (inLoop) {
      return pscope.assign(pscope.temporary('fn'), sn.apply(null, [null].concat(arrayFrom$(curryCodeCheck()))));
    }
    if (this.returns) {
      code.push("\n" + tab + "return ", name, ";");
    } else if (this.bound && this.ctor) {
      code.push(' function ctor$(){} ctor$.prototype = prototype;');
    }
    code = curryCodeCheck();
    if (this.front && !this.statement) {
      return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
    } else {
      return sn.apply(null, [null].concat(arrayFrom$(code)));
    }
  };
  Fun.prototype.compileParams = function(o, scope){
    var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;
    params = this.params, length = params.length, body = this.body;
    for (i$ = params.length - 1; i$ >= 0; --i$) {
      p = params[i$];
      if (!(p.isEmpty() || p.filler)) {
        break;
      }
      --params.length;
    }
    for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
      i = i$;
      p = params[i$];
      if (p.left instanceof Splat) {
        p.carp('invalid splat');
      }
      if (p instanceof Splat) {
        this.hasSplats = true;
        splace = i;
      } else if (p.op === '=') {
        params[i] = Binary(p.logic || '?', p.left, p.right);
      }
    }
    if (splace != null) {
      rest = params.splice(splace, 9e9);
    } else if (this.accessor) {
      if (that = params[1]) {
        that.carp('excess accessor parameter');
      }
    } else if (!(length || this.wrapper)) {
      if (body.traverseChildren(function(it){
        return it.value === 'it' || null;
      })) {
        params[0] = Var('it');
      }
    }
    names = [];
    assigns = [];
    for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
      p = params[i$];
      vr = p;
      if (df = vr.getDefault()) {
        vr = vr.first;
      }
      if (vr.isEmpty()) {
        vr = Var(scope.temporary('arg'));
      } else if (vr.value === '..') {
        vr = Var(o.ref = scope.temporary());
      } else if (!(vr instanceof Var)) {
        unaries = [];
        while (vr instanceof Unary) {
          hasUnary = true;
          unaries.push(vr);
          vr = vr.it;
        }
        v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary('arg'));
        assigns.push(Assign(vr, (fn$())));
        vr = v;
      } else if (df) {
        assigns.push(Assign(vr, p.second, '=', p.op, true));
      }
      names.push(scope.add(vr.value, 'arg', p), ', ');
    }
    if (rest) {
      while (splace--) {
        rest.unshift(Arr());
      }
      assigns.push(Assign(Arr(rest), Literal('arguments')));
    }
    if (assigns.length) {
      (ref$ = this.body).prepend.apply(ref$, assigns);
    }
    names.pop();
    return sn.apply(null, [null].concat(arrayFrom$(names)));
    function fn$(){
      switch (false) {
      case !df:
        return Binary(p.op, v, p.second);
      case !hasUnary:
        return fold(function(x, y){
          y.it = x;
          return y;
        }, v, unaries.reverse());
      default:
        return v;
      }
    }
  };
  Fun.prototype.usesThis = function(){
    return Node.prototype.traverseChildren.call(this, function(it){
      switch (false) {
      case !(it instanceof Literal && it.value === 'this'):
        return true;
      case !(it instanceof Fun && it.bound && it.usesThis()):
        return true;
      }
    });
  };
  return Fun;
}(Node));
exports.Class = Class = (function(superclass){
  var prototype = extend$((import$(Class, superclass).displayName = 'Class', Class), superclass).prototype, constructor = Class;
  function Class(arg$){
    var body;
    this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
    this.fun = Fun([], body);
  }
  Class.prototype.children = ['title', 'sup', 'mixins', 'fun'];
  Class.prototype.isCallable = YES;
  Class.prototype.ripName = function(it){
    this.name = it.varName();
  };
  Class.prototype.getRef = function(){
    var that, ref$;
    if (that = ((ref$ = this.title) != null ? ref$.varName() : void 8) || this.name) {
      return Var(that);
    }
  };
  Class.prototype.compile = function(o, level){
    var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;
    fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
    CopyL(this, fun);
    boundFuncs = [];
    curriedBoundFuncs = [];
    decl = title != null ? title.varName() : void 8;
    name = decl || this.name;
    if (ID.test(name || '')) {
      fun.cname = name;
    } else {
      name = 'constructor';
    }
    proto = Var('prototype');
    vname = fun.proto = Var(fun.bound = name);
    ctorName = 'constructor$$';
    importProtoObj = function(node, i){
      var j, prop, key, i$, ref$, len$, v;
      j = 0;
      for (; j < node.items.length; j++) {
        prop = node.items[j];
        key = prop.key;
        if ((key instanceof Key && key.name === ctorName) || (key instanceof Literal && key.value === "'" + ctorName + "'")) {
          if (ctor) {
            node.carp('redundant constructor');
          }
          ctor = prop.val;
          node.items.splice(j--, 1);
          ctorPlace = i;
        }
        if (!(prop.val instanceof Fun || prop.accessor)) {
          continue;
        }
        if (key.isComplex()) {
          key = Var(o.scope.temporary('key'));
          prop.key = Assign(key, prop.key);
        }
        if (prop.val.bound) {
          if (prop.val.curried) {
            curriedBoundFuncs.push(prop.key);
          } else {
            boundFuncs.push(prop.key);
          }
          prop.val.bound = false;
          prop.val.classBound = true;
        }
        for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ < len$; ++i$) {
          v = ref$[i$];
          v.meth = key;
        }
      }
      if (node.items.length) {
        return ref$ = Import(Chain(vname).add(Index(Key('prototype'))), node), ref$.proto = true, ref$;
      } else {
        return Literal('void');
      }
    };
    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
      i = i$;
      node = lines[i$];
      if (node instanceof Obj) {
        lines[i] = importProtoObj(node, i);
      } else if (node instanceof Fun && !node.statement) {
        ctor && node.carp('redundant constructor');
        ctor = node;
      } else if (node instanceof Assign && node.left instanceof Chain && node.left.head.value === 'this' && node.right instanceof Fun) {
        node.right.stat = node.left.tails[0].key;
      } else {
        node.traverseChildren(fn$);
      }
    }
    ctor || (ctor = lines[lines.length] = this.sup
      ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal('arguments'))]))))
      : Fun());
    if (!(ctor instanceof Fun)) {
      lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
      lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat('arguments', true)]))))));
    }
    ctor.name = name;
    ctor.ctor = true;
    ctor.statement = true;
    for (i$ = 0, len$ = boundFuncs.length; i$ < len$; ++i$) {
      f = boundFuncs[i$];
      ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal("'" + f.name + "'"), Var('prototype')]))));
    }
    for (i$ = 0, len$ = curriedBoundFuncs.length; i$ < len$; ++i$) {
      f = curriedBoundFuncs[i$];
      ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(Key("_" + f.name))), Chain(Var(util('curry'))).add(Call([Chain(Var('prototype')).add(Index(f)), Var('true')]))), Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal("'_" + f.name + "'")]))));
    }
    lines.push(vname);
    args = [];
    if (that = this.sup) {
      args.push(that);
      imports = Chain(Import(Literal('this'), Var('superclass')));
      fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key('displayName'))), Literal("'" + name + "'")), Literal(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var('superclass'));
    }
    if (that = this.mixins) {
      res$ = [];
      for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
        args[args.length] = that[i$];
        res$.push(Import(proto, JS("arguments[" + (args.length - 1) + "]"), true));
      }
      imports = res$;
      body.prepend.apply(body, imports);
    }
    if (fun.cname && !this.sup) {
      body.prepend(Literal(name + ".displayName = '" + name + "'"));
    }
    clas = Parens(Call.make(fun, args), true);
    if (decl && title.isComplex()) {
      clas = Assign(vname, clas);
    }
    if (title) {
      clas = Assign(title, clas);
    }
    return sn(null, clas.compile(o, level));
    function fn$(it){
      var i$, ref$, len$, k, child;
      if (it instanceof Block) {
        for (i$ = 0, len$ = (ref$ = it.lines).length; i$ < len$; ++i$) {
          k = i$;
          child = ref$[i$];
          if (child instanceof Obj) {
            it.lines[k] = importProtoObj(child, i);
          }
        }
      }
    }
  };
  return Class;
}(Node));
exports.Super = Super = (function(superclass){
  var prototype = extend$((import$(Super, superclass).displayName = 'Super', Super), superclass).prototype, constructor = Super;
  function Super(){}
  Super.prototype.isCallable = YES;
  Super.prototype.compile = function(o){
    var scope, that, result, ref$;
    scope = o.scope;
    if (!this.sproto) {
      for (; that = !scope.get('superclass') && scope.fun; scope = scope.parent) {
        result = that;
        if (that = result.meth) {
          return sn(this, 'superclass.prototype', Index(that).compile(o));
        }
        if (that = result.stat) {
          return sn(this, 'superclass', Index(that).compile(o));
        }
        if (that = scope.fun.inClass) {
          return sn(this, that, ".superclass.prototype.", scope.fun.name);
        } else if (that = scope.fun.inClassStatic) {
          return sn(this, that, ".superclass.", scope.fun.name);
        }
      }
      if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
        return sn(this, that, ".superclass");
      }
    }
    return sn(this, 'superclass');
  };
  Super.prototype.maybeKey = function(){
    return Key('super', true);
  };
  return Super;
}(Node));
exports.Parens = Parens = (function(superclass){
  var prototype = extend$((import$(Parens, superclass).displayName = 'Parens', Parens), superclass).prototype, constructor = Parens;
  function Parens(it, keep, string, lb, rb){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.it = it;
    this$.keep = keep;
    this$.string = string;
    this$.lb = lb;
    this$.rb = rb;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Parens.prototype.children = ['it'];
  Parens.prototype.show = function(){
    return this.string && '""';
  };
  prototype.delegate(['isComplex', 'isCallable', 'isArray', 'isRegex', 'isNextUnreachable', 'getRef'], function(it){
    return this.it[it]();
  });
  Parens.prototype.isString = function(){
    return this.string || this.it.isString();
  };
  Parens.prototype.unparen = function(){
    if (this.keep) {
      return this;
    } else {
      return this.it.unparen();
    }
  };
  Parens.prototype.compile = function(o, level){
    var it;
    level == null && (level = o.level);
    it = this.it;
    it.cond || (it.cond = this.cond), it['void'] || (it['void'] = this['void']);
    if (this.calling && (!level || this['void'])) {
      it.head.hushed = true;
    }
    if (!(this.keep || this.newed || level >= LEVEL_OP + PREC[it.op])) {
      return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
    }
    if (it.isStatement()) {
      return it.compileClosure(o);
    } else {
      return sn(null, sn(this.lb, "("), it.compile(o, LEVEL_PAREN), sn(this.rb, ")"));
    }
  };
  Parens.prototype.maybeKey = THIS;
  Parens.prototype.extractKeyRef = function(o, assign, tempOwner){
    var v, ref$, ref, key, val;
    if (tempOwner != null && (v = this.it) instanceof Var && (ref$ = v.temp, delete v.temp, ref$)) {
      (tempOwner.temps || (tempOwner.temps = [])).push(v.value);
    }
    if (this.it instanceof Chain && assign) {
      ref$ = this.it.cacheReference(o), this.it = ref$[0], ref = ref$[1];
      return Parens(ref);
    }
    ref$ = this.it.cache(o, true), key = ref$[0], val = ref$[1];
    if (assign) {
      ref$ = [val, key], key = ref$[0], val = ref$[1];
    }
    this.it = val.unparen();
    return Parens(key);
  };
  Parens.prototype.rewriteShorthand = function(o){
    var that;
    if (that = this.it.rewriteShorthand(o)) {
      this.it = that;
    }
  };
  return Parens;
}(Node));
exports.Splat = Splat = (function(superclass){
  var ref$, prototype = extend$((import$(Splat, superclass).displayName = 'Splat', Splat), superclass).prototype, constructor = Splat;
  function Splat(it, filler){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.it = it;
    this$.filler = filler;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isComplex = ref$.isComplex;
  Splat.prototype.isAssignable = YES;
  Splat.prototype.assigns = function(){
    return this.it.assigns();
  };
  Splat.prototype.compile = function(){
    return this.carp('invalid splat');
  };
  Splat.compileArray = function(o, list, apply){
    var index, i$, len$, node, args, atoms, ref$;
    expand(list);
    index = 0;
    for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
      node = list[i$];
      if (node instanceof Splat) {
        break;
      }
      ++index;
    }
    if (index >= list.length) {
      return sn(this, '');
    }
    if (!list[1]) {
      return sn(this, (apply ? Object : ensureArray)(list[0].it).compile(o, LEVEL_LIST));
    }
    args = [];
    atoms = [];
    for (i$ = 0, len$ = (ref$ = list.splice(index, 9e9)).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (node instanceof Splat) {
        if (atoms.length) {
          args.push(Arr(atoms.splice(0, 9e9)));
        }
        args.push(ensureArray(node.it));
      } else {
        atoms.push(node);
      }
    }
    if (atoms.length) {
      args.push(Arr(atoms));
    }
    return sn(null, (index
      ? Arr(list)
      : args.shift()).compile(o, LEVEL_CALL), sn(this, ".concat("), List.compile(o, args), sn(this, ")"));
  };
  function expand(nodes){
    var index, node, it;
    index = -1;
    while (node = nodes[++index]) {
      if (node instanceof Splat) {
        it = node.it;
        if (it.isEmpty()) {
          nodes.splice(index--, 1);
        } else if (it instanceof Arr) {
          nodes.splice.apply(nodes, [index, 1].concat(arrayFrom$(expand(it.items))));
          index += it.items.length - 1;
        }
      }
    }
    return nodes;
  }
  function ensureArray(node){
    if (node.isArray()) {
      return node;
    }
    util('slice');
    return Call.make(Util('arrayFrom'), [node]);
  }
  return Splat;
}(Node));
exports.Jump = Jump = (function(superclass){
  var prototype = extend$((import$(Jump, superclass).displayName = 'Jump', Jump), superclass).prototype, constructor = Jump;
  function Jump(verb, label){
    this.verb = verb;
    this.label = label;
  }
  Jump.prototype.show = function(){
    var that;
    return (this.verb || '') + ((that = this.label) ? ' ' + that : '');
  };
  Jump.prototype.isStatement = YES;
  Jump.prototype.makeReturn = THIS;
  Jump.prototype.isNextUnreachable = YES;
  Jump.prototype.getJump = function(ctx){
    var that, ref$;
    ctx || (ctx = {});
    if (!ctx[this.verb]) {
      return this;
    }
    if (that = this.label) {
      return !in$(that, (ref$ = ctx.labels) != null
        ? ref$
        : ctx.labels = []) && this;
    }
  };
  Jump.prototype.compileNode = function(o){
    var that, ref$;
    if (that = this.label) {
      in$(that, (ref$ = o.labels) != null
        ? ref$
        : o.labels = []) || this.carp("unknown label \"" + that + "\"");
    } else {
      o[this.verb] || this.carp("stray " + this.verb);
    }
    return sn(this, this.show() + ';');
  };
  Jump.extended = function(sub){
    sub.prototype.children = ['it'];
    this[sub.displayName.toLowerCase()] = sub;
  };
  return Jump;
}(Node));
exports.Throw = Throw = (function(superclass){
  var prototype = extend$((import$(Throw, superclass).displayName = 'Throw', Throw), superclass).prototype, constructor = Throw;
  function Throw(it){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.it = it;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Throw.prototype.getJump = VOID;
  Throw.prototype.compileNode = function(o){
    var ref$;
    return sn(this, "throw ", ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || 'null', ";");
  };
  return Throw;
}(Jump));
exports.Return = Return = (function(superclass){
  var prototype = extend$((import$(Return, superclass).displayName = 'Return', Return), superclass).prototype, constructor = Return;
  function Return(it){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    if (it && it.value !== 'void') {
      this$.it = it;
    }
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Return.prototype.getJump = THIS;
  Return.prototype.compileNode = function(o){
    var that;
    return sn.apply(null, [this, "return"].concat(
      (that = this.it)
        ? [' ', that.compile(o, LEVEL_PAREN)]
        : [], [";"]
    ));
  };
  return Return;
}(Jump));
exports.While = While = (function(superclass){
  var prototype = extend$((import$(While, superclass).displayName = 'While', While), superclass).prototype, constructor = While;
  function While(test, un, mode){
    this.un = un;
    mode && (mode instanceof Node
      ? this.update = mode
      : this.post = true);
    if (this.post || test.value !== '' + !un) {
      this.test = test;
    }
  }
  While.prototype.children = ['test', 'body', 'update', 'else'];
  While.prototype.aSource = 'test';
  While.prototype.aTargets = ['body', 'update'];
  While.prototype.show = function(){
    return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
  };
  prototype.isStatement = prototype.isArray = YES;
  While.prototype.makeComprehension = function(toAdd, loops){
    this.isComprehension = true;
    while (loops.length) {
      toAdd = loops.pop().addBody(Block(toAdd));
      if (!toAdd.isComprehension) {
        toAdd.inComprehension = true;
      }
    }
    return this.addBody(Block(toAdd));
  };
  While.prototype.getJump = function(ctx){
    var i$, ref$, ref1$, len$, node;
    ctx || (ctx = {});
    ctx['continue'] = true;
    ctx['break'] = true;
    for (i$ = 0, len$ = (ref$ = ((ref1$ = this.body) != null ? ref1$.lines : void 8) || []).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if (node.getJump(ctx)) {
        return node;
      }
    }
  };
  While.prototype.addBody = function(body){
    var top;
    this.body = body;
    if (this.guard) {
      this.body = Block(If(this.guard, this.body));
    }
    top = this.body.lines[0];
    if ((top != null ? top.verb : void 8) === 'continue' && !top.label) {
      this.body.lines.length = 0;
    }
    return this;
  };
  While.prototype.addGuard = function(guard){
    this.guard = guard;
    return this;
  };
  While.prototype.addObjComp = function(objComp){
    this.objComp = objComp != null ? objComp : true;
    return this;
  };
  While.prototype.makeReturn = function(it){
    var last, ref$, ref1$, ref2$;
    if (this.hasReturned) {
      return this;
    }
    if (it) {
      if (this.objComp) {
        this.body = Block(this.body.makeReturn(it, true));
      } else {
        if (!(this.body || this.index)) {
          this.addBody(Block(Var(this.index = 'ridx$')));
        }
        last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
        if ((this.isComprehension || this.inComprehension) && !(last != null && last.isComprehension)) {
          (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
          if ((ref1$ = this['else']) != null) {
            ref1$.makeReturn.apply(ref1$, arguments);
          }
          this.hasReturned = true;
        } else {
          this.resVar = it;
          if ((ref2$ = this['else']) != null) {
            ref2$.makeReturn.apply(ref2$, arguments);
          }
        }
      }
    } else {
      this.getJump() || (this.returns = true);
    }
    return this;
  };
  While.prototype.compileNode = function(o){
    var test, ref$, head, that;
    o.loop = true;
    this.test && (this.un
      ? this.test = this.test.invert()
      : this.anaphorize());
    if (this.post) {
      return sn(null, sn(this, 'do {'), this.compileBody((o.indent += TAB, o)));
    }
    test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';
    if (!(this.update || this['else'])) {
      head = !snEmpty(test)
        ? [sn(this, "while ("), test]
        : [sn(this, 'for (;;')];
    } else {
      head = [sn(this, 'for (')];
      if (this['else']) {
        head.push(this.yet = o.scope.temporary('yet'), " = true");
      }
      head.push(sn(this, ";"), test.toString() && ' ', test, sn(this, ";"));
      if (that = this.update) {
        head.push(' ', that.compile(o, LEVEL_PAREN));
      }
    }
    return sn.apply(null, [null].concat(arrayFrom$(head), [sn(this, ') {'), this.compileBody((o.indent += TAB, o))]));
  };
  While.prototype.compileBody = function(o){
    var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ = this;
    o['break'] = o['continue'] = true;
    lines = this.body.lines, yet = this.yet, tab = this.tab;
    code = [];
    ret = [];
    mid = [];
    empty = this.objComp ? '{}' : '[]';
    getResultName = function(){
      return _resultName != null
        ? _resultName
        : _resultName = o.scope.temporary(this$.objComp ? 'resultObj' : 'results');
    };
    last = lines != null ? lines[lines.length - 1] : void 8;
    if (!(this.isComprehension || this.inComprehension) || (last != null && last.isComprehension)) {
      hasLoop = false;
      if (last != null) {
        last.traverseChildren(function(it){
          var ref$;
          if (it instanceof Block && (ref$ = it.lines)[ref$.length - 1] instanceof While) {
            hasLoop = true;
          }
        });
      }
      if (this.returns && !this.resVar) {
        this.resVar = res = o.scope.assign(getResultName(), empty);
      }
      if (this.resVar && (last instanceof While || hasLoop)) {
        temp = o.scope.temporary('lresult');
        lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp
          ? Obj()
          : Arr(), '='));
        if (lines[key$ = lines.length - 1] != null) {
          lines[key$] = lines[key$].makeReturn(temp);
        }
        mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key('push'), '.', true)).add(Call([Chain(Var(temp))])).compile(o), ";\n" + this.tab);
      } else {
        this.hasReturned = true;
        if (this.resVar) {
          this.body.makeReturn(this.resVar);
        }
      }
    }
    if (this.returns) {
      if ((!last instanceof While && !this.hasReturned) || this.isComprehension || this.inComprehension) {
        if (lines[key$ = lines.length - 1] != null) {
          lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);
        }
      }
      ret.push("\n" + this.tab + "return ", res || empty, ";");
      if ((ref$ = this['else']) != null) {
        ref$.makeReturn();
      }
    }
    yet && lines.unshift(JS(yet + " = false;"));
    if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
      code.push("\n", bodyCode, "\n" + tab);
    }
    code.push.apply(code, mid);
    code.push('}');
    if (this.post) {
      code.push(sn(this, " while ("), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, ");"));
    }
    if (yet) {
      code.push(sn(this, " if ("), yet, sn(this, ") "), this.compileBlock(o, Block(this['else'])));
      o.scope.free(yet);
    }
    return sn.apply(null, [null].concat(arrayFrom$(code), arrayFrom$(ret)));
  };
  return While;
}(Node));
exports.For = For = (function(superclass){
  var prototype = extend$((import$(For, superclass).displayName = 'For', For), superclass).prototype, constructor = For;
  function For(it){
    var i$, x$, ref$, len$;
    importAll$(this, it);
    if (this.item instanceof Var && !this.item.value) {
      this.item = null;
    }
    for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      this[x$] = true;
    }
    if (this.own && !this.object) {
      this.carp('`for own` requires `of`');
    }
  }
  For.prototype.children = ['item', 'source', 'from', 'to', 'step', 'body'];
  For.prototype.aSource = null;
  For.prototype.show = function(){
    return ((this.kind || []).concat(this.index)).join(' ');
  };
  For.prototype.addBody = function(body){
    var ref$, that, assignments, x$, assigned, name, ref1$;
    if (this['let']) {
      if (ref$ = this.ref, delete this.ref, ref$) {
        this.item = Literal('..');
      }
      if (that = (ref$ = this.item) != null ? ref$.rewriteShorthand() : void 8) {
        this.item = that;
      }
      assignments = (x$ = [], (that = this.index) && x$.push(Assign(Var(that), Literal('index$$'))), (that = this.item) && x$.push(Assign(that, Literal('item$$'))), x$);
      body = Block(this.guard
        ? (assigned = (function(){
          var i$, x$, ref$, len$, j$, ref1$, len1$, results$ = [];
          for (i$ = 0, len$ = (ref$ = assignments).length; i$ < len$; ++i$) {
            x$ = ref$[i$];
            if (that = x$.assigns()) {
              for (j$ = 0, len1$ = (ref1$ = that).length; j$ < len1$; ++j$) {
                name = ref1$[j$];
                results$.push(Var(name));
              }
            }
          }
          return results$;
        }()), assignments.concat([If((ref1$ = this.guard, delete this.guard, ref1$), Call['let'](assigned, body))]))
        : Call['let'](assignments, body));
    }
    superclass.prototype.addBody.call(this, body);
    if (this['let']) {
      delete this.index;
      delete this.item;
    }
    return this;
  };
  For.prototype.isNextUnreachable = NO;
  For.prototype.compileNode = function(o){
    var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
    o.loop = true;
    temps = this.temps = [];
    if (this.object && this.index) {
      o.scope.declare(idx = this.index);
    } else {
      temps.push(idx = o.scope.temporary('i'));
    }
    if (!this.body) {
      this.addBody(Block(Var(idx)));
    }
    if (!this.object) {
      ref$ = (this.step || Literal(1)).compileLoopReference(o, 'step'), pvar = ref$[0], step = ref$[1];
      pvar === step || temps.push(pvar);
    }
    if (this.from) {
      if (this.ref) {
        this.item = Var(idx);
      }
      ref$ = this.to.compileLoopReference(o, 'to'), tvar = ref$[0], tail = ref$[1];
      fvar = this.from.compile(o, LEVEL_LIST);
      vars = idx + " = " + fvar;
      if (tail !== tvar) {
        vars += ", " + tail;
        temps.push(tvar);
      }
      if (!this.step && +fvar > +tvar) {
        pvar = step = -1;
      }
      eq = this.op === 'til' ? '' : '=';
      cond = +pvar
        ? idx + " " + '<>'.charAt(pvar < 0) + eq + " " + tvar
        : pvar + " < 0 ? " + idx + " >" + eq + " " + tvar + " : " + idx + " <" + eq + " " + tvar;
    } else {
      if (this.ref) {
        this.item = Var(o.scope.temporary('x'));
      }
      if (this.item || this.object && this.own || this['let']) {
        ref$ = this.source.compileLoopReference(o, 'ref', !this.object, true), svar = ref$[0], srcPart = ref$[1];
        svar === srcPart || temps.push(svar);
      } else {
        svar = srcPart = this.source.compile(o, LEVEL_PAREN);
      }
      if (!this.object) {
        if (0 > pvar && ~~pvar === +pvar) {
          vars = idx + " = " + srcPart + ".length - 1";
          cond = idx + " >= 0";
        } else {
          temps.push(lvar = o.scope.temporary('len'));
          vars = idx + " = 0, " + lvar + " = " + srcPart + ".length";
          cond = idx + " < " + lvar;
        }
      }
    }
    this['else'] && (this.yet = o.scope.temporary('yet'));
    head = [sn(this, 'for (')];
    if (this.object) {
      head.push(idx, " in ");
    }
    if (that = this.yet) {
      head.push(that, " = true, ");
    }
    if (this.object) {
      head.push(srcPart);
    } else {
      step === pvar || (vars += ', ' + step);
      head.push(vars, "; ", cond, "; " + (1 == Math.abs(pvar)
        ? (pvar < 0 ? '--' : '++') + idx
        : idx + (pvar < 0
          ? ' -= ' + pvar.toString().slice(1)
          : ' += ' + pvar)));
    }
    this.own && head.push(sn(this, ") if ("), o.scope.assign('own$', '{}.hasOwnProperty'), ".call(", svar, ", ", idx, ")");
    head.push(sn(this, ') {'));
    if (this['let']) {
      this.body.traverseChildren(function(it){
        switch (it.value) {
        case 'index$$':
          it.value = idx;
          break;
        case 'item$$':
          it.value = svar + "[" + idx + "]";
        }
      });
    }
    o.indent += TAB;
    if (this.index && !this.object) {
      head.push('\n' + o.indent, Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP), ';');
    }
    if (this.item && !this.item.isEmpty() && !this.from) {
      head.push('\n' + o.indent, Assign(this.item, JS(svar + "[" + idx + "]")).compile(o, LEVEL_TOP), ';');
    }
    if (this.ref) {
      o.ref = this.item.value;
    }
    body = this.compileBody(o);
    if ((this.item || (this.index && !this.object)) && '}' === body.toString().charAt(0)) {
      head.push('\n' + this.tab);
    }
    return sn.apply(null, [null].concat(arrayFrom$(head), [body]));
  };
  return For;
}(While));
exports.StepSlice = StepSlice = (function(superclass){
  var prototype = extend$((import$(StepSlice, superclass).displayName = 'StepSlice', StepSlice), superclass).prototype, constructor = StepSlice;
  StepSlice.prototype.makeReturn = function(makeReturnArg){
    this.makeReturnArg = makeReturnArg;
    return superclass.prototype.makeReturn.apply(this, arguments);
  };
  StepSlice.prototype.compileNode = function(o){
    var ref$, sub, ref, temps, code;
    this.index = o.scope.temporary('x');
    ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
    this.guard = Binary('<', Literal(this.index), Chain(ref).add(Index(Key('length'))));
    this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);
    if (this.makeReturnArg != null) {
      this.makeReturn(this.makeReturnArg);
    }
    code = [];
    if (temps) {
      code.push(sub.compile(o), ';' + '\n' + o.indent);
    }
    code.push(superclass.prototype.compileNode.apply(this, arguments));
    return sn.apply(null, [this].concat(arrayFrom$(code)));
  };
  function StepSlice(){
    StepSlice.superclass.apply(this, arguments);
  }
  return StepSlice;
}(For));
exports.Try = Try = (function(superclass){
  var prototype = extend$((import$(Try, superclass).displayName = 'Try', Try), superclass).prototype, constructor = Try;
  function Try(attempt, thrown, recovery, ensure){
    var ref$;
    this.attempt = attempt;
    this.thrown = thrown;
    this.recovery = recovery;
    this.ensure = ensure;
    if ((ref$ = this.recovery) != null) {
      ref$.lines.unshift(Assign(this.thrown || Var('e'), Var('e$')));
    }
  }
  Try.prototype.children = ['attempt', 'recovery', 'ensure'];
  Try.prototype.show = function(){
    return this.thrown;
  };
  Try.prototype.isStatement = YES;
  Try.prototype.isCallable = function(){
    var ref$;
    return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) && this.attempt.isCallable();
  };
  Try.prototype.getJump = function(it){
    var ref$;
    return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
  };
  Try.prototype.isNextUnreachable = function(){
    var ref$, that;
    return ((ref$ = this.ensure) != null ? ref$.isNextUnreachable() : void 8) || this.attempt.isNextUnreachable() && ((that = this.recovery) != null ? that.isNextUnreachable() : true);
  };
  Try.prototype.makeReturn = function(){
    var ref$;
    this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);
    if (this.recovery != null) {
      this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);
    }
    return this;
  };
  Try.prototype.compileNode = function(o){
    var code, that;
    o.indent += TAB;
    code = [sn(this, 'try '), this.compileBlock(o, this.attempt)];
    if (that = this.recovery || !this.ensure && JS('')) {
      code.push(sn(that, ' catch (e$) '), this.compileBlock(o, that));
    }
    if (that = this.ensure) {
      code.push(sn(that, ' finally '), this.compileBlock(o, that));
    }
    return sn.apply(null, [null].concat(arrayFrom$(code)));
  };
  return Try;
}(Node));
exports.Switch = Switch = (function(superclass){
  var prototype = extend$((import$(Switch, superclass).displayName = 'Switch', Switch), superclass).prototype, constructor = Switch;
  function Switch(type, topic, cases, $default){
    var last, ref$;
    this.type = type;
    this.topic = topic;
    this.cases = cases;
    this['default'] = $default;
    if (type === 'match') {
      if (topic) {
        this.topic = Arr(topic);
      }
    } else {
      if (topic) {
        if (topic.length > 1) {
          throw "can't have more than one topic in switch statement";
        }
        this.topic = this.topic[0];
      }
    }
    if (this.cases.length && (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 && last.tests[0] instanceof Var && last.tests[0].value === '_') {
      this.cases.pop();
      this['default'] = last.body;
    }
  }
  Switch.prototype.children = ['topic', 'cases', 'default'];
  Switch.prototype.aSource = 'topic';
  Switch.prototype.aTargets = ['cases', 'default'];
  Switch.prototype.show = function(){
    return this.type;
  };
  Switch.prototype.isStatement = YES;
  Switch.prototype.isCallable = function(){
    var i$, ref$, len$, c;
    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
      c = ref$[i$];
      if (!c.isCallable()) {
        return false;
      }
    }
    if (this['default']) {
      return this['default'].isCallable();
    } else {
      return true;
    }
  };
  Switch.prototype.getJump = function(ctx){
    var i$, ref$, len$, c, that;
    ctx || (ctx = {});
    ctx['break'] = true;
    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
      c = ref$[i$];
      if (that = c.body.getJump(ctx)) {
        return that;
      }
    }
    return (ref$ = this['default']) != null ? ref$.getJump(ctx) : void 8;
  };
  Switch.prototype.isNextUnreachable = function(){
    var i$, ref$, len$, c;
    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
      c = ref$[i$];
      if (!c.body.isNextUnreachable()) {
        return false;
      }
    }
    return (ref$ = this['default']) != null ? ref$.isNextUnreachable() : void 8;
  };
  Switch.prototype.makeReturn = function(){
    var i$, ref$, len$, c;
    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
      c = ref$[i$];
      c.makeReturn.apply(c, arguments);
    }
    if ((ref$ = this['default']) != null) {
      ref$.makeReturn.apply(ref$, arguments);
    }
    return this;
  };
  Switch.prototype.compileNode = function(o){
    var tab, topic, ref$, targetNode, target, t, code, stop, i$, len$, i, c, that;
    tab = this.tab;
    topic = this.type === 'match'
      ? (this.topic && (ref$ = Chain(this.topic).cacheReference(o), targetNode = ref$[0], target = ref$[1]), t = target
        ? [targetNode]
        : [], Block(t.concat([Literal('false')])).compile(o, LEVEL_PAREN))
      : !!this.topic && this.anaphorize().compile(o, LEVEL_PAREN);
    code = [sn(this, "switch (", snSafe(topic), ") {\n")];
    stop = this['default'] || this.cases.length - 1;
    o['break'] = true;
    for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
      i = i$;
      c = ref$[i$];
      code.push(c.compileCase(o, tab, i === stop, this.type === 'match' || !topic, this.type, target));
    }
    if (this['default']) {
      o.indent = tab + TAB;
      if (that = this['default'].compile(o, LEVEL_TOP)) {
        code.push(tab + "default:\n", that, "\n");
      }
    }
    return sn.apply(null, [null].concat(arrayFrom$(code), [tab + '}']));
  };
  return Switch;
}(Node));
exports.Case = Case = (function(superclass){
  var prototype = extend$((import$(Case, superclass).displayName = 'Case', Case), superclass).prototype, constructor = Case;
  function Case(tests, body){
    this.tests = tests;
    this.body = body;
  }
  Case.prototype.children = ['tests', 'body'];
  Case.prototype.isCallable = function(){
    return this.body.isCallable();
  };
  Case.prototype.makeReturn = function(){
    var ref$, ref1$;
    if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== 'fallthrough') {
      (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
    }
    return this;
  };
  Case.prototype.compileCase = function(o, tab, nobr, bool, type, target){
    var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;
    tests = [];
    for (i$ = 0, len$ = (ref$ = this.tests).length; i$ < len$; ++i$) {
      test = ref$[i$];
      if (test instanceof Arr && type !== 'match') {
        for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ < len1$; ++j$) {
          t = ref1$[j$];
          tests.push(t);
        }
      } else {
        tests.push(test);
      }
    }
    tests.length || tests.push(Literal('void'));
    if (type === 'match') {
      for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {
        i = i$;
        test = tests[i$];
        tar = Chain(target).add(Index(Literal(i), '.', true));
        tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));
      }
    }
    if (bool) {
      binary = type === 'match' ? '&&' : '||';
      t = tests[0];
      i = 0;
      while (that = tests[++i]) {
        t = Binary(binary, t, that);
      }
      tests = [(this.t = t, this.aSource = 't', this.aTargets = ['body'], this).anaphorize().invert()];
    }
    code = [];
    for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {
      t = tests[i$];
      code.push(tab, sn(t, "case ", t.compile(o, LEVEL_PAREN), ":\n"));
    }
    lines = this.body.lines;
    last = lines[lines.length - 1];
    if (ft = (last != null ? last.value : void 8) === 'fallthrough') {
      lines[lines.length - 1] = JS('// fallthrough');
    }
    o.indent = tab += TAB;
    if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
      code.push(bodyCode, '\n');
    }
    if (!(nobr || ft || (last != null && last.isNextUnreachable()))) {
      code.push(tab + 'break;\n');
    }
    return sn.apply(null, [null].concat(arrayFrom$(code)));
  };
  return Case;
}(Node));
exports.If = If = (function(superclass){
  var prototype = extend$((import$(If, superclass).displayName = 'If', If), superclass).prototype, constructor = If;
  function If($if, then, un){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$['if'] = $if;
    this$.then = then;
    this$.un = un;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  If.prototype.children = ['if', 'then', 'else'];
  If.prototype.aSource = 'if';
  If.prototype.aTargets = ['then'];
  If.prototype.show = function(){
    return this.un && '!';
  };
  If.prototype.terminator = '';
  prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex', 'isNextUnreachable'], function(it){
    var ref$;
    return ((ref$ = this['else']) != null ? ref$[it]() : void 8) && this.then[it]();
  });
  If.prototype.getJump = function(it){
    var ref$;
    return this.then.getJump(it) || ((ref$ = this['else']) != null ? ref$.getJump(it) : void 8);
  };
  If.prototype.makeReturn = function(){
    var ref$;
    this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);
    if (this['else'] != null) {
      this['else'] = (ref$ = this['else']).makeReturn.apply(ref$, arguments);
    }
    return this;
  };
  If.prototype.compileNode = function(o){
    if (this.un) {
      this['if'] = this['if'].invert();
    } else {
      this.soak || this.anaphorize();
    }
    if (o.level) {
      return this.compileExpression(o);
    } else {
      return this.compileStatement(o);
    }
  };
  If.prototype.compileStatement = function(o){
    var code, els;
    code = [sn(this, "if (", this['if'].compile(o, LEVEL_PAREN), ") ")];
    o.indent += TAB;
    code.push(this.compileBlock(o, Block(this.then)));
    if (!(els = this['else'])) {
      return sn.apply(null, [null].concat(arrayFrom$(code)));
    }
    return sn.apply(null, [null].concat(
      arrayFrom$(code), [
        sn(els, ' else '), els instanceof constructor
          ? els.compile((o.indent = this.tab, o), LEVEL_TOP)
          : this.compileBlock(o, els)
      ]
    ));
  };
  If.prototype.compileExpression = function(o){
    var thn, els, code, pad;
    thn = this.then, els = this['else'] || Literal('void');
    this['void'] && (thn['void'] = els['void'] = true);
    if (!this['else'] && (this.cond || this['void'])) {
      return Parens(Binary('&&', this['if'], Parens(thn.unwrap()))).compile(o);
    }
    code = [sn(this, this['if'].compile(o, LEVEL_COND))];
    pad = els.isComplex() ? '\n' + (o.indent += TAB) : ' ';
    code.push(pad + "", sn(thn, "? "), thn.compile(o, LEVEL_LIST), pad + "", sn(els, ": "), els.compile(o, LEVEL_LIST));
    if (o.level < LEVEL_COND) {
      return sn.apply(null, [null].concat(arrayFrom$(code)));
    } else {
      return sn(null, "(", code, ")");
    }
  };
  If.unfoldSoak = function(o, parent, name){
    var that;
    if (that = parent[name].unfoldSoak(o)) {
      parent[name] = that.then;
      return that.cond = parent.cond, that['void'] = parent['void'], that.then = Chain(parent), that;
    }
  };
  return If;
}(Node));
exports.Label = Label = (function(superclass){
  var ref$, prototype = extend$((import$(Label, superclass).displayName = 'Label', Label), superclass).prototype, constructor = Label;
  function Label(label, it){
    var fun;
    this.label = label || '_';
    this.it = it;
    if (this.it.curried) {
      this.carp("can't use label with a curried function (attempted label '" + this.label + "')");
    }
    if (fun = (it instanceof Fun || it instanceof Class) && it || it.calling && it.it.head) {
      fun.name || (fun.name = this.label, fun.labeled = true);
      return it;
    }
  }
  ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isCallable = ref$.isCallable, prototype.isArray = ref$.isArray;
  Label.prototype.show = function(){
    return this.label;
  };
  Label.prototype.isStatement = YES;
  Label.prototype.getJump = function(ctx){
    var ref$;
    ctx || (ctx = {});
    ((ref$ = ctx.labels) != null
      ? ref$
      : ctx.labels = []).push(this.label);
    return this.it.getJump((ctx['break'] = true, ctx));
  };
  Label.prototype.makeReturn = function(){
    var ref$;
    this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);
    return this;
  };
  Label.prototype.compileNode = function(o){
    var label, it, labels;
    label = this.label, it = this.it;
    labels = o.labels = arrayFrom$(o.labels || []);
    if (in$(label, labels)) {
      this.carp("duplicate label \"" + label + "\"");
    }
    labels.push(label);
    it.isStatement() || (it = Block(it));
    return sn(null, sn(this, label, ": "), it instanceof Block
      ? (o.indent += TAB, this.compileBlock(o, it))
      : it.compile(o));
  };
  return Label;
}(Node));
exports.Cascade = Cascade = (function(superclass){
  var prototype = extend$((import$(Cascade, superclass).displayName = 'Cascade', Cascade), superclass).prototype, constructor = Cascade;
  function Cascade(input, output, prog1){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.input = input;
    this$.output = output;
    this$.prog1 = prog1;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Cascade.prototype.show = function(){
    return this.prog1;
  };
  Cascade.prototype.children = ['input', 'output'];
  Cascade.prototype.terminator = '';
  prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){
    return this[this.prog1 ? 'input' : 'output'][it]();
  });
  Cascade.prototype.getJump = function(it){
    return this.output.getJump(it);
  };
  Cascade.prototype.makeReturn = function(ret){
    this.ret = ret;
    return this;
  };
  Cascade.prototype.compileNode = function(o){
    var level, input, output, prog1, ref, ref$, code, out;
    level = o.level;
    input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;
    if (prog1 && ('ret' in this || level && !this['void'])) {
      output.add((ref$ = Literal('..'), ref$.cascadee = true, ref$));
    }
    if ('ret' in this) {
      output = output.makeReturn(this.ret);
    }
    if (ref) {
      prog1 || (output = Assign(Var(ref), output));
    } else {
      ref = o.scope.temporary('x');
    }
    if (input instanceof Cascade) {
      input.ref = ref;
    } else {
      input && (input = Assign(Var(ref), input));
    }
    o.level && (o.level = LEVEL_PAREN);
    code = [input.compile(o)];
    out = Block(output).compile((o.ref = new String(ref), o));
    if (prog1 === 'cascade' && !o.ref.erred) {
      this.carp("unreferred cascadee");
    }
    if (!level) {
      return sn.apply(null, [null].concat(arrayFrom$(code), [input.terminator, "\n", out]));
    }
    code.push(", ", out);
    if (level > LEVEL_PAREN) {
      return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
    } else {
      return sn.apply(null, [null].concat(arrayFrom$(code)));
    }
  };
  return Cascade;
}(Node));
exports.JS = JS = (function(superclass){
  var prototype = extend$((import$(JS, superclass).displayName = 'JS', JS), superclass).prototype, constructor = JS;
  function JS(code, literal, comment){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.code = code;
    this$.literal = literal;
    this$.comment = comment;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  JS.prototype.show = function(){
    if (this.comment) {
      return this.code;
    } else {
      return "`" + this.code + "`";
    }
  };
  JS.prototype.terminator = '';
  prototype.isAssignable = prototype.isCallable = function(){
    return !this.comment;
  };
  JS.prototype.compile = function(it){
    return sn(this, snSafe(this.literal
      ? entab(this.code, it.indent)
      : this.code));
  };
  return JS;
}(Node));
exports.Require = Require = (function(superclass){
  var prototype = extend$((import$(Require, superclass).displayName = 'Require', Require), superclass).prototype, constructor = Require;
  function Require(body){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.body = body;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Require.prototype.children = ['body'];
  Require.prototype.compile = function(o){
    var getValue, processItem, code, i$, ref$, len$, item, this$ = this;
    getValue = function(item, throwError){
      switch (false) {
      case !(item instanceof Key):
        return item.name;
      case !(item instanceof Var):
        return item.value;
      case !(item instanceof Literal):
        return item.value;
      default:
        if (throwError) {
          return this$.carp('invalid require! argument');
        } else {
          return item;
        }
      }
    };
    processItem = function(item){
      var ref$, asg, value, asgValue, toAsg, main;
      ref$ = (function(){
        var ref$;
        switch (false) {
        case !(item instanceof Prop):
          return [
            item.val, (ref$ = item.key) != null
              ? ref$
              : item.val
          ];
        default:
          return [item, item];
        }
      }()), asg = ref$[0], value = ref$[1];
      asgValue = getValue(asg);
      toAsg = toString$.call(asgValue).slice(8, -1) === 'String' ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;
      value = stripString(getValue(value, true));
      main = Chain(CopyL(this, Var('require'))).add(Call([Literal("'" + value + "'")]));
      return sn(item, Assign(toAsg, main).compile(o));
    };
    if (this.body.items != null) {
      code = [];
      for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ < len$; ++i$) {
        item = ref$[i$];
        code.push(processItem(item), ";\n" + o.indent);
      }
      code.pop();
      return sn.apply(null, [null].concat(arrayFrom$(code)));
    } else {
      return sn(null, processItem(this.body));
    }
  };
  return Require;
}(Node));
exports.Util = Util = (function(superclass){
  var prototype = extend$((import$(Util, superclass).displayName = 'Util', Util), superclass).prototype, constructor = Util;
  function Util(verb){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.verb = verb;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Util.prototype.show = Jump.prototype.show;
  Util.prototype.isCallable = YES;
  Util.prototype.compile = function(){
    return sn(this, util(this.verb));
  };
  Util.Extends = function(){
    return Call.make(Util('extend'), [arguments[0], arguments[1]]);
  };
  return Util;
}(Node));
exports.Vars = Vars = (function(superclass){
  var prototype = extend$((import$(Vars, superclass).displayName = 'Vars', Vars), superclass).prototype, constructor = Vars;
  function Vars(vars){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.vars = vars;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  Vars.prototype.children = ['vars'];
  Vars.prototype.makeReturn = THIS;
  Vars.prototype.compile = function(o, level){
    var i$, ref$, len$, v, value;
    for (i$ = 0, len$ = (ref$ = this.vars).length; i$ < len$; ++i$) {
      v = ref$[i$], value = v.value;
      if (!(v instanceof Var)) {
        v.carp('invalid variable declaration');
      }
      if (o.scope.check(value)) {
        v.carp("redeclaration of \"" + value + "\"");
      }
      o.scope.declare(value, v);
    }
    return sn(this, Literal('void').compile(o, level));
  };
  return Vars;
}(Node));
exports.L = function(a, b, node){
  if (node && typeof node === "object") {
    node.first_line = a.first_line + 1;
    node.first_column = a.first_column;
    node.last_line = b.last_line + 1;
    node.last_column = b.last_column;
    node.line = a.first_line + 1;
    node.column = a.first_column;
  }
  return node;
};
exports.CopyL = CopyL = function(a, node){
  if (node && typeof node === "object") {
    node.first_line = a.first_line;
    node.first_column = a.first_column;
    node.last_line = a.last_line;
    node.last_column = a.last_column;
    node.line = a.line;
    node.column = a.column;
  }
  return node;
};
exports.Box = function(v){
  if (typeof v === "object") {
    return v;
  } else {
    return new v.constructor(v);
  }
};
exports.Decl = function(type, nodes, lno){
  if (!nodes[0]) {
    throw SyntaxError("empty " + type + " on line " + lno);
  }
  return DECLS[type](nodes);
};
DECLS = {
  'export': function(lines){
    var i, out, node, that, ref$;
    i = -1;
    out = Util('out');
    while (node = lines[++i]) {
      if (node instanceof Block) {
        lines.splice.apply(lines, [i--, 1].concat(arrayFrom$(node.lines)));
        continue;
      }
      if (that = node instanceof Fun && node.name) {
        lines.splice(i++, 0, Assign(Chain(out, [Index(Key(that))]), Var(that)));
        continue;
      }
      lines[i] = (that = node.varName() || node instanceof Assign && node.left.varName() || node instanceof Class && ((ref$ = node.title) != null ? ref$.varName() : void 8))
        ? Assign(Chain(out, [Index(Key(that))]), node)
        : Import(out, node);
    }
    return Block(lines);
  },
  'import': function(lines, all){
    var i$, len$, i, line;
    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
      i = i$;
      line = lines[i$];
      lines[i] = Import(Literal('this'), line, all);
    }
    return Block(lines);
  },
  importAll: function(it){
    return this['import'](it, true);
  },
  'const': function(lines){
    var i$, len$, node;
    for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
      node = lines[i$];
      node.op === '=' || node.carp('invalid constant variable declaration');
      node['const'] = true;
    }
    return Block(lines);
  },
  'var': Vars
};
function Scope(parent, shared){
  this.parent = parent;
  this.shared = shared;
  this.variables = {};
}
ref$ = Scope.prototype;
ref$.READ_ONLY = {
  'const': 'constant',
  'function': 'function',
  undefined: 'undeclared'
};
ref$.add = function(name, type, node){
  var t, that;
  if (node && (t = this.variables[name + "."])) {
    if (that = this.READ_ONLY[t] || this.READ_ONLY[type]) {
      node.carp("redeclaration of " + that + " \"" + name + "\"");
    } else if (t === type && type === 'arg') {
      node.carp("duplicate parameter \"" + name + "\"");
    } else if (t === 'upvar') {
      node.carp("accidental shadow of \"" + name + "\"");
    }
    if (t === 'arg' || t === 'function') {
      return name;
    }
  }
  this.variables[name + "."] = type;
  return name;
};
ref$.get = function(name){
  return this.variables[name + "."];
};
ref$.declare = function(name, node, constant){
  var that, scope;
  if (that = this.shared) {
    if (this.check(name)) {
      return;
    }
    scope = that;
  } else {
    scope = this;
  }
  return scope.add(name, constant ? 'const' : 'var', node);
};
ref$.assign = function(name, value){
  return this.add(name, {
    value: value
  });
};
ref$.temporary = function(name){
  var ref$;
  name || (name = 'ref');
  while ((ref$ = this.variables[name + "$."]) !== 'reuse' && ref$ !== void 8) {
    name = name.length < 2 && name < 'z'
      ? String.fromCharCode(name.charCodeAt() + 1)
      : name.replace(/\d*$/, fn$);
  }
  return this.add(name + '$', 'var');
  function fn$(it){
    return ++it;
  }
};
ref$.free = function(name){
  return this.add(name, 'reuse');
};
ref$.check = function(name, above){
  var type, ref$;
  if ((type = this.variables[name + "."]) || !above) {
    return type;
  }
  return (ref$ = this.parent) != null ? ref$.check(name, above) : void 8;
};
ref$.checkReadOnly = function(name){
  var that, ref$, key$;
  if (that = this.READ_ONLY[this.check(name, true)]) {
    return that;
  }
  (ref$ = this.variables)[key$ = name + "."] || (ref$[key$] = 'upvar');
  return '';
};
ref$.emit = function(code, tab){
  var vrs, asn, fun, name, ref$, type, that, val, declCode;
  vrs = [];
  asn = [];
  fun = [];
  for (name in ref$ = this.variables) {
    type = ref$[name];
    name = name.slice(0, -1);
    if (type === 'var' || type === 'const' || type === 'reuse') {
      vrs.push(name, ", ");
    } else if (that = type.value) {
      if (~(val = entab(that, tab)).toString().lastIndexOf('function(', 0)) {
        if (val instanceof SourceNode) {
          snRemoveLeft(val, 8);
        } else {
          val = val.slice(8);
        }
        fun.push("function ", name, val, "\n" + tab);
      } else {
        asn.push(name, " = ", val, ", ");
      }
    }
  }
  declCode = vrs.concat(asn);
  declCode.pop();
  fun.pop();
  if (declCode.length > 0) {
    code = sn.apply(null, [this, tab + "var "].concat(arrayFrom$(declCode), [";\n", code]));
  }
  if (fun.length > 0) {
    return sn.apply(null, [this, code, "\n" + tab].concat(arrayFrom$(fun)));
  } else {
    return sn(this, code);
  }
};
function YES(){
  return true;
}
function NO(){
  return false;
}
function THIS(){
  return this;
}
function VOID(){}
UTILS = {
  clone: 'function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}',
  extend: 'function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == \'function\') sup.extended(sub);\n  return sub;\n}',
  bind: 'function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}',
  'import': 'function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}',
  importAll: 'function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}',
  copyWithout: 'function(src, ex){\n  var obj = {}, own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key) && !own.call(ex, key)) obj[key] = src[key];\n  return obj;\n}',
  repeatString: 'function(str, n){\n  for (var r = \'\'; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;\n  return r;\n}',
  repeatArray: 'function(arr, n){\n  for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))\n    if (n & 1) r.push.apply(r, arr);\n  return r;\n}',
  'in': 'function(x, xs){\n  var i = -1, l = xs.length >>> 0;\n  while (++i < l) if (x === xs[i]) return true;\n  return false;\n}',
  out: 'typeof exports != \'undefined\' && exports || this',
  curry: 'function(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length > 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) <\n          f.length && arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}',
  flip: 'function(f){\n  return curry$(function (x, y) { return f(y, x); });\n}',
  partialize: 'function(f, args, where){\n  var context = this;\n  return function(){\n    var params = slice$.call(arguments), i,\n        len = params.length, wlen = where.length,\n        ta = args ? args.concat() : [], tw = where ? where.concat() : [];\n    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }\n    return len < wlen && len ?\n      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);\n  };\n}',
  not: 'function(x){ return !x; }',
  compose: 'function() {\n  var functions = arguments;\n  return function() {\n    var i, result;\n    result = functions[0].apply(this, arguments);\n    for (i = 1; i < functions.length; ++i) {\n      result = functions[i](result);\n    }\n    return result;\n  };\n}',
  deepEq: 'function(x, y, type){\n  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,\n      has = function (obj, key) { return hasOwnProperty.call(obj, key); };\n  var first = true;\n  return eq(x, y, []);\n  function eq(a, b, stack) {\n    var className, length, size, result, alength, blength, r, key, ref, sizeB;\n    if (a == null || b == null) { return a === b; }\n    if (a.__placeholder__ || b.__placeholder__) { return true; }\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n    className = toString.call(a);\n    if (toString.call(b) != className) { return false; }\n    switch (className) {\n      case \'[object String]\': return a == String(b);\n      case \'[object Number]\':\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case \'[object Date]\':\n      case \'[object Boolean]\':\n        return +a == +b;\n      case \'[object RegExp]\':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != \'object\' || typeof b != \'object\') { return false; }\n    length = stack.length;\n    while (length--) { if (stack[length] == a) { return true; } }\n    stack.push(a);\n    size = 0;\n    result = true;\n    if (className == \'[object Array]\') {\n      alength = a.length;\n      blength = b.length;\n      if (first) {\n        switch (type) {\n        case \'===\': result = alength === blength; break;\n        case \'<==\': result = alength <= blength; break;\n        case \'<<=\': result = alength < blength; break;\n        }\n        size = alength;\n        first = false;\n      } else {\n        result = alength === blength;\n        size = alength;\n      }\n      if (result) {\n        while (size--) {\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }\n        }\n      }\n    } else {\n      if (\'constructor\' in a != \'constructor\' in b || a.constructor != b.constructor) {\n        return false;\n      }\n      for (key in a) {\n        if (has(a, key)) {\n          size++;\n          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }\n        }\n      }\n      if (result) {\n        sizeB = 0;\n        for (key in b) {\n          if (has(b, key)) { ++sizeB; }\n        }\n        if (first) {\n          if (type === \'<<=\') {\n            result = size < sizeB;\n          } else if (type === \'<==\') {\n            result = size <= sizeB\n          } else {\n            result = size === sizeB;\n          }\n        } else {\n          first = false;\n          result = size === sizeB;\n        }\n      }\n    }\n    stack.pop();\n    return result;\n  }\n}',
  arrayFrom: 'Array.from || function(x){return slice$.call(x);}',
  split: "''.split",
  replace: "''.replace",
  toString: '{}.toString',
  join: '[].join',
  slice: '[].slice',
  splice: '[].splice'
};
LEVEL_TOP = 0;
LEVEL_PAREN = 1;
LEVEL_LIST = 2;
LEVEL_COND = 3;
LEVEL_OP = 4;
LEVEL_CALL = 5;
(function(){
  this['&&'] = this['||'] = this['xor'] = 0.2;
  this['.&.'] = this['.^.'] = this['.|.'] = 0.3;
  this['=='] = this['!='] = this['~='] = this['!~='] = this['==='] = this['!=='] = 0.4;
  this['<'] = this['>'] = this['<='] = this['>='] = this.of = this['instanceof'] = 0.5;
  this['<<='] = this['>>='] = this['<=='] = this['>=='] = this['++'] = 0.5;
  this['.<<.'] = this['.>>.'] = this['.>>>.'] = 0.6;
  this['+'] = this['-'] = 0.7;
  this['*'] = this['/'] = this['%'] = 0.8;
}.call(PREC = {
  unary: 0.9
}));
TAB = '  ';
ID = /^(?!\d)[\w$\xAA-\uFFDC]+$/;
SIMPLENUM = /^\d+$/;
function util(it){
  return Scope.root.assign(it + '$', UTILS[it]);
}
function entab(code, tab){
  return code.replace(/\n/g, '\n' + tab);
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function repeatArray$(arr, n){
  for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
    if (n & 1) r.push.apply(r, arr);
  return r;
}
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}