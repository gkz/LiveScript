<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<title>LiveScript</title>
<meta name='description' content="LiveScript is a language that compiles down to JavaScript. It is a fork of Coco, which is in turn derived from CoffeeScript. LiveScript is Coco that is much more compatible with CoffeeScript, more functional, and more feature rich.">

<link rel="icon" type="image/png" href="images/icon.png">


<link href="bootstrap/themes/cerulean.bootstrap.min.css" rel="stylesheet">
<link href="bootstrap/css/bootstrap-responsive.css" rel="stylesheet">

<link href="google-code-prettify/prettify.css" rel="stylesheet">

<link href="styles.css" rel="stylesheet">

<script>
  if(window.location.host === "gkz.github.com") {
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-7402515-5']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  }
</script>
</head>
<body data-spy="scroll">
<div class="site container-fluid">
  <div class="row-fluid side-row">
    <div class="span2 sidebar">
      <h1><a href="#">LiveScript</a><img src="images/icon.png"></h1>
      <ul class="nav nav-list">
        <li class="active"><a href="#overview">Overview</a></li> 
        <li class="divider">
        <li><a href="#installation">Installation</a></li> 
        <li><a href="#usage">Usage</a></li> 
        <li><a href="#community">Community</a></li> 
        <li><a href="#editor-support">Text Editor Support</a></li> 
        <li><a href="#prelude-ls">Standard Library</a></li>
        <li class="divider">
        <li><a href="#introduction">Introduction</a></li> 
        <li><a href="#literals">Literals</a></li> 
        <li><a href="#conditions">Conditions</a></li> 
        <li><a href="#functions">Functions</a></li> 
        <li><a href="#loops">Loops and Comprehensions</a></li> 
        <li><a href="#switch">Switch</a></li> 
        <li><a href="#operators">Operators</a></li> 
        <li><a href="#assignment">Assignment</a></li> 
        <li><a href="#property-access">Property Access</a></li> 
        <li><a href="#oop">OOP</a></li> 
        <li class="divider">
        <li><a href="#coffee-to-ls">Converting from CoffeeScript</a></li> 
        <li><a href="#speed">Speed</a></li> 
        <li><a href="#changes">Changes from Coco</a></li> 
        <li><a href="#changelog">Changelog</a></li> 
        <li class="divider">
        <li><a href="#inspiration">Inspiration</a></li> 
        <li><a href="#name">Name</a></li> 
        <li><a href="#thanks">Thanks</a></li> 
        <li><a href="#contributing">Contributing Guide</a></li> 
      </ul>
    </div>
    <div class="span4 compiler">
      <div class="compiler-box">
      <div class="github-buttons">
<a href="https://twitter.com/share" class="twitter-share-button" data-url="http://gkz.github.com/LiveScript/" data-text="LiveScript - functional CoffeeScript" data-related="gkzahariev:The Creator" data-via="gkzahariev">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
        <iframe src="http://markdotto.github.com/github-buttons/github-btn.html?user=gkz&repo=LiveScript&type=watch&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="120px" height="20px"></iframe>
      </div>
        <textarea placeholder="Enter LiveScript here"></textarea>
        <div class="actions">
          <button class="btn btn-primary" data-action="compile" title="Convert LiveScript to JavaScript">Compile</button>
          <button class="btn" data-action="run" title="Run compiled JavaScript">Run</button>
          <button class="btn" data-action="ast" title="Abstract Syntax Tree">AST</button>
          <button class="btn" data-action="tokens" title="Tokenization of input">Tokens</button>
          <button class="btn" data-action="lex" title="Same as tokens, but skipping rewriting">Lex</button>
        </div>
      </div>
      <div class="compiler-output">

      </div>
    </div>
  </div>
  <div class="row-fluid content-row">
    <div class="span2">&nbsp;</div>
    <div class="span6 content">
      <div id="overview" class="section">
        <a name="overview"></a>
        <h2>Overview</h2>
        <p>LiveScript is a language which compiles to JavaScript. It is a fork of <a href="http://satyr.github.com/coco/">Coco</a> which is in turn derived from <a href="http://coffeescript.org/">CoffeeScript</a>. Like those two it has a relatively straightforward mapping to JavaScript. LiveScript is Coco but much more compatible with CoffeeScript, more functional, and more feature rich. LiveScript aims for increased expressiveness and code beauty.
        <p>While adding features to assist in functional style programming, LiveScript also deeply supports imperative and object oriented programming, and has an optional class system with inheritance, calls to super, and more.
        <div class="major-actions">
          <h3 class="download">1.0.0:</h3>
          <a href="https://github.com/gkz/LiveScript/zipball/1.0.0"><div class="btn btn-large btn">zip</div></a>
          <a href="https://github.com/gkz/LiveScript/tarball/1.0.0"><div class="btn btn-large btn">tar.gz</div></a>
          <a href="https://github.com/gkz/LiveScript"><div class="btn btn-large btn-primary">View project on GitHub</div></a>
          <iframe src="http://markdotto.github.com/github-buttons/github-btn.html?user=gkz&repo=LiveScript&type=watch&size=large&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="150" height="40"></iframe>
          <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://gkz.github.com/LiveScript/" data-text="LiveScript - functional CoffeeScript" data-size="large" data-related="gkzahariev:The Creator" data-via="gkzahariev">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
        </div>
<p><a href="https://twitter.com/gkzahariev" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @gkzahariev</a> for updates on LiveScript releases.
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
        <p>Featured blog post: <strong><a href="blog/functional-programming-in-javascript-using-livescript-part-2.html">Functional Programming in JavaScript using LiveScript - Part 2</a></strong>
        <p>Double-click an example to load it into the compiler/repl. CoffeeScript users check out the <a href="#coffee-to-ls">CoffeeScript to LiveScript Conversion Guide</a>.
      <h3>Some Examples</h3>
      <p>Unnested callbacks and parentheses free chaining:
      <div class="example">
        <div class="example-ls">
        <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
<-! $ \h1 .on \click
alert \boom!
</pre>
        </div>
        <div class="example-js">
        <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
$('h1').on('click', function(){
  alert('boom!');
});
</pre>
        </div>
      </div>
      <p>Curried functions, implicit switch, the concat operator, and function composition:
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
take(n, [x, ...xs]:list) =
  | n <= 0     => []
  | empty list => []
  | otherwise  => [x] +++ take n - 1, xs









take 2, [1 2 3 4 5] #=> [1, 2]

takeThree = take 3
takeThree [3 to 8] #=> [3, 4, 5]

# Function composition, 'reverse' from prelude.ls
lastThree = reverse >> takeThree >> reverse
lastThree [1 to 8] #=> [6, 7, 8]
</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var take, takeThree, lastThree, slice$ = [].slice;
take = curry$(function(n, list){
  var x, xs;
  x = list[0], xs = slice$.call(list, 1);
  switch (false) {
  case !(n <= 0):
    return [];
  case !empty(list):
    return [];
  default:
    return [x].concat(take(n - 1, xs));
  }
});
take(2, [1, 2, 3, 4, 5]);

takeThree = take(3);
takeThree([3, 4, 5, 6, 7, 8]);


lastThree = compose$([reverse, takeThree, reverse]);
lastThree([1, 2, 3, 4, 5, 6, 7, 8]);
function curry$(f, args){
  return f.length > 1 ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length && arguments.length ?
      curry$.call(this, f, params) : f.apply(this, params);
  } : f;
}
function compose$(fs){
  return function(){
    var i, args = arguments;
    for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }
    return args[0];
  };
}
</pre>
        </div>
      </div>
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">

# Easy listing of implicit objects using asterisks
table1 =
  * id: 1
    name: \george
  * id: 2
    name: \mike
  * id: 3
    name: \donald

table2 =
  * id: 2
    age: 21
  * id: 1
    age: 20
  * id: 3
    age: 26

# Implicit access, accessignment
upCaseName = (.name.=toUpperCase!)

# Curried functions using -->
sortBy = (prop, list) --> list.sort (a, b) -> 
  | a[prop] < b[prop] => -1
  | a[prop] > b[prop] => 1
  | otherwise         => 0







# List comprehensions, destructuring, piping
[{id:id1, name, age} for {id:id1, name} in table1 for {id:id2, age} in table2 when id1 is id2]
|> sortBy \id
|> each upCaseName # using 'each' from prelude.ls
|> JSON.stringify
#=>
#[{"id":1,"name":"GEORGE","age":20},
# {"id":2,"name":"MIKE",  "age":21},
# {"id":3,"name":"DONALD","age":26}]















# operators as functions, backpipe
fold1 (+) <| map (.age), table2
#=> 67 ('fold1' and 'map' from prelude.ls)
</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var table1, table2, upCaseName,
    sortBy, id1, name, id2, age;
table1 = [
  { id: 1,
    name: 'george' },
  { id: 2,
    name: 'mike' },
  { id: 3,
    name: 'donald' }
];
table2 = [
  { id: 2,
    age: 21 },
  { id: 1,
    age: 20 },
  { id: 3,
    age: 26 }
];
upCaseName = function(it){
  return it.name = it.name.toUpperCase();
};
sortBy = curry$(function(prop, list){
  return list.sort(function(a, b){
    switch (false) {
    case !(a[prop] < b[prop]):
      return -1;
    case !(a[prop] > b[prop]):
      return 1;
    default:
      return 0;
    }
  });
});
JSON.stringify(
each(upCaseName)(
sortBy('id')(
(function(){
  var i$, ref$, len$, ref1$, j$, len1$, ref2$, results$ = [];
  for (i$ = 0, len$ = (ref$ = table1).length; i$ < len$; ++i$) {
    ref1$ = ref$[i$], id1 = ref1$.id, name = ref1$.name;
    for (j$ = 0, len1$ = (ref1$ = table2).length; j$ < len1$; ++j$) {
      ref2$ = ref1$[j$], id2 = ref2$.id, age = ref2$.age;
      if (id1 === id2) {
        results$.push({
          id: id1,
          name: name,
          age: age
        });
      }
    }
  }
  return results$;
}()))));
fold1(curry$(function(x$, y$){
  return x$ + y$;
}))(map(function(it){
  return it.age;
}, table2));
function curry$(f, args){
  return f.length > 1 ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length && arguments.length ?
      curry$.call(this, f, params) : f.apply(this, params);
  } : f;
}
</pre>
        </div>
      </div>
    </div>
    <hr>
    <div id="installation" class="section">
      <a name="installation"></a>
      <h2>Installation</h2>
      <p>To install LiveScript on your system, download it (<a href="https://github.com/gkz/LiveScript/zipball/1.0.0">zip</a>, <a href="https://github.com/gkz/LiveScript/tarball/1.0.0">tar.gz</a>), enter its directory, and run <code>sudo bin/slake install</code>. Using git to download: <code>git clone git://github.com/gkz/LiveScript.git && cd LiveScript && sudo bin/slake install</code>. <a href="http:/nodejs.org">Node.js</a> is required to be installed on your system.</p>
      <p>You can install it through the <a href="http://npmjs.org">Node Package Manager</a>: <strong><code>sudo npm install -g LiveScript</code></strong>.
      <p>You can also use it directly in the browser by including the file in <code>LiveScript/extras/livescript.js</code> via a script tag. In fact, this is how this page operates.</p>
    </div>
    <div id="usage" class="section">
      <a name="usage"></a>
      <h2>Usage</h2>
      <p>Usage: <code>livescript [options] [files] [arguments]</code></p>
      <h3>Options</h3>
      <table class="usage-options table table-striped table-bordered">
        <tr><td>-i, --interactive</td><td>start REPL; use ^J for multiline input</td></tr>
        <tr><td>-c, --compile</td><td>compile to JavaScript and save as .js files</td></tr>
        <tr><td>-d, --prelude</td><td>automatically import prelude.ls</td></tr>
        <tr><td>-k, --const</td><td>compile all variables as constants</td></tr>
        <tr><td>-o, --output DIR</td><td>compile into the specified directory</td></tr>
        <tr><td>-w, --watch</td><td>watch scripts for changes, and repeat</td></tr>
        <tr><td>-s, --stdin</td><td>read stdin</td></tr>
        <tr><td>-e, --eval</td><td>read command line arguments as script</td></tr>
        <tr><td>-r, --require FILE+</td><td>require libraries before executing</td></tr>
        <tr><td>-b, --bare</td><td>compile without the top-level function wrapper</td></tr>
        <tr><td>-p, --print</td><td>print the result to stdout</td></tr>
        <tr><td>-l, --lex</td><td>print the tokens the lexer produces</td></tr>
        <tr><td>-t, --tokens</td><td>print the tokens the rewriter produces</td></tr>
        <tr><td>-a, --ast</td><td>print the syntax tree the parser produces</td></tr>
        <tr><td>-j, --json</td><td>print/compile as JSON</td></tr>
        <tr><td>-n, --nodejs ARGS+</td><td>pass options through to the "node" binary</td></tr>
        <tr><td>-v, --version</td><td>display version</td></tr>
        <tr><td>-h, --help</td><td>display this</td></tr>
      </table>
    </div>
    <div id="community" class="section">
      <a name="community"></a>
      <h2>Community</h2>
      <ul>
        <li><a href="https://groups.google.com/forum/#!forum/livescript">Google Groups</a>
        <li><a href="http://www.reddit.com/r/livescript/">r/livescript</a>
        <li><a href="http://ost.io/gkz/LiveScript">ost.io/gkz/LiveScript</a>
      </ul>
      <h3>Blog</h3>
      <ul>
        <li><a href="blog/functional-programming-in-javascript-using-livescript-part-2.html">Functional Programming in JavaScript using LiveScript - Part 2</a>
        <li><a href="blog/ten-reasons-to-switch-from-coffeescript.html">10 Reasons to Switch from CoffeeScript to LiveScript</a>
        <li><a href="blog/functional-programming-in-javascript-using-livescript-and-prelude-ls.html">Functional Programming in JavaScript using LiveScript and prelude.ls</a>
        <li><a href="blog/livescript-one-liners-to-impress-your-friends.html">10 LiveScript One Liners to Impress Your Friends</a>
      </ul>
      <h3>In the Wild</h3>
      <ul>
        <li><a href="https://github.com/gkz/LiveScript/wiki/Projects-using-LiveScript">Projects using LiveScript</a>
        <li><a href="https://github.com/gkz/LiveScript/wiki/Projects-supporting-LiveScript">Projects supporting LiveScript</a>
      </ul>
      <p>Add your own projects to the lists!
    </div>
    <div id="editor-support" class="section">
      <a name="editor-support"></a>
      <h2>Text Editor Support</h2>
      <ul>
        <li>Vim users check out <a href="https://github.com/gkz/vim-ls">vim-ls</a>.
        <li>TextMate, Chocolat, and Sublime Text bundle for LiveScript: <a href="https://github.com/paulmillr/LiveScript.tmbundle">LiveScript.tmbundle</a>.
        <li>Emacs basic LiveScript support: <a href="https://github.com/tensai-cirno/livescript-mode">livescript-mode</a>
      </ul>
      <p>Add yours to the <a href="https://github.com/gkz/LiveScript/wiki/Projects-supporting-LiveScript">wiki page</a>.
    </div>
    <div id="prelude-ls" class="section">
      <a name="prelude-ls">
      <h2>Standard Libaray</h2>
      <p><a href="http://gkz.github.com/prelude-ls/">prelude.ls</a> is the recommended base library when using LiveScript. It allows you to do things such as:

<pre class="prettyprint lang-ls">
[1 2 3] |> map (* 2) |> filter (> 3) |> fold1 (+) 
#=> 10
</pre>

      <p>You can automatically import prelude.ls when compiling by using the <code>-d</code> or <code>--prelude</code> options.

      <p>Prelude is loaded on this page and you can use it when running things in the compiler/repl to the right.
    </div>
    <hr>
    <div id="introduction" class="section">
      <a name="introduction"></a>
      <h2>Introduction</h2>
      <p>Like many modern languages, blocks are delimited by whitespace indentation and newlines are used instead of semicolons to terminate statements (you can still use semicolons if you want to fit more than one statement on a line).

      <p>For example (LiveScript on the left, compiled JavaScript on the right):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
if 2 + 2 == 4
  doSomething()
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
if (2 + 2 === 4) {
  doSomething();
}
</pre>
        </div>
      </div>

      <p class="note">You can try all these examples for yourself using the LiveScript compiler/repl to the right.

      <p>To further clear things up, you can omit the parentheses when calling a function.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add 2, 3
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
add(2, 3);
</pre>
        </div>
      </div>

      <p>And comments are:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
# from here to the end of the line.
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
// from here to the end of the line.
</pre>
        </div>
      </div>

      <p class="note">Lisp hackers, you may be pleased to know that you can use dashes in the name of your variables and functions. The names are equivalent to, and are compiled to, camel case. Eg. <code>my-value = 42</code> == <code>myValue = 42</code>.

      <p>The file extension for LiveScript is <code>.ls</code>.


      <h3>Defining Functions</h3>

      <p>Defining functions is very lightweight in LiveScript:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

(x, y) -> x + y 

-> # an empty function 

times = (x, y) ->
  x * y
# multiple lines, and be assigned to 
# a var like in JavaScript
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var times;
(function(x, y){ return x + y; });

(function(){});

times = function(x, y){ 
  return x * y;
};


</pre>
        </div>
      </div>

      <p>As you see, function definitions are considerably shorter! You may also have noticed that we have omitted <code>return</code>. In LiveScript, almost everything is an expression and the last one reached is automatically returned. However, you can still use <code>return</code> to force returns if you want, and you can add a bang to your definitions to suppress auto-returning <code>noRet = !(x) -> ...</code>.

      <h3>Assignment</h3>
      <p>Basic assignment is as you would expect, <code>variable = value</code>, and there is no need for variable declarations. However, unlike CoffeeScript, you must use <code>:=</code> to modify variables in upper scopes. 

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

x = 10


do ->
  x = 5

x #=> 10

do ->
  x := 2

x #=> 2
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 10;

(function(){
  var x;
  return x = 5;
})();
x;

(function(){
  return x = 2;
})();
x;
</pre>
        </div>
      </div>
      
      <p>Almost everything is an expression, which means you can do things like:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = if   2 + 2 == 4
    then 10
    else 0
x #=> 10
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 2 + 2 === 4 ? 10 : 0;

x;
</pre>
        </div>
      </div>

      <p>Things such as loops, switch statements, and even try/catch statements are all expressions. 

      <p>If you want to simply declare a variable and not initialize it, you can use <code>var</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
var x
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
</pre>
        </div>
      </div>

      <p>You can also declare constants in LiveScript using <code>const</code>. They are checked at compile time - the compiled JS is no different.
      
      <p>Attempting to compile the following:

<pre class="prettyprint lang-ls">
const x = 10
x = 0
</pre>

      <p>Results in <code>redeclaration of constant "x" on line 2</code>. 

      <p>However, objects are not frozen if declared as constants - you can still modify their properties. You can force all variables to be constants if you compile with the <code>-k</code> or <code>--const</code> flags.


      <h3>Info</h3>

      <p>For differences from CoffeeScript, see the <a href="#coffee-to-ls">CoffeeScript to LiveScript Conversion Guide</a>.
      <p>You can double click any of the examples to load the LiveScript code into the compiler to the right, or you can play around and try out your own code. Press run to execute the compiled JavaScript. Note that LiveScript wraps compiled JS in a safety wrapper <code>(function(){...contents...}).call(this);</code> - this wrapper has been omitted in all examples and this page's compiler output for conciseness.
    </div>
    <div id="literals" class="section">
      <a name="literal"></a>
      <h2>Literals</h2>
      <div class="example">
        <div class="example-ls">
        <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
## Numbers
42
17.34

# Underscores and letters are ignored
64_000km

# Any base can be used from 2 to 36
6~12
2~1000
16~ff

## Boolean
true
false
on
off
yes
no

## Undefined
void
undefined

## Strings
'a string'

# Strings without whitespace can be written with 
# a preceding backslash instead of quotes
\word

# Double quoted strings are interpolated
"The answer is #{2 + 2}"

# Variables can be interpolated without the braces
variable = "world"
"Hello #variable"

# Multiline strings
multiline = "string can be multiline 
            and go on and on 
            beginning whitespace is 
            ignored"
heredoc = '''
            string can be multiline 
            with newlines
            and go on and on 
            beginning whitespace is 
            ignored
'''
## Comments
# a single line comment starts with a #
/* multiline comments
   use this format and are preserved
   in the output unlike single line ones
*/

## Objects - braces are optional
person = 
  age:      23
  eyeColor: \green
  height:   180cm

# Dynamic keys
obj =
  "#variable": 234
  (person.eyeColor): false

# Flagging shorthand
{+debug, -live}

# This
this 
@
@location

## Regex
//
| [!=]==?             # equality
| @@                  # arguments
| <\[(?:[\s\S]*?\]>)? # words
//g

## Lists
[1, person.age, 'French Fries']

# Commas are not needed if the item
# preceding is non callable
[1 2 3 true void \word 'hello there']

# Implicit list
myList = 
  32 + 1
  person.height
  \beautiful

# Listing using asterisks
tree =
  * * 1 
    * * 2
      * 3
    * 4
  * * 5
    * 6
    * * 7
      * 8
      * * 9
        * 10
    * 11
 
# List of strings
<[ list of words ]>

# Ranges 
[2 to 20 by 3]
[4 til 6]
[\A to \D]

# Labels ':label'
:label 4 + 2
</pre>
        </div>
        <div class="example-js">
        <h5>JavaScript</h5>
<pre class="prettyprint lang-js">

42;
17.34;


64000;


8;
8;
255;


true;
false;
true;
false;
true;
false;


void 8; // evaluates to undefined
void 8;


'a string';



'word';
var variable, multiline, heredoc, person, 
    obj, myList, tree, __ref;
"The answer is " + (2 + 2);


variable = "world";
"Hello " + variable;


multiline = "string can be multiline and go on and on beginning whitespace is ignored";




heredoc = 'string can be multiline \nwith newlines\nand go on and on \nbeginning whitespace is \nignored';





/* multiline comments
   use this format and are preserved
   in the output unlike single line ones
*/


person = {
  age: 23,
  eyeColor: 'green',
  height: 180
};

obj = (__ref = {}, __ref[variable + ""] = 234,
  __ref[person.eyeColor] = false, __ref);

({
  debug: true,
  live: false
});

this;
this;
this.location;


/|[!=]==?|@@|<\[(?:[\s\S]*?\]>)?/g;






[1, person.age, 'French Fries'];



[1, 2, 3, true, void 8, 'word', 'hello there'];


myList = [32 + 1, person.height, 'beautiful'];





tree = [[1, [2, 3], 4], 
  [5, 6, [7, 8, [9, 10]], 11]];












['list', 'of', 'words'];


[2, 5, 8, 11, 14, 17, 20];
[4, 5];
["A", "B", "C", "D"];

label: {
  4 + 2;
}
</pre>
        </div>
      </div>
    </div>
    <div id="conditions" class="section">
      <a name="conditions"></a>
      <h2>Conditions</h2>
      <div class="example">
        <div class="example-ls">
        <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
# A bit of setup
months = 12
week   = <[ sun mon tues wed thurs fri sat sun ]>
time   =
  days:  365
  hours: 8760



# Functions defined so that the example can run
doSomething = -> 'do nothing actually'
doOtherThing = -> 'do other thing'
doThirdThing = -> 'do third thing'



# As expected - 'else if' and 'else' are optional
# Meanings of == and === are reveresed from JS
if months == 12 
  doSomething()
else if time.hours === '8760'
  doOtherThing()
else 
  doThirdThing()

# 'is not' and 'isnt'
if time.days is not 366
and months isnt 13
then 'both not true!'

# Post 'if'
doSomething() if months is 12
  
# Chained comprehension
if time.hours < 500 < time.hours then doSomething()

# Formatting, 'if not', and 'in'
if \sun not in week 
then doSomething()
else doOtherThing()

# 'unless' is the same as 'if not', use of 'of'
doOtherThing() unless \hours of time

# 'that' implicitly refers to 
# the value of the condition
halfYear = that / 2 if time.days
</pre>
          </div>
          <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var months, week, time, doSomething, doOtherThing, 
    doThirdThing, that, halfYear;
months = 12;
week = ['sun', 'mon', 'tues', 'wed', 
        'thurs', 'fri', 'sat', 'sun'];
time = {
  days: 365,
  hours: 8760
};
doSomething = function(){
  return 'do nothing actually';
};
doOtherThing = function(){
  return 'do other thing';
};
doThirdThing = function(){
  return 'do third thing';
};
if (months === 12) {
  doSomething();
} else if (time.hours == '8760') {
  doOtherThing();
} else {
  doThirdThing();
}

if (time.days !== 366 && months !== 13) {
  'both not true!';
}


if (months === 12) {
  doSomething();
}
if (time.hours < 500 && 500 < time.hours) {
  doSomething();
}
if (!__in('sun', week)) {
  doSomething();
} else {
  doOtherThing();
}
if (!('hours' in time)) {
  doOtherThing();
}

if (that = time.days) {
  halfYear = that / 2;
}
function __in(x, arr){
  var i = 0, l = arr.length >>> 0;
  while (i < l) if (x === arr[i++]) return true;
  return false;
}
</pre>
          </div>
        </div>
    </div>
    <div id="functions" class="section">
      <a name="functions"></a>
      <h2>Functions</h2>
      <div class="example">
        <div class="example-ls">
        <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
# Functions auto return


# Defining functions
square = (x) -> x * x

# Functions defined this way are curried 
# by default
cube(x) = x * x * x
cube 2 #=> 8

# Extended parameters
setPersonParams = (
  person # target object to set params
  person.age
  person.height
) -> person

person = setPersonParams {}, 21, 180cm 
#=> {age: 12, height: 180}

# Bang call
util! #=> 'available above declaration'

# Creates named function
function util()
  'available above declaration'

# Parentheses free chaining
$ \h1 .find \a .text! #=> LiveScript

# Implicit argument using 'it'
length = -> it.length

# Do call, calls function with no arguments
do -> 42

# Suppress auto return
returnNothing = !(param) -> param
returnNothing \hello # returns nothing

!alsoReturnsNothing(param) = param


# Curried functions
times = (x, y) --> x * y
times 2, 3 #=> 6
timesTwo = times 2
timesTwo 4 #=> 8

alsoCurriedTimes(x, y) = x * y


# Short for (function(a){...}.call(this, b))
let $ = jQuery
  $.isArray [] #=> true

# Short for (function(){...}.call(x))
with person
  @age = 22

# With new context
dog = new
  @name = \spot
  @mutt = true

# Infix application
add = (x, y) -> x + y
3 `add` 4 #=> 7

# Implicit function creation for call/lookup 
# (useful for higher order functions like map)
(.length)


(.join \*)


(obj.)


# Bound functions using ~> (wavy arrow)
thisParam = (param) ~> this[param]
# Bound functions have 'this' lexically bound,
# not dynamically bound as normally.
# Notice the __this = this at the top
# variable declarations in the JS. 
# Use ~~> for bound and curried functions
# or thisParam@(param) = this[param]
# using the alternate definition syntax.
</pre>
          </div>
          <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var square, cube, setPersonParams, person,
  length, returnNothing, alsoReturnsNothing,
  times, timesTwo, alsoCurriedTimes, dog,
  add, thisParam, __this = this;
square = function(x){
  return x * x;
};
cube = __curry(function(x){
  return x * x * x;
});
cube(2);

setPersonParams = function(person, age, height){
  person.age = age;
  person.height = height;
  return person;
};

person = setPersonParams({}, 21, 180);



util();


function util(){
  return 'available above declaration';
}

$('h1').find('a').text();

length = function(it){
  return it.length;
};
(function(){
  return 42;
})();

returnNothing = function(param){
  param;
};
returnNothing('hello');
alsoReturnsNothing = __curry(function(param){
  param;
});
times = __curry(function(x, y){
  return x * y;
});
times(2, 3);
timesTwo = times(2);
timesTwo(4);
alsoCurriedTimes = __curry(function(x, y){
  return x * y;
});
(function($){
  $.isArray([]);
}.call(this, jQuery));

(function(){
  this.age = 22;
}.call(person));

dog = new function(){
  this.name = 'spot';
  this.mutt = true;
};

add = function(x, y){ return x + y; };
add(3, 4);


(function(it){
  return it.length;
});
(function(it){
  return it.join('*');
});
(function(it){
  return obj[it];
});

thisParam = function(param){
  return __this[param];
};

function __curry(f, args){
  return f.length ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length ?
      __curry.call(this, f, params) : f.apply(this, params);
  } : f;
}
</pre>
        </div>
      </div>

      <h3>Backcalls</h3>

      <p>Backcalls are very useful. They allow you to unnest callbacks. They are defined using arrows pointed to the left. All the syntax is the same as regular arrows for defining bound functions (<code><~</code>), curried functions (<code><--, <~~</code>), suppressing return (<code><-!</code>) - except that it is just pointing the other way.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
<- $
alert \boom
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
$(function(){
  return alert('boom');
});
</pre>
        </div>
      </div>

      <p>They can take arguments, and you can specify a placeholder for where you want it to go.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x <- map _, [1 to 3]
x * 2
#=> [2, 4, 6]
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
map(function(x){
  return x * 2;
}, [1, 2, 3]);
</pre>
        </div>
      </div>

      <h3>Partial Application</h3>

      <p>You can partially apply functions using the underscore <code>_</code> as a placeholder. Sometimes, the function you want to deal with isn't curried, or if it is the arguments are not in a good order. In these cases partial application is very useful. 

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

filterNums = filter _, [1 to 5]

filterNums even  #=> [2, 4]
filterNums odd   #=> [1, 3, 5]
filterNums (< 3) #=> [1, 2]
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var filterNums, __slice = [].slice;
filterNums = __partialize(filter, [void 8,
    [1, 2, 3, 4, 5]], [0]);
filterNums(even);
filterNums(odd);
filterNums((function(it){
  return it < 3;
}));
function __partialize(f, args, where){
  return function(){
    var params = __slice.call(arguments), i,
        len = params.length, wlen = where.length,
        ta = args ? args.concat() : [], tw = where ? where.concat() : [];
    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
    return len < wlen && len ? __partialize(f, ta, tw) : f.apply(this, ta);
  };
}
</pre>
        </div>
      </div>

      <p>If you call a partially applied function with no arguments, it will execute as is instead of returning itself, allowing you to use default arguments.

      <p>Partially applied functions are also really useful for piping if the functions you are using don't have a nice argument order and aren't curried (like in underscore.js for instance).

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[1 2 3] 
  |> _.map _, (* 2) 
  |> _.reduce _, (+), 0 
  #=> 12
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var __slice = [].slice;
__partialize(_.reduce, [
  void 8, __curry(function(__x, __y){
    return __x + __y;
  }), 0
], [0])(
__partialize(_.map, [
  void 8, (function(it){ return it * 2; })
], [0])(
[1, 2, 3]));
function __partialize(f, args, where){
  return function(){
    var params = __slice.call(arguments), i,
        len = params.length, wlen = where.length,
        ta = args ? args.concat() : [], tw = where ? where.concat() : [];
    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
    return len < wlen && len ? __partialize(f, ta, tw) : f.apply(this, ta);
  };
}
function __curry(f, args){
  return f.length > 1 ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length && arguments.length ?
      __curry.call(this, f, params) : f.apply(this, params);
  } : f;
}

</pre>
        </div>
      </div>

      <h3>Arguments</h3>

      <p>You can access the <code>arguments</code> object with the shorthand <code>&</code>. The first argument is <code>&0</code>, the second <code>&1</code>, and so on.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

addThreeNumbers = -> &0 + &1 + &2
addThreeNumbers 1 2 3 #=> 6
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var addThreeNumbers;
addThreeNumbers = function(){
  return arguments[0] + arguments[1] + arguments[2];
};
addThreeNumbers(1, 2, 3);
</pre>
        </div>
      </div>

      <p>Note that currying won't work in that situation, as the number of declared arguments in <code>addThreeNumbers</code> is 0.

    </div>
    <div id="loops" class="section">
      <a name="loops"></a>
      <h2>Loops and Comprehensions</h2>
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
# For loops
# for (from) (to|til) (by) (when)
for i from 1 to 10 by 3
  i
# by is optional step value
# from is optional, if omitted 
# 'from 0' is implied
# when (alias case, |) optional guard

for val, i in [7 8 9]
  val 



for key, val of {one: 1, two: 2}
  key





# List Comprehension
r = [x + 1 for x to 10 by 2 when x isnt 4]
# r => [1, 3, 7, 9, 11]





r = ["#x#y" for x in [\a \b] for y in [1 2]]
# r => [ 'a1', 'a2', 'b1', 'b2' ]








# Object Comprehension
r = {[key, val * 2] for key, val of {a: 1, b: 2}}
# r => {a: 2, b: 4}





# While
i = 0
list = [1 to 10]
while n < 9
  n = list[++i]

# until == while not
# while/until can also accept when guard
# else clause executes if loops doesn't run
i = 1
until i > 7 when n isnt 99
  n = list[++i]
else
  10



# do while loop
i = 0
do
  i++
while list[i] < 9 

# while accepts an updated clause
# can be postfix too
i = 0
while list[i] < 9, i++ then i

# while true
i = 0
loop
  \ha
  break if ++i > 20



i = 0
for ever
  \ha
  if ++i > 20
     break
</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var i, val, key, x, r, y, list, n, __ref, __len,
  __res, __i, __j, __ref1, __len1, __run;
for (i = 1; i <= 10; i += 3) {
  i;
}




for (i = 0, __len = (__ref = [7, 8, 9]).length; 
    i < __len; ++i) {
  val = __ref[i];
  val;
}
for (key in __ref = {
  one: 1,
  two: 2
}) {
  val = __ref[key];
  key;
}
__res = [];
for (x = 0; x <= 10; x += 2) {
  if (x !== 4) {
    __res.push(x + 1);
  }
}
r = __res;
__res = [];
for (__i = 0, __len = (__ref = ['a', 'b']).length; __i < __len; ++__i) {
  x = __ref[__i];
  for (__j = 0, __len1 = (__ref1 = [1, 2]).length; __j < __len1; ++__j) {
    y = __ref1[__j];
    __res.push(x + "" + y);
  }
}
r = __res;
__res = {};
for (key in __ref = {
  a: 1,
  b: 2
}) {
  val = __ref[key];
  __res[key] = val * 2;
}
r = __res;
i = 0;
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
while (n < 9) {
  n = list[++i];
}



i = 1;
while (!(i > 7)) {
  __run = true;
  if (n !== 99) {
    n = list[++i];
  }
} if (!__run) {
  10;
}
i = 0;
do {
  i++;
} while (list[i] !== 9);



i = 0;
for (; list[i] !== 9; i++) {
  i;
}
i = 0;
for (;;) {
  'ha';
  if (++i > 20) {
    break;
  }
}
i = 0;
for (;;) {
  'ha';
  if (++i > 20) {
    break;
  }
}
</pre>
        </div>
      </div>
    </div>
    <div id="switch" class="section">
      <a name="switch"></a>
      <h2>Switch</h2>
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
# Auto breaks, multiple conditions
switch 6
case 1   then \hello
case 2 4 then \boom
case 6   
  'here it is'
default \something







# Switch on nothing switches on true
switch
case 5 == 6 
  \never
case false
  'also never'
case 6 / 2 is 3
  'here'

# Fallthrough
# works if last expression of case block
# is 'fallthrough'
result = switch 6
case 6 
  something = 5
  fallthrough
case 4
  'this is it'

result is 'this is it' #=> true

# Alternate syntax using | and =>
switch 'moto' 
| "some thing"     => \hello
| \explosion \bomb => \boom
| <[ the moto ? ]> => 'here it is'
| otherwise        => \something










# Implicit switch after ->, ~>, :, =
func = (param) ->
  | param.length < 5 => param.length
  | otherwise        => param.slice 3

func 'hello' #=> lo





# You can also use _ instead of otherwise
state = | 2 + 2 is 5 => 'I love Big Brother'
        | _          => 'I love Julia'





# CoffeeScript style switches work fine too
day = \Sun
switch day
  when "Mon" then 'go to work'
  when "Tue" then 'go to a movie'
  when "Thu" then 'go drinking'
  when "Fri", "Sat"
      'go dancing'
  when "Sun" then 'drink more'
  else 'go to work'
</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var something, result, func, state, day;
switch (6) {
case 1:
  'hello';
  break;
case 2:
case 4:
  'boom';
  break;
case 6:
  'here it is';
  break;
default:
  'something';
}
switch (false) {
case 5 !== 6:
  'never';
  break;
case !false:
  'also never';
  break;
case 6 / 2 !== 3:
  'here';
}
result = (function(){
  switch (6) {
  case 6:
    something = 5;
    // fallthrough
  case 4:
    return 'this is it';
  }
}());
result === 'this is it';

switch ('moto') {
case "some thing":
  'hello';
  break;
case 'explosion':
case 'bomb':
  'boom';
  break;
case 'the':
case 'moto':
case '?':
  'here it is';
  break;
default:
  'something';
}
func = function(param){
  switch (false) {
  case !(param.length < 5):
    return param.length;
  default:
    return param.slice(3);
  }
};
func('hello');

state = (function(){
  switch (false) {
  case 2 + 2 !== 5:
    return 'I love Big Brother';
  default:
    return 'I love Julia';
  }
}());

day = 'Sun';
switch (day) {
case "Mon":
  'go to work';
  break;
case "Tue":
  'go to a movie';
  break;
case "Thu":
  'go drinking';
  break;
case "Fri":
case "Sat":
  'go dancing';
  break;
case "Sun":
  'drink more';
  break;
default:
  'go to work';
}

</pre>
        </div>
      </div>
    </div>
    <div id="operators" class="section">
      <a name="operators"></a>
      <h2>Operators</h2>
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
n = 0




## Math
# The standard
1 + 2 #=> 3
3 - 4 #=> -1
6 * 2 #=> 12
8 / 4 #=> 2

-3 % 4  #=> -3
-3 %% 4 #=> 1

n++    #=> 1
++n    #=> 2
n = -n #=> -2
n = +n #=> 2
n--    #=> 1
--n    #=> 0

+'23'  #=> 23

# Power - right associative,
# higher precedence than unary ops
2 ** 4     #=> 16
3 ^ 4      #=> 81
-2 ^ 2 ^ 3 #=> -256

## Bitwise and shifts
14 .&. 9   #=> 8
14 .|. 9   #=> 15
14 .^. 9   #=> 7
~9         #=> -10
9  .<<. 2  #=> 36
-9 .>>. 2  #=> -3
-9 .>>>. 2 #=> 1073741821

## Comparison
# Strict equals
2 + 4 == 6      #=> true
\boom is 'boom' #=> true

# Fuzzy Equals
2 === '2'       #=> true

# Strict not equals
\boom != null   #=> true
2 + 2 is not 4  #=> false
n + 1 isnt 1    #=> false

# Fuzzy not equals
\1 !== 1        #=> false

# Greater/less than
2 < 4           #=> true
9 > 7           #=> true
8 <= 8          #=> true
7 >= 8          #=> false

# Chained comparison
1 < 2 < 4        #=> true
1 < 2 == 4/2 > 0 #=> true

## Logic
true and false #=> false
true && false  #=> false

true or false  #=> true
true || false  #=> true

not false      #=> true
!false         #=> true

## In/Of
2 in [1 2 3 4 5] #=> true
\id of {id: 23, name: \rogers} #=> true


## Pipe
# |> turns 'val |> func' into 'func(val)'
reverse = -> it.reverse!
[1 2 3] |> reverse #=> [3, 2, 1]


# <| turns 'func <| val' into 'func(val)'
# useful for avoiding parens
add = (x, y) --> x + y
add 4 <| 5 #=> 9 - instead of add(4) 5

## Function composition
# '(f >> g) x' is 'g(f(x))' 
# '(f << g) x' is 'f(g(x))'
addTwo   = add 2
timesTwo = -> it * 2

addTwoTimesTwo = addTwo >> timesTwo
timesTwoAddTwo = addTwo << timesTwo

addTwoTimesTwo 3 #=> 10
timesTwoAddTwo 3 #=> 8

even = (x) -> x % 2 == 0
odd  = (not) . even


## List 
list1 = <[ one two three ]>
list2 = [\four]

# Concat
list1 +++ list2 #=> ['one', 'two', 'three', 'four']

# Concat when first is list literal
[1] + list2     #=> [1, 'four']

# List repetition when first is list literal
[\ha] * 3       #=> ['ha', 'ha', 'ha']

# Join when right operand is a string literal
list1 * \,      #=> 'one,two,three'

# Unary spread
# when right is list literal, apply to each item
neg = -[4 5 6]  #=> [-4, -5, -6]

## String
'hello' + ' ' + 'world' #=> 'hello world'
string = 'say '         #=> 'say '
string += \yeah         #=> 'say yeah'

# String repetition when first is string literal
'X' * 3      #=> 'XXX'

# String subtraction/division when
# right is string or regex literal
string - /h/ #=> 'say yea'
string / \y  #=> ['sa', ' ', 'eah']

## Min/max - return greater or lesser value
4 >? 8     #=> 8
9 - 5 &lt;? 6 #=> 4

## Existence/Inexistence 
bigfoot ? 'grizzly bear'         #=> 'grizzly bear'
string = \boom if n?             #=> 'boom'
string = 'say yeah' if bigfoot!? #=> 'say yeah'

document?.title                  #=> 'LiveScript'







## instanceof - list literal to right gets expanded
new Date() instanceof Date           #=> true
new Date() instanceof [Date, Object] #=> true

## typeof
typeof /^/  #=> object
typeof! /^/ #=> RegEx

## delete - returns original value
obj = {one: 1, two: 2} 
one = delete obj.one
one #=> 1

## Property copy
# copy enumerable properties from right to left,
# return left value
# <<< for own properties
# import and importAll are aliases
obj <<< three: 3
obj #=> {two: 2, three: 3}
{go: true} <<<< window
document import obj

## Clone - unary, creates prototypical child value
child = ^^(new String)
child.length #=> 0

## Partial application, ops as functions
(+ 2) 4         #=> 6
(*) 4 3         #=> 12

(not) true      #=> false
(in [1 to 3]) 2 #=> true
</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var n, reverse, add, addTwo, timesTwo,
    addTwoTimesTwo, timesTwoAddTwo, even, 
    odd, list1, list2, neg, string, obj,
    one, child, __ref, __slice = [].slice, 
    __join = [].join, __replace = ''.replace, 
    __split = ''.split, __toString = {}.toString;
n = 0;
1 + 2;
3 - 4;
6 * 2;
8 / 4;

-3 % 4;
((-3) % (__ref = 4) + __ref) % __ref;

n++;
++n;
n = -n;
n = +n;
n--;
--n;

+'23';



Math.pow(2, 4);
Math.pow(3, 4);
-Math.pow(2, Math.pow(2, 3));


14 & 9;
14 | 9;
14 ^ 9;
~9;
9 << 2;
-9 >> 2;
-9 >>> 2;



2 + 4 === 6;
'boom' === 'boom';


2 == '2';


'boom' !== null;
2 + 2 !== 4;
n + 1 !== 1;


'1' != 1;


2 < 4;
9 > 7;
8 <= 8;
7 >= 8;


1 < 2 && 2 < 4;
1 < 2 && 2 === (__ref = 4 / 2) && __ref > 0;


true && false;
true && false;

true || false;
true || false;

!false;
!false;


2 == 1 || 2 == 2 || 2 == 3 || 2 == 4 || 2 == 5;
'id' in {
  id: 23,
  name: 'rogers'
};
reverse = function(it){
  return it.reverse();
};
reverse([1, 2, 3]);

add = __curry(function(x, y){
  return x + y;
});
add(4)(5);



addTwo = add(2);
timesTwo = function(it){
  return it * 2;
};
addTwoTimesTwo = __compose((timesTwo),(addTwo));
timesTwoAddTwo = __compose((addTwo),(timesTwo));

addTwoTimesTwo(3);
timesTwoAddTwo(3);

even = function(x){
  return x % 2 === 0;
};
odd = __compose((__not),(even));

list1 = ['one', 'two', 'three'];
list2 = ['four'];


list1.concat(list2);


[1].concat(__slice.call(list2));


['ha', 'ha', 'ha'];


__join.call(list1, ',');



neg = [-4, -5, -6];


'hello' + ' ' + 'world';
string = 'say ';
string += 'yeah';


'XXX';



__replace.call(string, /h/, '');
__split.call(string, 'y');


4 > 8 ? 4 : 8;
(__ref = 9 - 5) < 6 ? __ref : 6;

(typeof bigfoot == 'undefined' || 
bigfoot === null) && 'grizzly bear';
if (n != null) {
  string = 'boom';
}
if (typeof bigfoot == 'undefined' || 
bigfoot === null) {
  string = 'say yeah';
}
if (typeof document != 'undefined' &&
document !== null) {
  document.title;
}

new Date() instanceof Date;
(__ref = new Date()) instanceof Date || 
__ref instanceof Object;

typeof /^/;
__toString.call(/^/).slice(8, -1);

obj = {
  one: 1,
  two: 2
};
one = obj.one, delete obj.one;
one;




obj.three = 3;
obj;
__importAll({
  go: true
}, window);
__import(document, obj);
child = __clone(new String);
child.length;


(function(it){ return it + 2; })(4);
__curry(function(__x, __y){ return __x * __y; })
  (4, 3);
__not(true);
(function(it){ 
  return it == 1 || it == 2 || it == 3; })(2);

function __curry(f, args){
  return f.length > 1 ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length && arguments.length ?
      __curry.call(this, f, params) : f.apply(this, params);
  } : f;
}
function __compose(f, g){
  return function(){ return f(g.apply(this, arguments)); }
}
function __not(x){ return !x; }
function __importAll(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
function __import(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function __clone(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
</pre>
        </div>
      </div>
    </div>
    <div id="assignment" class="section">
      <a name="assignment"></a>
      <h2>Assignment</h2>
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
# Basic
x = 10
var y # Can declare without initializing

# Nondeclaring assignment using :=
# := must be used to modify variables
# in upper scopes unlike in CoffeeScript
do ->
  x = 5
x #=> 10

do ->
  x := 2
x #=> 2

# Constants
const z = 3
# 'z = 2' would result in compile time error

# Compound assign
# (no compound assign for bitwise ops)
x += 2   #=> 4
x -= 1   #=> 3
x *= 3   #=> 9
x /= 3   #=> 3
x %= 3   #=> 0
x %%= 3  #=> 0
x &lt;?= -1 #=> -1
x >?= 2  #=> 2
x **= 2  #=> 4
x ^= 2   #=> 16

x ?= 10
x        #=> 16
x !?= 8
x        #=> 8

x ||= 5  #=> 8
x &&= 5  #=> 5

# ?, !?, ||, or && can prefix any 
# compound assign
x &&+= 3 #=> 8
x ?*= 2
x        #=> 8

# Unary assignment
y = \45
+  = y   #=> 45   (make into number)
!! = y   #=> true (make into boolean)
-~-~ = y #=> 3    (int-coercing double crement)

# Assignment defaults
# can use || && ? !?
x ? y = 10
y        #=> 10

# Can use = instead of ? in function parameters
f = (z = 7) -> z
f 9      #=> 9
f!       #=> 7



f = (z && 5) -> z
f!       #=> (nothing)
f 3      #=> 5

# Destructering
one = \boom
two = \lala
list = [one, two] #=> ['boom', 'lala']
[two, one] = list #=> ['lala', 'boom']

[first, ...middle, last] = [1 to 5]
first  #=> 1
middle #=> [2, 3, 4]
last   #=> 5

mitch =
  age:    21
  height: 180cm
  pets:    [\dog, \goldfish]
  fam:
    bro: \phile

{age, height, pets: [pet1, pet2], fam: {bro}} = mitch
height #=> 180
bro    #=> 'phile'
pet1   #=> 'dog'

# You can also rename things via :label
{height:tallness} = mitch
tallness #=> 180

# Subdestructering - works with lists and objects
phile = {}
phile{height, pets} = mitch
phile.height #=> 180
phile.pets   #=> ['dog', 'goldfish']

# Soak assign - performs assign only 
# if right side value exists
x? = age     
x #=> 21
</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var x, y, f, one, two, list, first, middle, last, 
  mitch, age, height, pet1, pet2, bro, tallness,
  phile, __ref, __i, __slice = [].slice;

x = 10;

(function(){
  var x;
  return x = 5;
})();
x;
(function(){
  return x = 2;
})();
x;

z = 3;




x += 2;
x -= 1;
x *= 3;
x /= 3;
x %= 3;
x = ((x) % (__ref = 3) + __ref) % __ref;
x <= (__ref = -1) || (x = __ref);
x >= 2 || (x = 2);
x = Math.pow(x, 2);
x = Math.pow(x, 2);

x == null && (x = 10);
x;
x != null && (x = 8);
x;

x || (x = 5);
x && (x = 5);



x && (x += 3);
x == null && (x *= 2);
x;


y = '45';
y = +y;
y = !!y;
y = -~-~y;



x == null && (y = 10);
y;

f = function(z){
  z == null && (z = 7);
  return z;
};
f(9);
f();
f = function(z){
  z && (z = 5);
  return z;
};
f();
f(3);
one = 'boom';
two = 'lala';
list = [one, two];
two = list[0], one = list[1];
__ref = [1, 2, 3, 4, 5], first = __ref[0], middle = 1 < (__i = __ref.length - 1) ? __slice.call(__ref, 1, __i) : (__i = 1, []), last = __ref[__i];
first;
middle;
last;
mitch = {
  age: 21,
  height: 180,
  pets: ['dog', 'goldfish'],
  fam: {
    bro: 'phile'
  }
};
age = mitch.age, height = mitch.height, __ref = mitch.pets, pet1 = __ref[0], pet2 = __ref[1], bro = mitch.fam.bro;
height;
bro;
pet1;
tallness = mitch.height;
tallness;

phile = {};
phile.height = mitch.height, phile.pets = mitch.pets;
phile.height;
phile.pets;


if (age != null) {
  x = age;
}
x;
</pre>
        </div>
      </div>
    </div>
    <div id="property-access" class="section">
      <a name="property-access"></a>
      <h2>Property Access</h2>
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
# Standard
[1 2 3][1]     #=> 2
{a: 1, b: 2}.b #=> 2

# Dot Access - dot operators can accept many
# more things other than identifiers as their
# right operand, including numbers, strings,
# parentheses, brackets, and braces
x = "hello world": [4 [5 boom: 6]]
x.'hello world'.1.[0] #=> 5






# Accessignment using .=
document.title.=toUpperCase! #=> LIVESCRIPT

# Array slice
list = [1 2 3 4 5]
list[2, 4]    #=> [3, 5]
list[1 to 3]  #=> [2, 3, 4]
list[1 til 3] #=> [2, 3]
list[1 til 3] = [7, 8]
list          #=> [1, 7, 8, 4, 5]




# Object slice
obj = one: 1, two: 2
obj{first: one, two} #=> {first: 1, two: 2}

# Length star [*]
list[*] = 6
list        #=> [1, 2, 3, 4, 5, 6]
list[*-1]   #=> 6

# Semiautovivification .@ .@@
# ensures that the property exists 
# as an object or as an array
x.@@'hello world'.1.@1.boom #=> 6
</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var x, list, obj, __ref;
[1, 2, 3][1];
({
  a: 1,
  b: 2
}).b;
x = {
  "hello world": [
    4, [
      5, {
        boom: 6
      }
    ]
  ]
};
x['hello world'][1][0];

document.title = document.title.toUpperCase();


list = [1, 2, 3, 4, 5];
[list[2], list[4]];
[list[1], list[2], list[3]];
[list[1], list[2]];
__ref = [7, 8], list[1]=__ref[0], list[2]=__ref[1];
list;

obj = {
  one: 1,
  two: 2
};
({
  first: obj.one,
  two: obj.two
});
list[list.length] = 6;
list;
list[list.length - 1];



((__ref = (x['hello world'] || (x['hello world'] = []))[1])[1] || (__ref[1] = {})).boom;
</pre>
        </div>
      </div>
    </div>
    <div id="oop" class="section">
      <a name="oop"></a>
      <h2>Object Oriented Programming</h2>
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
class Item
  # constructor
  ->
    @id = Math.random!
    @x = 10

  @static = 'static'
  # properties and methods
  type: \unknown
  boundToInstance: ~> @x

Renameable =
  setName: -> @name = it
  getName: -> @name ? @id
 
class Box extends Item implements Renameable
  (@name) ->
    super ...

  type: \cube
 
  # any code
  priv    = \secret
  @static = -> priv

thing = new Box \boxy
thing.getName! #=> \boxy
thing.id       #=> (some random number)
thing.type     #=> 'cube'
thing.priv     #=> (nothing)
Box.static!    #=> 'secret'
Box::type = \block 
thing.type     #=> 'block' 

thing.boundToInstance! #=> 10

# infix with - "cloneport"
thing2 = thing with name: \boxahoy
thing2.name           #=> 'boxahoy'
thing2.type           #=> 'block'
thing2 instanceof Box #=> true

</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var Item, Renameable, Box, thing, thing2, __ref;
Item = (function(){
  Item.displayName = 'Item';
  var prototype = Item.prototype, constructor = Item;
  function Item(){
    this.boundToInstance = __bind(this, 'boundToInstance', prototype);
    this.id = Math.random();
    this.x = 10;
  }
  Item['static'] = 'static';
  prototype.type = 'unknown';
  prototype.boundToInstance = function(){
    return this.x;
  };
  return Item;
}());
Renameable = {
  setName: function(it){
    return this.name = it;
  },
  getName: function(){
    var __ref;
    return (__ref = this.name) != null
      ? __ref
      : this.id;
  }
};
Box = (function(superclass){
  Box.displayName = 'Box';
  var priv, prototype = __extend(Box, superclass).prototype, constructor = Box;
  __importAll(prototype, arguments[1]);
  function Box(name){
    this.name = name;
    superclass.apply(this, arguments);
  }
  prototype.type = 'cube';
  priv = 'secret';
  Box['static'] = function(){
    return priv;
  };
  return Box;
}(Item, Renameable));
thing = new Box('boxy');
thing.getName();
thing.id;
thing.type;
thing.priv;
Box['static']();
Box.prototype.type = 'block';
thing.type;
thing.boundToInstance();
thing2 = (__ref = __clone(thing), __ref.name = 'boxahoy', __ref);
thing2.name;
thing2.type;
thing2 instanceof Box;
function __bind(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function __extend(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function __importAll(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
function __clone(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
</pre>
        </div>
      </div>
    </div>
    <hr>
    <div class="section" id="coffee-to-ls">
      <a name="coffee-to-ls"></a>
      <h2>CoffeeScript to LiveScript Conversion Guide</h2>
      <ul>
        <li>Change all your fat arrows <code>=></code> to wavy arrows <code>~></code>
        <li>Change all your block comments <code>### ###</code> to <code>/* */</code>
        <li>Change any range syntax creating lists from <code>[x..y]</code> to <code>[x to y]</code> and change <code>[x...y]</code> to <code>[x til y]</code>
        <li>Similarly, change any range syntax in for loops from <code>for i in [x..y]</code> to <code>for i from x to y</code> and change <code>for i in [x...y]</code> to <code>for i from x til y</code>
        <li>Change any list comprehensions from <code>(x for x in list)</code> to <code>[x for x in list]</code>. Any postfix loops which you do not want returning a list, change to not postfixed, eg. change <code>increase x for x in list</code> to <code>for x in list then increase x</code>. You can shave characters if you wish by using the alias to <code>then</code>, the fat arrow <code>=></code>
        <li>Change any number literals starting with a dot, eg. <code>.5</code> to start with a zero <code>0.5</code>
        <li>Change any regular expression literals from <code>/// ///</code> to <code>// //</code>
        <li>Change any splats you are using from <code>(args...) -></code> to be prefixed like <code>(...args) -></code>
        <li>Remove the parentheses from function definitions with no parameters, <code>() -></code> simply becomes <code>-></code> - this is because <code>()</code> is always a call.
        <li>Change your constructor functions in your classes from being defined as 
<pre>
class Item
  constructor: ->
</pre> to simply being functions at the top level of your class body, eg.
<pre>
class Item
  -> 
</pre>
        <li>Change any calls to super from <code>super</code> to <code>super ...</code> - this is because <code>super</code> is a direct reference to the parent function rather than a call itself.
        <li>Change any bitwise operators to themselves surrounded by dots. Eg. <code>&amp;</code> is now <code>.&amp;.</code> and <code>&gt;&gt;</code> is now <code>.&gt;&gt;.</code>
        <li>If you are modifying variables in upper scopes at any time, eg.
<pre>
x = 10
do ->
  x = 5
</pre> you must use <code>:=</code> instead of just <code>=</code> as that will declare a new (shadowing) variable in LiveScript. Thus, the above code would need to be
<pre>
x = 10
do ->
  x := 5
</pre> if you wanted to modify <code>x</code>
      <li>If you are using nested list comprehensions (eg. <code>(x + y for x in [1, 2] for y in [3, 4])</code>, you will need to change how you handle the result as instead of being a lists within a list as in CoffeScript (the result of the example would be <code>[[4,5],[5,6]]</code>), the result is flattened (the result of the example in LiveScript would be <code>[4,5,5,6]</code>) 
      <li>Change the name of any of your variables named <code>it</code>, <code>that</code>, <code>fallthrough</code>, or <code>otherwise</code>. Those are terrible names for variables so you should change them anyway. This technically isn't required in all cases, but will be less confusing if you do so in all cases. <code>it</code> is used as the implicit argument of functions defined with no parameters, eg. <code>reverse = -> it.reverse!</code>. <code>that</code> refers to the value of the condition, for instance <code>that + 2 if (x + 10)/(y - 18)</code>, <code>that == (x + 10)/(y-18)</code>. <code>fallthrough</code>, if used at the end of a case block makes that block fallthrough to the next case. <code>otherwise</code>, if used directly after case, turns that case into default.
      <li>If you have any multiline strings non triple quoted strings (using <code>"string"</code> or <code>'string'</code>), eg.
<pre>
text = "hi 
        there"
</pre> you will have to change them as in CoffeeScript this would be <code>"hi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;there"</code> while LiveScript ignores indentation after newlines so it would be <code>"hi there"</code>
      <li><code>and</code>, <code>or</code> and spaced <code>.</code> and <code>?.</code> close implicit calls, so you will have to change any code involving those where you have depended on CoffeeScript to not close the call. Eg. <code>f a .g b or h c</code> would be <code>f(a.g(b || h(c)))</code> in CoffeeScript and <code>f(a).g(b) || h(c)</code> in LiveScript.
      <li>Change any <code>do</code>s special casing function literals to using <code>let</code>. Eg. in CoffeScript <code>do ($ = jQuery) -> $</code> change to
<pre>
let $ = jQuery
  $
</pre>
      <li>Change any implicit calls against blocks starting with an implicit objects to use <code>do</code>. Eg. change 
<pre>
f
  a: b
</pre> into
<pre>
f do
  a: b
</pre>
      <li>Remove any JavaScript code literals, eg. <code>`js code here`</code>. That functionality is no longer availible in LiveScript. Rewrite the code to use LiveScript instead. 
      <li>Change any dually spaced property access, eg. <code>x . y</code> to be either spaced on only one side or not at all. A dually spaced dot is now used to compose functions.
      <li>Change any non spaced identifier subtraction, eg. <code>a-b</code> to spaced <code>a - b</code>. <code>a-1</code> and <code>1-b</code> are still fine. This is because <code>a-b</code> is a valid identifier in LiveScript, equivalent to its camel case, <code>aB</code>.
      </ul>
    </div>
    <div id="speed" class="section">
      <a name="speed"></a>
      <h2>Speed</h2>
      <p>Harder, better, <strong>faster</strong>, stronger.
      <h5>CoffeeScript (1.3.1)</h5>
<pre>
$ cake bench
Lex     1365 ms (24146 tokens)
Rewrite  120 ms (26886 tokens)
Parse    277 ms
Compile  189 ms (149436 chars)
total   1951 ms
</pre>
      <h5>LiveScript</h5>
<pre>
$ slake bench
Lex      241 ms (27289 tokens)
Rewrite   98 ms (32717 tokens)
Parse    266 ms (27910 nodes)
Compile  246 ms (181132 chars)
TOTAL    851 ms
</pre>
      <p>For more improvements see <a href="https://github.com/satyr/coco/wiki/improvements">Coco's list of improvements</a>.
    </div>
    <div class="section" id="changes">
      <a name="changes"></a>
      <h2>Changes from Coco: Detail and Rationale</h2>
      <ul>
      <li>Renamed everything from Coco and Coke to LiveScript and Slake, and file extension from .co to .ls. Rationale for names chosen: LiveScript was the name of JavaScript before it was named JavaScript - thus it seemed like an appropriate name, also few if any other projects are named LiveScript. Slake because lake was taken and lsake sounds bad. 
      <li>Switched so that <code>==</code> compiles into <code>===</code>, and also for the negatives. Rationale: Most people would want to use the JavaScript <code>===</code> more often than <code>==</code> and less typing is better, also this makes things more similar to CoffeeScript which compiles <code>==</code> to <code>===</code> so there is less code for people to change coming from CoffeeScript. The compilation of <code>is</code> to <code>===</code> stays the same.
      <li>Switched <code>in</code> and <code>of</code> so that they are like in CoffeeScript. In goes over values, of over keys. Rationale: People have to change less of their CoffeeScript code, they're used to it, and using <code>in</code> for checking if a value is in an array just seems right, using <code>of</code> just feels weird.
      <li>All bitwise operators except <code>~</code> have changed to be surrounded by dots, eg. <code>&amp;</code> is now <code>.&amp;.</code> and <code>&gt;&gt;</code> is <code>.&gt;&gt;.</code>. Bitwise assign equals (eg. <code>&amp;=</code>) have been removed. Rationale: People rarely use the bitwise operators all the time, and they take up valuable symbols that could be used for other purposes. They are still available, just in a longer form. <code>~</code> is still there as is. 
      <li><code>=></code>, the pipe operator using <code>_</code>, is removed. Free up => (for <code>then</code> alias), (<code>|</code> is used as an alias for case). Use other pipes (<code>|></code>) and partial application instead.
      <li><code>|</code> is an alias for <code>case</code> (used in switch) Rationale: less typing, looks good. Modelled after Haskell's guards.
      <li><code>=></code> is an alias for <code>then</code>. Rationale: will not be encouraged for use in if statements as it looks slightly odd - really for use in switch statements, when combined with <code>|</code>, to create a succinct and easy to understand structure. Based off of Haskell's use of -> in case expressions.  
      <li>Added <code>otherwise</code> and underscore <code>_</code> as a contextual keyword, when used after <code>case</code> or <code>|</code>, making that the default statement. Rationale: same as in Haskell (otherwise), underscore as in Scala - and shorter. It allows <code>| otherwise => 4 + 9</code>, which fits in with the rest of the structure.
      <li>Added implicit <code>switch</code> after <code>-></code>, <code>~></code>, <code>:</code>, or an assign when they are followed by case tokens (either <code>case</code> or <code>|</code>). Rationale: reduces typing and increases beauty in a common situation for using a switch, with no increase in ambiguity. 
      <li>Added list concat operator, <code>+++</code>. Eg. <code>xs +++ ys</code> is <code>xs.concat(ys)</code>. Rationale: less typing, more beautiful, inspired by the ++ function in Haskell (had to use 3 pluses in order to avoid ambiguity with increment operator.)
      <li><code>^</code> is now an alias to <code>**</code>, the power operator. Rationale: it was available, and is used in other languages. 
      <li>Power precedence is now proper, and the power operator has precedence over multiplication and division. It also has higher precedence than unary ops. Eg. 2*4^2 == 32, not 64 as in Coco. Also, -2^2 == -4. Rationale: math should work properly - this is how it's done in many languages including Haskell. 
      <li>Power operator is now right associative. eg. 2^2^3 == 2^(2^3) == 256. Rationale: follwing Haskell's and many other languages lead on this one.
      <li>Added magic auto curried functions, defined using <code>--></code> and <code>~~></code>. With this you can do <code>times = (x, y) --> x * y</code>, <code>timesTwo = times 2</code>, <code>timesTwo 4 #=> 8</code>. If you call a curried function with no arguments, it calls itself as is, instead of returning itself (you can just reference it if you want it itself). Rationale: more Haskell like, useful functionality. 
      <li>Added new function definition syntax, eg. <code>add(x, y) = x + y</code> == <code>add = (x, y) --> x + y</code>. You can also use it in object literals and class definitions eg. <code>add(x, y): x + y</code> == <code>add: (x, y) --> x + y</code>. You can also suppress return on both by starting with a bang, eg. <code>!nothingness(params) = true</code> will not return anything. As well you can have lexically bound this using <code>id@(param) = something</code> which is suger for <code>id = (param) ~~> something</code> (notice the wavy arrow). You can go crazy and do something like this if you wish: <code>@!func@! = something</code> which is a function assigned to this, which takes no parameters and returns nothing, while being lexically bound to this. All functions defined using this syntax are curried. Rationale: more beautiful, less typing, more Haskell like.
      <li>Added <code>obj ::= obj2</code> as alias to <code>obj::&lt;&lt;&lt;obj2</code>. Rationale: seems to be the intuitive behavior expected, looks cleaner.
      <li>Added <code>yes / on</code> as aliases to <code>true</code> and <code>no / off</code> as aliases to <code>false</code>. Added <code>undefined</code> as an alias to <code>void</code>, and aliased <code>isnt</code> to <code>is not</code>. Rationale: ease transition from CoffeeScript, which has all these features, to LiveScript. 
      <li>Added <code>when</code> as alias to <code>case</code> (and <code>|</code>). Rationale: ease transition from CoffeeScript. 
      <li>Allowed guards in loops using case statement, eg. <code>x for x from 1 to 10 when x % 2 is 0</code>. Rationale: ease transition from CoffeeScript and have guards in comprehensions like other languages (Haskell).
      <li>Added the use of <code>else</code> for default in switch. Rationale: ease transition from CoffeeScript.
      <li>Added <code>loop</code> as alias for <code>while true</code>. Rationale: ease transition from CoffeeScript. 
      <li>Added pipe operator <code>|></code> ala F#, <code>val |> func</code> is the same as <code>func(val)</code>. Very useful in combination with curried functions. Rationale: useful, as in F#.
      <li>Added backwards pipe operator <code><|</code> ala F#: <code>f <| x</code> is the same as <code>f x</code>. This is more useful than it looks, and can help you avoid parens. For instance for a definition of toCase that returns a function that either uppercases or lowercases a word, <code>toCase \up <| \hello</code> rather than <code>toCase(\up) \hello</code>. Rationale: useful as per above, as in F#.
      <li>Added function composition operators ala F#. <code>&gt;&gt;</code> and <code>&lt;&lt;</code>. <code>(f &gt;&gt; g) x</code> is <code>g(f(x))</code> and <code>(f &lt;&lt; g) x</code> is <code>f(g(x))</code>. Rationale: very useful, especially with curried functions. As in F# (and Haskell, there it's the dot operator).
      <li>Added <code>%%</code> operator (and corresponding <code>%%=</code> operator), <code>x %% y</code> is <code>(x % y + y) % y</code>. Eg. <code>-3 % 4 == -3; -3 %% 4 == 1</code>. Rationale: this is how the <code>%</code> op behaves in other languages such as Python and Ruby.
      <li>Changed number base format from <code>7r4</code> to <code>7~4</code>. This is because using <code>r</code> causes ambiguity with number comments. For instance, <code>36rpm</code> - is that the number <code>36</code> with the number comment <code>rpm</code> or is it <code>pm</code> base <code>36</code> (922). Also now accept any number as radix, so that a better error can be thrown when that radix is not 2-36. Rationale: fixes ambiguity.
      <li>Allowed expression in range syntax, eg. <code>[x to y/2]</code> instead of just number literals. This has the side effect of removing naked ranges, eg. <code>2 to 5</code> without enclosing brackets (for loops remain unchanged). Rationale: expressions in ranges are useful, much more than naked ranges which have really limited use. Also closer to CoffeeScript, easing transition again. 
      <li>Changed CLI to bare compilation so that defined variables are attached to global scope. Improved repl to continue when lines end with <code>-></code>, <code>~></code>, or <code>=</code>
      <li>Added list comprehensions (eg. <code>[x for x in list when x is \something]</code>) and removed postfix loops (eg. <code>something x for x in list</code>). Comprehensions always return a list. Nested list comprehensions behave properly, ie. the last for is the inner most loop. Rationale: following Haskell and Python. More consistent behavior. Easier to deal with in your head. More intuitive. 
      <li>Removed JS literals, eg. <code>`js code here`</code>. Rationale: it was unnecessary, and it freed up backticks.
      <li>Add infix function application, eg. <code>3 `add` 2</code>. Rationale: as in Haskell. This allows for partial application of their second argument, like operators eg. <code>(`times` 2)</code>.
      <li>Changed unary clone operator from <code>^</code> to <code>^^</code>. Rationale: disambiguate with partial application of power operator.
      <li>Added partial application of operators. Eg. <code>(+ 2)</code> returns a function which adds 2 to its argument. Also allowed is simply <code>(*)</code> which is a function which multiplies its two arguments. <code>(+x)</code> and <code>(-x)</code> still mean the application of those unary operators - the operator must be spaced to be the partial application of that operator. Using the length star <code>*</code> is no longer allowed within parens (sometimes used when setting dynamic keys), due to ambiguity with the partially applied multiplication operator. Rationale: awesome. As in Haskell.
      <li>Added unary operators as functions. Eg. you can use <code>(not)</code> as a function, compose it, etc. Rationale: very useful, as in Haskell.
      <li>Added <code>.</code> as alias to <code>&lt;&lt;</code> in composing functions. This disallows property access in the style of <code>x . y</code>. Rationale: as in Haskell. Dually spaced property access should never be used anyway. 
      <li>Added object comprehensions. Eg. <code>{[key, val * 2] for key, val of obj}</code> would return an object with all the values double of the original. The first part of the array literal gets translated into the key, the second part into the value. Rationale: very useful when dealing with objects. Can now map and filter objects back into objects.
      <li>Dashes are now supported in identifiers, they get converted into camel case. Eg. <code>get-room</code> is equivalent to <code>getRoom</code>, <code>encode-URI</code> is <code>encodeURI</code>. Rationale: enable different styles which other people may enjoy. As in the lisp family of languages. 
      <li>Added implicit call/lookup eg. <code>(.length)</code> is equivalent to <code>-> it.length</code> and <code>(.join \*)</code> is equivalent to <code>-> it.join \*</code>. <code>(obj.)</code> is <code>-> obj[it]</code>. Rationale: useful when mapping, filtering, etc. 
      <li>Added infix <code>with</code> operator ("cloneport"). Eg. <code>personA = personB with name: \alice</code> is equivalent to <code>personA = ^^personB &lt;&lt;&lt; name: \alice</code>. Ie. it clones the head and imports the tail into that new object. <code>personB</code> is unmodified. Rationale: really nice may to create new objects out of old ones.
      <li>Add partial application, <code>_</code> is the placeholder. Eg. <code>f = add-three-numbers 1, _, 3</code> then <code>f 2 #=> 6</code>. Can be multiple times, and like curried functions if called with no args will invoke, allowing use of default args. Rationale: really useful, for when function args aren't in a nice order so you can use a curried version.
      <li>Changed backcall <code>&lt;-</code> placeholder to underscore <code>_</code>. Rationale: fit in with partial application placeholder.
      <li>Changed <code>arguments</code> alias to <code>&</code>, removed <code>@@</code> as that alias. Eg. <code>-> &amp;0 + &amp;1</code>. Rationale: shorter - less typing.
      <li>Added <code>-d, --prelude</code> option for automatically adding prelude.ls. Rationale: make it easier to use prelude.ls.
      <li>Added <code>-k, --const</code> option for compiling as if all variables as constants. Rationale: some people coming from languages with all immutable values may find this nice.
      <li>Allowed arbitrary expressions in slicing syntax, eg. <code>list[1 to x]</code>. Rationale: useful.
      <li>Changed so that constructors are inherited. Rationale: useful, and more like in CoffeeScript.
      <li>Allowed empty class definitions, ie. with no block. Rationale: useful and more like CoffeeScript.
      <li>Bound methods are bound to the instance, not the class. Rationale: seems pretty useless to be bound to the class, so this is more useful. Also more like CoffeeScript.
      <li>See the <a href="#changelog">changelog</a> for more things from version 1.0.0 and beyond
      </ul>
    </div>
    <div id="changelog" class="section">
      <a name="changelog"></a>
      <h2>Changelog</h2>
      <p>For more details see <a href="#changes">Changes from Coco</a>
      <h3>1.0.0</h3>
      <ul>
        <li>Nicer compilation for the compose op
        <li>The <code>--prelude</code>/<code>-d</code> flags work for the repl
        <li>New func syntax eg. <code>f(x) = x</code> now uses <code>~</code> for bound funcs, liked named funcs, eg. <code>~f(x) = x</code>
        <li>Removed no return option for new func syntax
        <li>Added function keyword arguments ala python, eg. <code>f = ({x = 2, y = 3}) -> x + y</code>, and then application with <code>f y: 4</code>
        <li>Removed overloading of <code>+</code> for list concatination (just use <code>+++</code>)
        <li>Readded bitwise compound assign, eg. <code>.&.=</code>
        <li>Added <code>where</code>, like <code>let</code> but comes after instead of before
        <li>Changed fuzzy equals (<code>==</code> in JS) to <code>~=</code>, <code>!~=</code> for the negation
        <li>Added <code>xor</code> operator, exclusive or - true if only one side or the other is true
        <li>Doing equals on a regex literal will compile to an exec, eg. <code>x == /[ae]/g</code> is <code>/[ae]/g.exec(x)</code> - you can use <code>that</code> to get the results if used in an if statement. The negation simply uses test.
        <li>Binary logic is callable, eg. <code>(f or g) x</code> is <code>f(x) || g(x)</code>
        <li>Allow splicing like in CoffeeScript, eg. <code>list[1 to x] = [1 2 3]</code>
        <li>Static functions are now inherited and support calls to <code>super</code>
        <li>Generated reference variables are now named with a <code>$</code> after them instead of <code>__</code> preceding. eg. <code>ref$</code> instead of <code>__ref</code>
        <li>Added deep compare, allows the comparison of objects, arrays, and more. <code>===</code> - experimental
        <li>Added <code>match</code> statement - experimental
      </ul>
      <h3>0.9.12</h3>
      <ul>
        <li>Changed bitwise/shift operator syntax to be more clear. Now simply as in JS, but surrounded by dots. Eg. <code>&</code> is <code>.&.</code>, and <code>&gt;&gt;</code> is <code>.&gt;&gt;.</code>
        <li>Speed improvements
        <li>Allowed arbitrary expressions in slicing syntax, eg. <code>list[1 to x]</code>
        <li>Made classes work more like in CoffeeScript - details:
        <li>Constructors are now inherited
        <li>Allowed empty class definitions, eg. <code>class A extends B</code>
        <li>Bound methods (eg. <code>f: ~></code>) are bound to the instance, not to the class
      </ul>
      <h3>0.9.11</h3>
      <ul>
        <li>Bug fixes
        <li>Updated to work with node 0.8.x
        <li>Added partial application of funcs using <code>_</code> placeholder
        <li>Added infix <code>with</code> "cloneport", clones head and imports tail into that
        <li>Allow partial application of pipe <code>|&gt;</code> and backpipe <code>&lt;|</code> and use as function
        <li>Better compilation of various operators-as-functions
        <li>Added existential soak implicit call/lookup, eg. <code>(?length)</code>
        <li>Allow partially applied assign - <code>=</code>, <code>+=</code>, etc.
        <li>Removed <code>|&gt;&gt;</code> pipe operator - use normal pipes and partial application now
        <li>Changed backcall placeholder to underscore <code>_</code>
        <li>Added underscore <code>_</code> as alias to <code>otherwise</code> in switch statements
        <li>Added <code>--prelude</code> or <code>-d</code> option to automatically include <a href="http://gkz.github.com/prelude-ls/">prelude.ls</a> in compiled files
        <li>Added <code>--const</code> or <code>-k</code> option to compile as if all variables are constants
        <li>Added partial application of property accessor eg. <code>(obj.)</code>
        <li>Removed cons <code>&</code> operator
        <li>Added <code>&</code> as alias to <code>arguments</code>, allowing <code>-> &0 + &1</code> etc. 
        <li>Removed <code>@@</code> as alias to <code>arguments</code>
        <li>Increased precedence of the pipe <code>|&gt;</code> operator to allow assignment of the entire thing without parens, not just of the first section
        <li>Added mixin feature <code>implements</code> thanks to Coco, eg. <code>class Cow extends Animal implements Mooer</code>, which does <code>::<<< Mooer</code> in the class body.
      </ul>
      <h3>0.9.10</h3>
      <ul>
        <li>Now have `const` and `var` thanks to Coco
        <li>Implicit access and call functions, eg. <code>(.length)</code> and <code>(.join \|)</code> - useful for mapping/filtering, etc.
        <li>Bug fixes
        <li>Improved repl
      </ul>
      <h3>0.9.9</h3>
      <ul>
        <li>Various bug fixes
        <li>Calling a curried funciton with no args calls it as is rather than returning itself
        <li>Allow partial application of second arg for infix functions
      </ul>
      <h3>0.9.8</h3>
      <ul>
        <li>Object comprehensions added
        <li>Dashes in identifiers allowed (transformed to camel case)
      </ul>
      <h3>0.9.7</h3>
      <ul>
        <li>Bug fixes
        <li>Precedence change of <code>&</code> and <code>+++</code>
        <li>Nicer pipe <code>|></code> compilation
      </ul>
      <h3>0.9.6</h3>
      <ul>
        <li>Partially applied operators
        <li>Operators as functions
      </ul>
      <h3>0.9.5</h3>
      <ul>
        <li>Infix function calls added
        <li>JS literals removed
        <li>Improved CLI
      </ul>
      <h3>0.9.4</h3>
      <ul>
        <li>Added proper list comprehensions
        <li>Removed post-fix loops
      </ul>
      <h3>0.9.3</h3>
      <ul>
        <li>Changed node requirements
      </ul>
      <h3>0.9.2</h3>
      <ul>
        <li>Improved CLI
        <li>Enabled expressions in range syntax
      </ul>
      <h3>0.9.1</h3>
      <ul>
        <li>Changed number radix symbol to <code>~</code>
        <li>Added <code>%%=</code>
      </ul>
      <h3>0.9.0</h3>
      <ul>
        <li>Initial public release, many changes. See <a href="#changes">Changes from Coco</a> for more details.
      </ul>
    </div>
    <hr>
    <div id="inspiration" class="section">
      <a name="inspiration"></a>
      <h2>Inspiration</h2>
        <ul>
          <li>Functional languages in general
          <li>Haskell
          <li>F#
        </ul>
    </div>
    <div id="name" class="section">
      <a name="name"></a>
      <h2>Name</h2>
        <p>LiveScript was one of the original names for JavaScript, so it seemed fitting. It's an inside joke for those who know JavaScript well.
    </div>
    <div id="thanks" class="section">
      <a name="thanks"></a>
      <h2>Thanks</h2>
      <p>You can find the full list of contributors <a href="https://github.com/gkz/LiveScript/graphs/contributors">here</a>. That list includes contributors to LiveScript and its predecessors. 
      <p>People who have contributed directly to LiveScript include <a href="https://github.com/gkz">George Zahariev</a>, <a href="https://github.com/satyr">Satoshi Murakami</a>, <a href="https://github.com/josher19">Joshua Weinstein</a>, <a href="https://github.com/goatslacker">Josh Perez</a>, and <a href="https://github.com/paulmillr">Paul Miller</a>.
      <p>An extra special thanks to Satoshi, as this project is a fork of his project <a href="https://github.com/satyr/coco">Coco</a> and would not be possible without it. It has been a pleasure to work off of his beautiful Coco compiler. 
    </div>
    <div id="contributing" class="section">
      <a name="contributing"></a>
      <h2>Contributing Guide</h2>
      <p>Fork <a href="https://github.com/gkz/LiveScript">LiveScript</a> and make your changes. Always write tests first (in the <code>/test</code> directory).
      <p>Run <code>bin/slake</code> to see available commands. Always make sure you can <code>bin/slake build:full</code> - ie. build the compiler itself. Useful: <code>git checkout -- lib && bin/slake build:full</code>: cleans out your <code>lib</code> and compiles twice and tests. Only send a pull requests if all tests pass. If you are hacking on the grammar, you will need to <code>git checkout -- lib && bin/slake build && bin/slake build:parser && bin/slake test</code>. Once all tests pass, rewrite any of the compiler that needs rewriting, and then <code>bin/slake build:full</code>.
      <p>Don't submit patches with a built browser file (<code>extras/livescript.js</code>) created by <code>bin/slake build:browser</code>. This file is only built before releasing a new version. 
    </div>
  </div>
</div>

<script type="text/ls">
  console?.log 'LiveScript up'
</script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>


<script src="bootstrap/js/bootstrap.js"></script>
<script src="bootstrap/js/bootstrap-scrollspy.js"></script>

<script src="google-code-prettify/prettify.js"></script>
<script src="lang-ls-0.9.12.js"></script>

<script src="underscore-min.js"></script>
<script src="prelude-browser-min-0.5.0.js"></script>
<script src="site.js"></script>

<script src="livescript-0.9.12.js"></script>
</body>
</html>
