<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LiveScript - a language which compiles to JavaScript</title>
<meta name="description" content="LiveScript is a language which compiles to JavaScript. It has a straightforward mapping to JavaScript and allows you to write expressive code devoid of repetitive boilerplate. While LiveScript adds many features to assist in functional style programming, it also has many improvements for object oriented and imperative programming.">

<link rel="canonical" href="http://livescript.net">
<link rel="icon" type="image/png" href="images/icon.png">
<link href="bootstrap/themes/cerulean.bootstrap.min.css" rel="stylesheet">
<link href="google-code-prettify/prettify.css" rel="stylesheet">
<link href="styles.css" rel="stylesheet">

<script>
  if(window.location.host && window.location.host !== "localhost") {
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-7402515-5']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  }
</script>
</head>
<body data-spy="scroll">
<div class="site container-fluid">
  <div class="row-fluid side-row">
    <div class="span2 sidebar">
      <h1><a href="#">LiveScript</a><img src="images/icon.png"></h1>
      <ul class="nav nav-list">
        <li class="active"><a href="#overview">Overview</a></li>
        <li class="divider">
        <li><a href="#installation">Installation</a></li>
        <li><a href="#usage">Usage</a></li>
        <li><a href="#community">Community</a></li>
        <li><a href="#editor-support">Text Editor/IDE Plugins</a></li>
        <li><a href="#prelude-ls">Standard Library</a></li>
        <li><a href="#source-maps">Source Maps</a></li>
        <li class="divider">
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#literals">Literals</a></li>
        <li><a href="#operators">Operators</a></li>
        <li><a href="#functions">Functions</a></li>
        <li><a href="#generators-yield">Generators and Yield</a></li>
        <li><a href="#if-unless">If and Unless</a></li>
        <li><a href="#loops">Loops and Comprehensions</a></li>
        <li><a href="#switch">Switch</a></li>
        <li><a href="#assignment">Assignment</a></li>
        <li><a href="#property-access">Property Access</a></li>
        <li><a href="#exceptions">Exceptions</a></li>
        <li><a href="#oop">OOP</a></li>
        <li class="divider">
        <li><a href="#coffee-to-ls">Converting from CoffeeScript</a></li>
        <li><a href="#changelog">Changelog</a></li>
        <li class="divider">
        <li><a href="#inspiration">Inspiration</a></li>
        <li><a href="#name">Name</a></li>
        <li><a href="#thanks">Thanks</a></li>
        <li><a href="#contributing">Contributing Guide</a></li>
        <li><a href="#changes">Changes from Coco</a></li>
      </ul>
    </div>
    <div class="span4 compiler">
      <div class="compiler-box">
        <div id="compiler-close-button">&times;</div>
        <div class="github-buttons">
          <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://livescript.net/" data-text="LiveScript - functional CoffeeScript" data-related="gkzahariev:The Creator" data-via="gkzahariev">Tweet</a>
          <iframe src="http://ghbtns.com/github-btn.html?user=gkz&repo=LiveScript&type=watch&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="120px" height="20px"></iframe>
          <i class="icon-resize-full action-compiler-fullscreen" title="Go fullscreen"></i>
          <i style="display:none" class="icon-resize-small action-compiler-fullscreen" title="Escape fullscreen"></i>
        </div>
        <textarea placeholder="Enter LiveScript here"></textarea>
        <div class="actions">
          <button class="btn btn-primary" data-action="compile" title="Convert LiveScript to JavaScript">Compile</button>
          <button class="btn" data-action="run" title="Run compiled JavaScript">Run</button>
          <button class="btn" data-action="ast" title="Abstract Syntax Tree">AST</button>
          <button class="btn" data-action="tokens" title="Tokenization of input">Tokens</button>
          <button class="btn" data-action="lex" title="Same as tokens, but skipping rewriting">Lex</button>
        </div>
      </div>
      <div class="compiler-output">

      </div>
    </div>
  </div>
  <div class="row-fluid content-row">
    <div class="span2">&nbsp;</div>
    <div class="span6 content">
      <div id="overview" class="section">
        <a name="overview"></a>
        <h2>Overview</h2>
        <p><strong>LiveScript</strong> is a language which <strong>compiles to JavaScript</strong>. It has a straightforward mapping to JavaScript and allows you to write expressive code devoid of repetitive boilerplate. While LiveScript adds many features to assist in functional style programming, it also has many improvements for object oriented and imperative programming.
        <p>LiveScript is a fork of <a href="http://satyr.github.com/coco/">Coco</a> and an indirect descendant of CoffeeScript, with which it has much <a href="#coffee-to-ls">compatibility</a>.
        <div class="major-actions">
          <h3 class="download">1.6.0:</h3>
          <a href="https://github.com/gkz/LiveScript/zipball/1.6.0"><div class="btn btn-large btn">zip</div></a>
          <a href="https://github.com/gkz/LiveScript/tarball/1.6.0"><div class="btn btn-large btn">tar.gz</div></a>
          <a href="https://github.com/gkz/LiveScript"><div class="btn btn-large btn-primary">View project on GitHub</div></a>
          <iframe src="http://ghbtns.com/github-btn.html?user=gkz&repo=LiveScript&type=watch&size=large&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="150" height="40"></iframe>
          <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://livescript.net/" data-text="LiveScript - functional CoffeeScript" data-size="large" data-related="gkzahariev:The Creator" data-via="gkzahariev">Tweet</a>
        </div>
        <p><strong><code>npm install -g livescript</code></strong>
<p><a href="https://twitter.com/gkzahariev" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @gkzahariev</a> for updates on LiveScript.
        <p>Featured blog post: <strong><a href="blog/livescript-1.4.0-source-maps-more.html">LiveScript 1.4.0 - Source Maps and more!</a></strong>
        <p>Double-click an example to load it into the compiler/REPL. Docs in French: <a href="index-fr.html">Fran√ßais</a>.
      <h3>Some Examples</h3>
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
# Easy listing of implicit objects
table1 =
  * id: 1
    name: 'george'
  * id: 2
    name: 'mike'
  * id: 3
    name: 'donald'





table2 =
  * id: 2
    age: 21
  * id: 1
    age: 20
  * id: 3
    age: 26




# Implicit access, accessignment
up-case-name = (.name .= to-upper-case!)

# List comprehensions, destructuring, piping
[{id:id1, name, age} for {id:id1, name} in table1
                     for {id:id2, age} in table2
                     when id1 is id2]
|> sort-by (.id) # using 'sort-by' from prelude.ls
|> each up-case-name # using 'each' from prelude.ls
|> JSON.stringify
#=>
#[{"id":1,"name":"GEORGE","age":20},
# {"id":2,"name":"MIKE",  "age":21},
# {"id":3,"name":"DONALD","age":26}]











# operators as functions, piping
map (.age), table2 |> fold1 (+)
#=> 67 ('fold1' and 'map' from prelude.ls)
</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var table1, table2, upCaseName, id1, name, id2, age;
table1 = [
  {
    id: 1,
    name: 'george'
  }, {
    id: 2,
    name: 'mike'
  }, {
    id: 3,
    name: 'donald'
  }
];
table2 = [
  {
    id: 2,
    age: 21
  }, {
    id: 1,
    age: 20
  }, {
    id: 3,
    age: 26
  }
];
upCaseName = function(it){
  return it.name = it.name.toUpperCase();
};
JSON.stringify(
each(upCaseName)(
sortBy(function(it){
  return it.id;
})(
(function(){
  var i$, ref$, len$, ref1$, j$, len1$, ref2$, results$ = [];
  for (i$ = 0, len$ = (ref$ = table1).length; i$ < len$; ++i$) {
    ref1$ = ref$[i$], id1 = ref1$.id, name = ref1$.name;
    for (j$ = 0, len1$ = (ref1$ = table2).length; j$ < len1$; ++j$) {
      ref2$ = ref1$[j$], id2 = ref2$.id, age = ref2$.age;
      if (id1 === id2) {
        results$.push({
          id: id1,
          name: name,
          age: age
        });
      }
    }
  }
  return results$;
}()))));
fold1(curry$(function(x$, y$){
  return x$ + y$;
}))(
map(function(it){
  return it.age;
}, table2));
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
</pre>
        </div>
      </div>
      <p>Unnested callbacks and parentheses free chaining:
      <div class="example">
        <div class="example-ls">
        <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
<- $ 'h1' .on 'click'
alert 'boom!'
</pre>
        </div>
        <div class="example-js">
        <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
$('h1').on('click', function(){
  return alert('boom!');
});
</pre>
        </div>
      </div>
    </div>
    <hr>
    <div id="installation" class="section">
      <a name="installation"></a>
      <h2>Installation</h2>
      <p>You can install LiveScript through <a href="http://npmjs.org">npm</a>: <strong><code>sudo npm install -g livescript</code></strong>.
      <p>Alternately, you can also download it (<a href="https://github.com/gkz/LiveScript/zipball/1.6.0">zip</a>, <a href="https://github.com/gkz/LiveScript/tarball/1.6.0">tar.gz</a>), enter its directory, and run <code>sudo make install</code>. Using git to download: <code>git clone git://github.com/gkz/LiveScript.git &amp;&amp; cd LiveScript &amp;&amp; sudo make install</code>. <a href="http://nodejs.org">Node.js</a> is required to be installed on your system.</p>
      <p>You can also use it directly in the browser by including the file in <code>LiveScript/browser/livescript.js</code> via a script tag. You must then call <code>require("livescript").go()</code>. If you use this, your LiveScript scripts have to be placed after the included <code>livescript.js</code> file, and the script tags must have the attribute <code>type="text/ls"</code>.
      <p>For example:
<pre class="prettyprint lang-html">
&lt;script src="livescript.js"&gt;&lt;/script&gt;
&lt;script type="text/ls"&gt;
    console.log "boom #{window.location}"
&lt;/script&gt;
&lt;script&gt;
    var LiveScript = require("livescript");
    LiveScript.go();
&lt;/script&gt;
</pre>
    </div>
    <div id="usage" class="section">
      <a name="usage"></a>
      <h2>Usage</h2>

      <h3>Command Line:</h3>

      <p>Usage: <code>lsc [options]... [file]...</code></p>
      <p>Use <code>lsc</code> with no options to start REPL.

      <h4>General:</h4>
<pre>
Usage: lsc [option]... [file]...

Use 'lsc' with no options to start REPL.

Misc:
  -v, --version              display version
  -h, --help                 display this help message
  -c, --compile              compile to JavaScript and save as .js files
  -e, --eval code::String    pass as string from the command line as input
  -d, --prelude              automatically import prelude.ls in REPL
  -r, --require paths::[String]  require libraries before executing
  -s, --stdin                read stdin
  -j, --json                 print/compile as JSON
  -n, --nodejs               pass options after this through to the 'node' binary
  -w, --watch                watch scripts for changes, and repeat
  -k, --const                compile all variables as constants

Output control:
  -o, --output path::String  compile into the specified directory
  -p, --print                print the result to stdout
  -b, --bare                 compile without the top-level function wrapper
  --no-header                do not add "Generated by" header
  -l, --lex                  print the tokens the lexer produces
  -t, --tokens               print the tokens the rewriter produces
  -a, --ast                  print the syntax tree the parser produces
  --debug                    print debug output when compiling
  -m, --map String           generate source maps - either: 'none', 'linked',
                             'linked-src', 'embedded', or 'debug'
  --no-warn                  suppress compiler warnings

Version 1.6.0
&lt;http://livescript.net/&gt;
</pre>

      <h3>Command Line Examples</h3>

      <ul>
        <li>Run a LiveScript file (through node.js): <code>lsc file.ls</code> - you can omit the <code>.ls</code> if you wish.
        <li>Compile a LiveScript file, creating a <code>file.js</code>: <code>lsc -c file.ls</code>
        <li>Watch a file and compile on changes: <code>lsc -wc file.ls</code>
        <li>Compile a directory and output to another directory: <code>lsc -co output src</code>
        <li>Watch a directory, compile on change into an output directory: <code>lsc -wco output src</code>
        <li>Compile a one-liner and print the JS: <code>lsc -bpe '[1 to 5]'</code>
        <li>Start the LiveScript REPL: <code>lsc</code> - <code>Ctrl-D</code> to exit, use <code>Ctrl-J</code> for multiline input.
      </ul>

      <h3 id="json">JSON</h3>
      <a name="json"></a>
      <p>You can compile LiveScript style JSON to <code>.json</code> files by using the <code>.json.ls</code> file extension, or by passing in the <code>-j,--json</code> flag.

      <p>You can combine <code>-e,--eval</code> with JSON data for functional style command line JSON processing. The JSON data you supply is bound to <code>this</code> in the eval expression. You can either pipe in JSON, and use the <code>-j,--json</code> flag, or use a file with the <code>.json</code>extension.

<pre>
$ lsc -e '@name' package.json
"livescript"
$ cat package.json | lsc -je '@name'
"livescript"
</pre>

      <p>You can include <a href="http://www.preludels.com">prelude.ls</a> with the <code>-d,--prelude</code> flag.

<pre>
$ lsc -de '@files |&gt; map (.to-upper-case!)' package.json
[
  "LIB",
  "BIN",
  "README.MD",
  "LICENSE"
]
</pre>

      <p>You can easily require modules as well, with the <code>-r,--require</code> flag.

<pre>
lsc -r 'path' -de '@files |&gt; map -&gt; [it, path.resolve it]' package.json
[
  [
    "lib",
    "/home/z/open-source/LiveScript/lib"
  ],
  [
    "bin",
    "/home/z/open-source/LiveScript/bin"
  ],
  [
    "README.md",
    "/home/z/open-source/LiveScript/README.md"
  ],
  [
    "LICENSE",
    "/home/z/open-source/LiveScript/LICENSE"
  ]
]
</pre>

      <h3>Programmatic API:</h3>

      <p>Require it into your Node or Browserify project with <code class="prettyprint lang-js">var LiveScript = require('livescript');</code> or <code class="prettyprint lang-ls">require! livescript</code>, or use the installation steps above for in-browser installation. In Node, requiring this also registers it in <code>require.extensions</code>.</p>

      <h4>General:</h4>
      <p><code>LiveScript.compile(code :: String, options :: Object?) -> String</code></p>
      <p>Compile a string of LiveScript code into plain JavaScript. If the string fails to compile, a SyntaxError is thrown.</p>
      <p>Options:</p>
      <table class="usage-options table table-striped table-bordered">
        <tr><td>bare :: Boolean = false</td><td>if true, compile without the top-level function wrapper</td></tr>
        <tr><td>header :: Boolean = true</td><td>if true, add the "Generated by" header</td></tr>
        <tr><td>const :: Boolean = false</td><td>if true, compile all variables as constants</td></tr>
        <tr><td>json :: Boolean = false</td><td>if true, compile to JSON instead of JavaScript</td></tr>
        <tr><td>warn :: Boolean = true</td><td>if false, suppress compiler warnings</td></tr>
        <tr><td>filename :: String?</td><td>an optional filename to use for compilation errors</td></tr>
      </table>

      <br> <!-- for proper spacing -->

      <p><code>LiveScript.run(code :: String, options :: Object?) -> String</code></p>
      <p>Evaluate a string of LiveScript code. If the string fails to compile, a SyntaxError is thrown. Note that this uses the Function constructor.</p>
      <p>Options:</p>
      <table class="usage-options table table-striped table-bordered">
        <tr><td>const :: Boolean = false</td><td>if true, compile all variables as constants</td></tr>
        <tr><td>filename :: String?</td><td>an optional filename to use for errors</td></tr>
      </table>

      <h4>Utilities:</h4>
      <p><code>LiveScript.ast(code :: String|Array) -> Object</code></p>
      <p>Generate the AST representation of the LiveScript source, if it is a string, or the token stream if it is an array. If it is a string that cannot be parsed as LiveScript code, a SyntaxError is thrown. If it is an Array, an Error is thrown if the stream is not valid.</p>

      <br> <!-- for proper spacing -->

      <p><code>LiveScript.tokens(code :: String, options :: Object?) -> Array</code></p>
      <p>Generate a token stream from LiveScript code. Note that this does keep state between calls.</p>
      <p>Options</p>
      <table class="usage-options table table-striped table-bordered">
        <tr><td>raw :: Boolean = false</td><td>if true, do not flush the token stream before tokenizing - recommended to leave as default</td></tr>
        <tr><td>line :: Number = 0</td><td>the starting line number for the token stream</td></tr>
      </table>

      <br> <!-- for proper spacing -->

      <p><code>LiveScript.lex(code :: String)</code></p>
      <p>Equivalent to <code>LiveScript.tokens(code, {raw: true})</code>.</p>

      <br> <!-- for proper spacing -->

      <p><code>LiveScript.ast.* :: Object...</code></p>
      <p>All the AST constructors used for <code>LiveScript.ast()</code>.</p>

      <h4>Browser-specific methods:</h4>
      <p><code>LiveScript.stab(code :: String, callback :: (err :: Error?) -> void, filename :: String?) -> void</code></p>
      <p>Run a string of code, and call back with an optional error.</p>

      <br> <!-- for proper spacing -->

      <p><code>LiveScript.load(url :: String, callback :: (err :: Error?) -> void) -> void</code></p>
      <p>Load a remote LiveScript file via an <code>XMLHttpRequest</code> at <code>url</code> and call back with an optional error.</p>

      <br> <!-- for proper spacing -->

      <p><code>LiveScript.go() -> void</code></p>
      <p>Load all scripts with a <code>type</code> attribute of either <code>"text/ls"</code> or <code>"application/ls"</code>.</p>
    </div>
    <div id="community" class="section">
      <a name="community"></a>
      <h2>Community</h2>
      <ul>
        <li><a href="https://github.com/gkz/LiveScript/issues">LiveScript GitHub issues section</a>
        <li><a href="https://groups.google.com/forum/#!forum/livescript">Google Groups</a>
        <li><a href="http://www.reddit.com/r/livescript/">r/livescript</a>
        <li>Find us at <a href="https://webchat.freenode.net/?channels=#livescript">#livescript</a> on freenode.
        <li>Follow the <a href="https://github.com/gkz/LiveScript-style-guide">LiveScript style guide</a>
      </ul>
      <a name="blog"></a>
      <h3>Blog</h3>
      <ul>
        <li><a href="blog/livescript-1.4.0-source-maps-more.html">LiveScript 1.4.0 - Source Maps and more!</a>
        <li><a href="blog/livescript-1.3.0.html">LiveScript 1.3.0 Released!</a>
        <li><a href="blog/livescript-1.2.0.html">LiveScript 1.2.0 Released!</a>
        <li><a href="blog/10-things-you-didnt-know-livescript-can-do.html">10 things you didn't know LiveScript can do</a>
        <li><a href="blog/fizzbuzzbazz.html">The shortest FizzBuzzBazz - can you do better?</a>
        <li><a href="blog/livescript-1.1.0.html">LiveScript 1.1.0 Released!</a>
        <li><a href="blog/powerful-jquery-with-livescript.html">Powerful jQuery with LiveScript</a>
        <li><a href="blog/livescript-1.0.0.html">LiveScript 1.0.0 Released</a>
        <li><a href="blog/functional-programming-in-javascript-using-livescript-part-2.html">Functional Programming in JavaScript using LiveScript - Part 2</a>
        <li><a href="blog/ten-reasons-to-switch-from-coffeescript.html">10 Reasons to Switch from CoffeeScript to LiveScript</a>
        <li><a href="blog/functional-programming-in-javascript-using-livescript-and-prelude-ls.html">Functional Programming in JavaScript using LiveScript and prelude.ls</a>
        <li><a href="blog/livescript-one-liners-to-impress-your-friends.html">10 LiveScript One Liners to Impress Your Friends</a>
      </ul>
      <h3>In the Wild</h3>
      <ul>
        <li><a href="https://github.com/gkz/LiveScript/wiki/Companies-using-LiveScript">Companies using LiveScript</a>
        <li><a href="https://github.com/gkz/LiveScript/wiki/Projects-using-LiveScript">Projects using LiveScript</a>
        <li><a href="https://github.com/gkz/LiveScript/wiki/Projects-supporting-LiveScript">Projects supporting LiveScript</a>
      </ul>
      <p>Add your own project/company to the lists!
    </div>
    <div id="editor-support" class="section">
      <a name="editor-support"></a>
      <h2>Text Editor/IDE Plugins</h2>
      <ul>
        <li>Vim users, check out <a href="https://github.com/gkz/vim-ls">vim-ls</a>.</li>
        <li>TextMate, Chocolat, and Sublime Text bundle for LiveScript: <a href="https://github.com/paulmillr/LiveScript.tmbundle">LiveScript.tmbundle</a>.</li>
        <li>Emacs basic LiveScript support: <a href="https://github.com/tensai-cirno/livescript-mode">livescript-mode</a>.</li>
        <li>And more on the <a href="https://github.com/gkz/LiveScript/wiki/Projects-supporting-LiveScript">wiki page</a>. Add yours to the growing list!</li>
      </ul>
    </div>
    <div id="prelude-ls" class="section">
      <a name="prelude-ls">
      <h2>Standard Library</h2>
      <p><a href="http://preludels.com">prelude.ls</a> is the recommended base library when using LiveScript. It allows you to do things such as:

<pre class="prettyprint lang-ls">
[1 2 3] |> map (* 2) |> filter (> 3) |> fold1 (+)
#=> 10
</pre>

      <p>You can automatically import prelude.ls to the REPL by using the <code>-d</code> or <code>--prelude</code> options.

      <p>Prelude is loaded on this page and you can use it when running things in the compiler/REPL to the right.
    </div>
    <hr>
    <div id="source-maps" class="section">
      <a name="source-maps"></a>
      <h2>Source Maps</h2>
      <p>Use the <code>-m, --map</code> option when compiling to generate source maps. It has several possible values, <code>none</code> - the default, <code>linked</code>, <code>linked-src</code>, <code>embedded</code>, and <code>debug</code>
      <p>There are three files involved when generating sourcemaps:
      <ol style="list-style-type: lower-alpha">
        <li>The original LiveScript source
        <li>The sourcemap
        <li>The generated JavaScript source
      </ol>
      <p><code>a</code> can optionally be embedded inside <code>b</code>, and <code>b</code> can optionally be embedded inside <code>c</code> via a comment.
      <p><code>linked</code>: No embedding, <code>c</code> links to <code>b</code> via a relative path, and same for <code>b</code> to <code>a</code>
      <p><code>linked-src</code>: <code>b</code> is embedded inside <code>c</code>, but <code>a</code> is linked to
      <p><code>embedded</code>: Everything is embedded inside <code>c</code>
      <p><code>debug</code>: Same as linked, but will also output a human readable representation of the source-node tree (similar to the output from the <code>ast</code> option) to a '.map.debug' file.
      <p>Use <code>linked</code> or <code>linked-src</code> if you are directly serving the output from lsc to the browser - (ie. not performing further processing). They keep the original source separate, so the JavaScript file is still small. <code>linked-src</code> just means you have one fewer file to carry around at the expense of increasing the size of the JavaScript file.
      <p>Use <code>embedded</code> for everything else - it's self-contained and it's the only form most other tools such as browserify will accept as input. The file will be significantly larger, but you can remedy this by running a separate tool at the end of your build pipeline to split the output back into the <code>linked</code> form.
    </div>
    <div id="introduction" class="section">
      <a name="introduction"></a>
      <h2>Introduction</h2>
      <p>Like many modern languages, blocks are delimited by whitespace indentation and newlines are used instead of semicolons to terminate statements (you can still use semicolons if you want to fit more than one statement on a line).

      <p>For example (LiveScript on the left, compiled JavaScript on the right):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
if 2 + 2 == 4
  do-something()
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
if (2 + 2 === 4) {
  doSomething();
}
</pre>
        </div>
      </div>

      <p class="note">You can try all these examples for yourself using the LiveScript compiler/REPL to the right.

      <p>To further clear things up, you can omit the parentheses when calling a function.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add 2, 3
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
add(2, 3);
</pre>
        </div>
      </div>

      <p>And comments are:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
# from here to the end of the line.
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
// from here to the end of the line.
</pre>
        </div>
      </div>

      <p class="note">Lisp hackers, you may be pleased to know that you can use dashes in the name of your variables and functions. The names are equivalent to, and are compiled to, camel case. Eg. <code>my-value = 42</code> == <code>myValue = 42</code>.

      <p>The file extension for LiveScript is <code>.ls</code>.


      <h3>Defining Functions</h3>

      <p>Defining functions is very lightweight in LiveScript:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

(x, y) -> x + y



-> # an empty function

times = (x, y) ->
  x * y
# multiple lines, and be assigned to
# a var like in JavaScript
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var times;
(function(x, y){
  return x + y;
});

(function(){});

times = function(x, y){
  return x * y;
};


</pre>
        </div>
      </div>

      <p>As you see, function definitions are considerably shorter! You may also have noticed that we have omitted <code>return</code>. In LiveScript, almost everything is an expression and the last one reached is automatically returned. However, you can still use <code>return</code> to force returns if you want, and you can add a bang <code>!</code> before the arrow to suppress auto-returning <code>no-ret = (x) !-> ...</code>.

      <h3>Assignment</h3>
      <p>Basic assignment is as you would expect, <code>variable = value</code>, and there is no need for variable declarations. However, unlike CoffeeScript, you must use <code>:=</code> to modify variables in upper scopes.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

x = 10


do ->
  x = 5

x #=> 10

do ->
  x := 2

x #=> 2
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 10;

(function(){
  var x;
  return x = 5;
})();
x;

(function(){
  return x = 2;
})();
x;
</pre>
        </div>
      </div>

      <p>Almost everything is an expression, which means you can do things like:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = if 2 + 2 == 4
    then 10
    else 0
x #=> 10
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 2 + 2 === 4 ? 10 : 0;

x;
</pre>
        </div>
      </div>

      <p>Things such as loops, switch statements, and even try/catch statements are all expressions.

      <p>If you want to simply declare a variable and not initialize it, you can use <code>var</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
var x
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
</pre>
        </div>
      </div>

      <p>You can also declare constants in LiveScript using <code>const</code>. They are checked at compile time - the compiled JS is no different.

      <p>Attempting to compile the following:

<pre class="prettyprint lang-ls">
const x = 10
x = 0
</pre>

      <p>Results in <code>redeclaration of constant "x" on line 2</code>.

      <p>However, objects are not frozen if declared as constants - you can still modify their properties. You can force all variables to be constants if you compile with the <code>-k</code> or <code>--const</code> flags.


      <h3>Info</h3>

      <p>For differences from CoffeeScript, see the <a href="#coffee-to-ls">CoffeeScript to LiveScript Conversion Guide</a>.
      <p>You can double click any of the examples to load the LiveScript code into the compiler to the right, or you can play around and try out your own code. Press run to execute the compiled JavaScript. Note that LiveScript wraps compiled JS in a safety wrapper <code>(function(){...contents...}).call(this);</code> - this wrapper has been omitted in all examples and this page's compiler output for conciseness.
    </div>
    <div id="literals" class="section">
      <a name="literal"></a>
      <h2>Literals</h2>

      <h3 id="literals-numbers">Numbers</h3>

      <p><code>.4</code> is not valid, it must be preceded with a zero, eg. <code>0.4</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
42
17.34
0.4
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
42;
17.34;
0.4;
</pre>
        </div>
      </div>

      <p>Underscores and appended letters are ignored.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
64_000km
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
64000;
</pre>
        </div>
      </div>

      <p>Any base can be used from 2 to 36 using <code>~</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
6~12
2~1000
16~ff
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
8;
8;
255;
</pre>
        </div>
      </div>

      <h3 id="literals-booleans">Booleans, Void, Null</h3>

      <p>Aliases as in CoffeeScript.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
true
false
on
off
yes
no
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
true;
false;
true;
false;
true;
false;
</pre>
        </div>
      </div>

      <p>In JavaScript, <code>undefined</code> can be redefined, so it is prudent to use the <code>void</code> operator which produces the undefined value, always.

      <p><code>void</code> at the top level (not used as an expression) compiles to nothing (for use as a placeholder) - it must be used as a value to compile.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

void
x = void

null
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x;
// void compiles to nothing here!
x = void 8;

null;
</pre>
        </div>
      </div>

      <h3 id="literals-strings">Strings</h3>

      <p>You can use double or single quotes.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
'a string'
"a string"
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
'a string';
"a string";
</pre>
        </div>
      </div>


      <p>Strings can be written with a preceding backslash instead of quotes. Backslash strings can't contain <code>, ; ] ) }</code> or whitespace.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
\word
func \word, \word;
(func \word)
[\word]
{prop:\word}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
'word';
func('word', 'word');
func('word');
['word'];
({
  prop: 'word'
});
</pre>
        </div>
      </div>

      <p>Double quoted strings allow interpolation. Single quoted strings are passed through as-is. Simple variables can be interpolated without curly braces.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

"The answer is #{2 + 2}"
'As #{is}'

variable = "world"
"Hello #variable"
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var variable;
"The answer is " + (2 + 2);
'As #{is}';

variable = "world";
"Hello " + variable;
</pre>
        </div>
      </div>

      <p>Prefixing your interpolated string with <code>%</code> returns and the raw parts as an array. This allows you to join the result as you wish.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
%"#x #y"
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
[x, " ", y];
</pre>
        </div>
      </div>

      <p>Multiline strings (can also do the same but with double quotes for use with interpolation):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
multiline = 'string can be multiline \
            and go on and on \
            beginning whitespace is \
            ignored'
heredoc = '''
            string can be multiline
            with newlines
            and go on and on
            beginning whitespace is
            ignored
'''
nospaces = 'deadbeef
            deadbeef'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var multiline, heredoc, nospaces;
multiline = 'string can be multiline and go on and on beginning whitespace is ignored';

heredoc = 'string can be multiline\nwith newlines\nand go on and on\nbeginning whitespace is\nignored';





nospaces = 'deadbeefdeadbeef';

</pre>
        </div>
      </div>

      <h3 id="literals-comments">Comments</h3>

      <p>Single line comments start off with a <code>#</code>. They are not passed through to the compiled output.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
# single line comment
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">


</pre>
        </div>
      </div>

      <p>Multiline comments are preserved in the output.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
/* multiline comments
   use this format and are preserved
   in the output unlike single line ones
*/
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
/* multiline comments
   use this format and are preserved
   in the output unlike single line ones
*/
</pre>
        </div>
      </div>

      <h3 id="literals-objects">Objects</h3>

      <p>Braces are optional:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

obj = {prop: 1, thing: 'moo'}



person =
  age:      23
  eye-color: 'green'
  height:   180cm

oneline = color: 'blue', heat: 4
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj, person, oneline;
obj = {
  prop: 1,
  thing: 'moo'
};
person = {
  age: 23,
  eyeColor: 'green',
  height: 180
};
oneline = {
  color: 'blue',
  heat: 4
};
</pre>
        </div>
      </div>

      <p>Dynamic keys:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj =
  "#variable": 234
  (person.eye-color): false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj, ref$;
obj = (ref$ = {}, ref$[variable + ""] = 234, ref$[person.eyeColor] = false, ref$);
</pre>
        </div>
      </div>

      <p>Property setting shorthand - easily set properties with variables if you want the property name to be the same as the variable name.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = 1
y = 2
obj = {x, y}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x, y, obj;
x = 1;
y = 2;
obj = {
  x: x,
  y: y
};
</pre>
        </div>
      </div>

      <p>Flagging shorthand - easily set boolean properties.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
{+debug, -live}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
({
  debug: true,
  live: false
});
</pre>
        </div>
      </div>

      <p>This - no need to use a dot <code>.</code> to access properties.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
this
@
@location
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
this;
this;
this.location;
</pre>
        </div>
      </div>

      <h3 id="literals-regexp">Regular Expressions</h3>

      <p>Regular regex delineated with a single <code>/</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
/moo/gi
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
/moo/gi;
</pre>
        </div>
      </div>

      <p>Delineated with <code>//</code> - multiline, comments, spacing!

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
//
| [!=]==?             # equality
| @@                  # constructor
| <\[(?:[\s\S]*?\]>)? # words
//g
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
/|[!=]==?|@@|<\[(?:[\s\S]*?\]>)?/g;





</pre>
        </div>
      </div>

      <h3 id="literals-lists">Lists</h3>

      <p>Regular list literal delineated with brackets:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[1, person.age, 'French Fries']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
[1, person.age, 'French Fries'];
</pre>
        </div>
      </div>

      <p>Commas are not needed if the item preceding is not callable:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[1 2 3 true void \word 'hello there']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
[1, 2, 3, true, void 8, 'word', 'hello there'];
</pre>
        </div>
      </div>

      <p>Implicit lists created with an indented block. They need at least two items for it to work. If you have only one item, you can add a yaddayaddayadda <code>...</code> to force the implicit list.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
my-list =
  32 + 1
  person.height
  'beautiful'

one-item =
  1
  ...
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var myList, oneItem;
myList = [32 + 1, person.height, 'beautiful'];



oneItem = [1];



</pre>
        </div>
      </div>

      <p>When implicitly listing, you can use an asterisk <code>*</code> to disambiguate implicit structures such as implicit objects and implicit lists. The asterisk does not denote an item of the list, but merely sets aside an implicit structure so that it is not muddled with the other ones being listed.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
tree =
  * 1
    * 2
      3
    4
  * 5
    6
    * 7
      8
      * 9
        10
    11

obj-list =
  * name: 'tessa'
    age:  23
  * name: 'kendall'
    age:  19


obj =
  * name: 'tessa'
    age:  23

obj-one-list =
  * name: 'tessa'
    age:  23
  ...
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var tree, objList, obj, objOneList;
tree = [[1, [2, 3], 4], [5, 6, [7, 8, [9, 10]], 11]];









objList = [
  {
    name: 'tessa',
    age: 23
  }, {
    name: 'kendall',
    age: 19
  }
];
obj = {
  name: 'tessa',
  age: 23
};
objOneList = [{
  name: 'tessa',
  age: 23
}];
</pre>
        </div>
      </div>

      <p>Lists of words:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
<[ list of words ]>
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
['list', 'of', 'words'];
</pre>
        </div>
      </div>

      <h3 id="literals-ranges">Ranges</h3>

      <p><code>to</code> means up to and <em>including</em> the number. <code>til</code> means up <em>until</em> but not including the number.

      <p>You can optionally add a <code>by</code> which defines the step of the range.

      <p>If you omit the first number, it is assumed to be <code>0</code>.

      <p>With number/string literals:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[1 to 5]       #=> [1, 2, 3, 4, 5]
[1 til 5]      #=> [1, 2, 3, 4]
[1 to 10 by 2] #=> [1, 3, 7, 9]
[4 to 1]       #=> [4, 3, 2, 1]
[to 5]         #=> [0, 1, 2, 3, 4, 5]
[\A to \D]     #=> ['A', 'B', 'C', D']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
[1, 2, 3, 4, 5];
[1, 2, 3, 4];
[1, 3, 5, 7, 9];
[4, 3, 2, 1];
[0, 1, 2, 3, 4, 5];
["A", "B", "C", "D"];
</pre>
        </div>
      </div>

      <p>With any expression - if your range uses expressions, and you want it to go downwards (ie. from a larger number to a smaller one) you must explicitly set <code>by -1</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = 4
[1 to x]       #=> [1, 2, 3, 4]
[x to 0 by -1] #=> [4, 3, 2, 1, 0]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x, i$;
x = 4;
for (i$ = 1; i$ <= x; ++i$) {
  i$;
}
for (i$ = x; i$ >= 0; --i$) {
  i$;
}
</pre>
        </div>
      </div>

      <h3 id="literals-misc">Misc</h3>

      <p>Labels (useful for nested loops):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
:label 4 + 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
label: {
  4 + 2;
}
</pre>
        </div>
      </div>

      <p><code>constructor</code> shorthand.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
@@
@@x
x@@y
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
constructor;
constructor.x;
x.constructor.y;
</pre>
        </div>
      </div>

      <p>Yaddayaddayadda - a placeholder:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
...
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
throw Error('unimplemented');
</pre>
        </div>
      </div>
    </div>

    <div id="operators" class="section">
      <a name="operators"></a>
      <h2>Operators</h2>

      <h3 id="operators-number">Number</h3>

      <p>The standard math operators:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
1 + 2 #=> 3
3 - 4 #=> -1
6 * 2 #=> 12
8 / 4 #=> 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
1 + 2;
3 - 4;
6 * 2;
8 / 4;
</pre>
        </div>
      </div>

      <p>There is a remainder operator, as in JavaScript - but we also add a proper modulo operator.


      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

-3 % 4  #=> -3
-3 %% 4 #=> 1
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$;
-3 % 4;
((-3) % (ref$ = 4) + ref$) % ref$;
</pre>
        </div>
      </div>

      <p>The power is right associative, and has higher precedence than unary ops. <code>^</code> is an alias for <code>**</code>

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
2 ** 4     #=> 16
3 ^ 4      #=> 81
-2 ^ 2 ^ 3 #=> -256
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
Math.pow(2, 4);
Math.pow(3, 4);
-Math.pow(2, Math.pow(2, 3));
</pre>
        </div>
      </div>

      <p>Increments and decrements:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

n = 0
n++ #=> 0
++n #=> 2
n-- #=> 2
--n #=> 0
x = n++ #=> 0
x #=> 0
n #=> 1
x = ++n #=> 2
x #=> 2
n #=> 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var n, x;
n = 0;
n++;
++n;
n--;
--n;
x = n++;
x;
n;
x = ++n;
x;
n;
</pre>
        </div>
      </div>

      <p>Bitwise and shift operators:


      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
14 .&. 9   #=> 8
14 .|. 9   #=> 15
14 .^. 9   #=> 7
~9         #=> -10
9  .<<. 2  #=> 36
-9 .>>. 2  #=> -3
-9 .>>>. 2 #=> 1073741821
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
14 & 9;
14 | 9;
14 ^ 9;
~9;
9 << 2;
-9 >> 2;
-9 >>> 2;
</pre>
        </div>
      </div>

      <p>Casting to a number:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
+'4' #=>  4
-'3' #=> -3
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
+'4';
-'3';
</pre>
        </div>
      </div>

      <h3 id="operators-comparison">Comparison</h3>

      <p>Strict equality (no type coercion):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
2 + 4 == 6      #=> true
\boom is 'boom' #=> true

\boom != null   #=> true
2 + 2 is not 4  #=> false
0 + 1 isnt 1    #=> false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
2 + 4 === 6;
'boom' === 'boom';

'boom' !== null;
2 + 2 !== 4;
0 + 1 !== 1;
</pre>
        </div>
      </div>

      <p>Fuzzy equality (with type coercion):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
2 ~= '2'       #=> true
\1 !~= 1       #=> false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
2 == '2';
'1' != 1;
</pre>
        </div>
      </div>

      <p>Greater/less than:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
2 < 4           #=> true
9 > 7           #=> true
8 <= 8          #=> true
7 >= 8          #=> false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
2 < 4;
9 > 7;
8 <= 8;
7 >= 8;
</pre>
        </div>
      </div>

      <p>Chained comparison:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

1 < 2 < 4        #=> true
1 < 2 == 4/2 > 0 #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$;
1 < 2 && 2 < 4;
1 < 2 && 2 === (ref$ = 4 / 2) && ref$ > 0;
</pre>
        </div>
      </div>

      <p>Minimum/maximum - returns the smaller/larger of the two operands.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

4 >? 8     #=> 8
9 - 5 &lt;? 6 #=> 4
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$;
4 > 8 ? 4 : 8;
(ref$ = 9 - 5) < 6 ? ref$ : 6;
</pre>
        </div>
      </div>

      <p>When one of the operands of a equals (<code>==</code> or <code>is</code>, and the negatives for that) is a regex literal it will test the other operand against it. Equality compiles to <code>exec</code> so you can use the results, while the negative simply compiles to <code>test</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
/^e(.*)/ is 'enter' #=> ["enter","nter"]
/^e(.*)/ == 'zx'    #=> null
/moo/ != 'loo'      #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
/^e(.*)/.exec('enter');
/^e(.*)/.exec('zx');
!/moo/.test('loo');
</pre>
        </div>
      </div>


      <h3 id="operators-logic">Logic</h3>

      <p>The basics:</p>

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
true and false #=> false
true && false  #=> false

true or false  #=> true
true || false  #=> true

not false      #=> true
!false         #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
true && false;
true && false;

true || false;
true || false;

!false;
!false;
</pre>
        </div>
      </div>

      <p>A logical operator not commonly seen in other languages - exclusive or:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
false xor true  #=> true
false xor false #=> false
1 xor 0         #=> 1
1 xor 1         #=> false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
!false !== !true && (false || true);
!false !== !false && (false || false);
!1 !== !0 && (1 || 0);
!1 !== !1 && (1 || 1);
</pre>
        </div>
      </div>

      <p><code>and</code>, <code>or</code>, and <code>xor</code> close implicit calls, while <code>||</code> and <code>&amp;&amp;</code> do not.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
even 0 and 3 #=> 3
even 0 &&  3 #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
even(0) && 3;
even(0 && 3);
</pre>
        </div>
      </div>

      <p>You can call logic operators.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
(f or g) 1
(f and g or h) 3 4
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
f(1) || g(1);
f(3, 4) && g(3, 4) || h(3, 4);
</pre>
        </div>
      </div>

      <h3 id="operators-in-of">In/Of</h3>

      <p>Use <code>in</code> to check if and element is in a list; use <code>of</code> to check if a key is in an object.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

list = [7 8 9]
2 in [1 2 3 4 5]             #=> true
3 in list                    #=> false
\id of id: 23, name: \rogers #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var list;
list = [7, 8, 9];
2 === 1 || 2 === 2 || 2 === 3 || 2 === 4 || 2 === 5;
in$(3, list);
'id' in {
  id: 23,
  name: 'rogers'
};
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
</pre>
        </div>
      </div>

      <a name="piping"></a>
      <h3 id="operators-piping">Piping</h3>

      <p>Instead of a series of nested function calls, you can pipe values in. <code>x |> f</code> and <code>f <| x</code> are equivalent to <code>f(x)</code>.


      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

x = [1 2 3] |> reverse |> head #=> 3


y = reverse <| [1 2 3] #=> [3,2,1]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x, y;
x = head(
reverse(
[1, 2, 3]));
y = reverse([1, 2, 3]);
</pre>
        </div>
      </div>

      <p>You can use newlines to space things out better.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
4
|> (+ 1)
|> even
#=> false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
even(
(function(it){
  return it + 1;
})(
4));
</pre>
        </div>
      </div>

      <a name="composing"></a>
      <h3 id="operators-composing">Function</h3>

      <p>Composing allows you to create functions by <em>composing</em> them out of a series of functions. LiveScript has two operators for composing, forward <code>&gt;&gt;</code> and backwards <code>&lt;&lt;</code>.

      <p><code>(f &lt;&lt; g) x</code> is equivalent to <code>f(g(x))</code>, and <code>(f &gt;&gt; g) x</code> is equivalent to <code>g(f(x))</code>. For example:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

odd     = (not) << even
odd 3   #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var odd;
odd = compose$(even, not$);
odd(3);
function compose$() {
  var functions = arguments;
  return function() {
    var i, result;
    result = functions[0].apply(this, arguments);
    for (i = 1; i < functions.length; ++i) {
      result = functions[i](result);
    }
    return result;
  };
}
function not$(x){ return !x; }
</pre>
        </div>
      </div>

      <p>To be a bit more clear about the difference between the two operators:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add-two-times-two = (+ 2) >> (* 2)
times-two-add-two = (+ 2) << (* 2)

add-two-times-two 3 #=> (3+2)*2 => 10
times-two-add-two 3 #=> (3*2)+2 => 8
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var addTwoTimesTwo, timesTwoAddTwo;
addTwoTimesTwo = compose$((function(it){
  return it + 2;
}), (function(it){
  return it * 2;
}));
timesTwoAddTwo = compose$((function(it){
  return it * 2;
}), (function(it){
  return it + 2;
}));
addTwoTimesTwo(3);
timesTwoAddTwo(3);
function compose$() {
  var functions = arguments;
  return function() {
    var i, result;
    result = functions[0].apply(this, arguments);
    for (i = 1; i < functions.length; ++i) {
      result = functions[i](result);
    }
    return result;
  };
}
</pre>
        </div>
      </div>

      <p>You can use a spaced dot as an alias to <code>&lt;&lt;</code>, for example <code>f . g</code>, just as in Haskell.

      <h3 id="operators-list">List</h3>

      <p>You can concatenate two lists together:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
<[ one two three ]> ++ [\four]
#=> ['one','two','three','four']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
['one', 'two', 'three'].concat(['four']);


</pre>
        </div>
      </div>

      <p>Note that the concat operator must either be spaced on both sides <code>xs ++ ys</code>, or not spaced on both sides <code>xs++ys</code>. If it is spaced on one side only, then it is taken to be the increment operator.

      <p>List repetition when first is list literal:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[\ha] * 3 #=> ['ha','ha','ha']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
['ha', 'ha', 'ha'];
</pre>
        </div>
      </div>

      <p>Join when the right operand is a string literal:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
<[ one two three ]> * \|      #=> 'one|two|three'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
['one', 'two', 'three'].join('|');
</pre>
        </div>
      </div>

      <p>Unary spread - when the operand is a list literal, apply the unary op to each item:<br />

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
r = +...[4 5 6]          #=> [+4, +5, +6]
t = typeof! ...[\b 5 {}] #=> ["String", "Number", "Object"]
c = ~...[4, 5]           #=> [-5, -6]
++...player<[strength hp]>
# also works with -, --, typeof, ! and delete!
i = new ...[some, classes]
c = ^^...[copy, these, {}]
delete ...list[1, 2, 3]
do ...[a, b, c]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var r, t, c, i, toString$ = {}.toString;
r = [+4, +5, +6];
t = [toString$.call('b').slice(8, -1), toString$.call(5).slice(8, -1), toString$.call({}).slice(8, -1)];
c = [~4, ~5];
++player['strength'], ++player['hp'];
i = [new some, new classes];
c = [clone$(copy), clone$(these), clone$({})];
delete list[1], delete list[2], delete list[3];
a(), b(), c();
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
</pre>
        </div>
      </div>

      <h3 id="operators-string">String</h3>

      <p>String concatenation:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
'hello' + ' ' + 'world' #=> 'hello world'
string = 'say '         #=> 'say '
string += \yeah         #=> 'say yeah'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var string;
'hello' + ' ' + 'world';
string = 'say ';
string += 'yeah';
</pre>
        </div>
      </div>

      <p>String repetition when the first operand is a string literal:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
'X' * 3      #=> 'XXX'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
'XXX';
</pre>
        </div>
      </div>

      <p>String subtraction/division when the right operand is a string or regex literal - subtraction means <code>replace</code>, division is <code>split</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
'say yeah' - /h/ #=> 'say yea'
'say yeah' / \y  #=> ['sa',' ','eah']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
'say yeah'.replace(/h/, '');
'say yeah'.split('y');
</pre>
        </div>
      </div>

      <h3 id="operators-existence">Existence</h3>

      <p>The <code>?</code> operator can be used in a variety of contexts to check for existence.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
bigfoot ? 'grizzly bear'     #=> 'grizzly bear'
string = \boom if window?    #=> 'boom'
document?.host               #=> 'gkz.github.com'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var string;
(typeof bigfoot == 'undefined' || bigfoot === null) && 'grizzly bear';
if (typeof window != 'undefined' && window !== null) {
  string = 'boom';
}
if (typeof document != 'undefined' && document !== null) {
  document.host;
}
</pre>
        </div>
      </div>

      <h3 id="operators-object">Object</h3>

      <p>Instanceof - list literals to the right get expanded:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

new Date() instanceof Date           #=> true
new Date() instanceof [Date, Object] #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$;
new Date() instanceof Date;
(ref$ = new Date()) instanceof Date || ref$ instanceof Object;
</pre>
        </div>
      </div>

      <p>Typeof - add a bang for a useful alternative:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

typeof /^/  #=> object
typeof! /^/ #=> RegExp
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var toString$ = {}.toString;
typeof /^/;
toString$.call(/^/).slice(8, -1);
</pre>
        </div>
      </div>

      <p>Delete returns the value of the deleted item:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = {one: 1, two: 2}
r = delete obj.one
r #=> 1
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj, r, ref$;
obj = {
  one: 1,
  two: 2
};
r = (ref$ = obj.one, delete obj.one, ref$);
r;
</pre>
        </div>
      </div>

      <p><code>delete!</code> is like <code>delete</code> in JavaScript, and returns false only if the property exists and can't be deleted, otherwise returns true.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = {one: 1, two: 2}
delete! obj.one #=> true
delete! Math.PI #=> false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj;
obj = {
  one: 1,
  two: 2
};
delete obj.one;
delete Math.PI;
</pre>
        </div>
      </div>

      <p>Property copy - copy enumerable properties from right to left, and evaluate to the left. <code>&lt;&lt;&lt;</code> for own properties, <code>&lt;&lt;&lt;&lt;</code> for all properties. <code>import</code> and <code>import all</code> are aliases for the two respectively with the exception that if you leave out the left operand, <code>this</code> is presumed.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = {one: 1, two: 2}
obj <<< three: 3 #=> {one: 1, two: 2, three: 3}
{go: true} <<<< window
import obj
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj;
obj = {
  one: 1,
  two: 2
};
obj.three = 3;
importAll$({
  go: true
}, window);
import$(this, obj);
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
</pre>
        </div>
      </div>

      <p>Clone - creates a prototypical clone of the operand. It does not create a deep clone of the object, rather the resulting object's prototype is the operand. Remember that prototypes are ignored when serializing to JSON.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

obj = {one: 1}


obj2 = ^^obj
obj2.two = 2
obj2 #=> {one: 1, two: 2}
# above includes its prototype's properties
# JSON serialization would be just `{two: 2}`
obj  #=> {one: 1}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj, obj2;
obj = {
  one: 1
};
obj2 = clone$(obj);
obj2.two = 2;
obj2;


obj;
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
</pre>
        </div>
      </div>

      <p>The infix <em>with</em> (aka the <em>cloneport</em>) combines the clone and property copy operators for easy object creation. It is equivalent to <code>^^obj &lt;&lt;&lt; obj2</code>. Remember that the clone operator creates a prototypical clone, and prototypes are not serialized in JSON.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
girl = {name: \hanna, age: 22}
guy  = girl with name: \john
guy  #=> {name: 'john',  age: 22}
# the above result include the object's prototype
# in the result - the actual JSON: {name: 'john'}
girl #=> {name: 'hanna', age: 22}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var girl, guy, ref$;
girl = {
  name: 'hanna',
  age: 22
};
guy = (ref$ = clone$(girl), ref$.name = 'john', ref$);
guy;
girl;
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
</pre>
        </div>
      </div>

      <h3 id="operators-partial">Partial Application, Operators as Functions</h3>

      <p>You can partially apply operators and use them as functions

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
(+ 2) 4         #=> 6
(*) 4 3         #=> 12

(not) true      #=> false
(in [1 to 3]) 2 #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
(function(it){
  return it + 2;
})(4);
curry$(function(x$, y$){
  return x$ * y$;
})(4, 3);
not$(true);
(function(it){
  return it === 1 || it === 2 || it === 3;
})(2);
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function not$(x){ return !x; }
</pre>
        </div>
      </div>

      <a name="export"></a>
      <h3 id="operators-export">export</h3>
      <p>By using the <code>export</code> operator instead of <code>exports</code> you get a more concise way to define modules.</p>

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">



export func = ->

export value

export value-a, value-b, value-c



export
  a: 1
  b: -> 123



export class MyClass
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var func, ref$, MyClass, out$ = typeof exports != 'undefined' && exports || this;

out$.func = func = function(){};

out$.value = value;

out$.valueA = valueA;
out$.valueB = valueB;
out$.valueC = valueC;

ref$ = out$;
ref$.a = 1;
ref$.b = function(){
  return 123;
};

out$.MyClass = MyClass = (function(){
  MyClass.displayName = 'MyClass';
  var prototype = MyClass.prototype, constructor = MyClass;
  function MyClass(){}
  return MyClass;
}());
</pre>
        </div>
      </div>

      <a name="require"></a>
      <h3 id="operators-require">require!</h3>

      <p>Having to require a series of modules results in a lot of cruft. You can get rid of that cruft by using <code>require!</code>, which takes an ID, or a string, array, or object literal.

      <p>If you are requiring a module with dashes in its name, you must use a string literal.

      <p>You can rename what you are requiring by using an object literal.

      <p>You can destructure to get the contents of value.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

require! lib
require! 'lib1'

require! prelude-ls # no
require! 'prelude-ls'

require! [fs, path]

require! <[ fs path ]>


require! jQuery: $

require! {
  fs
  path
  lib: foo
}
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var lib, lib1, preludeLs, fs, path, $, foo;
lib = require('lib');
lib1 = require('lib1');

preludeLs = require('preludeLs');
preludeLs = require('prelude-ls');

fs = require('fs');
path = require('path');
fs = require('fs');
path = require('path');

$ = require('jQuery');


fs = require('fs');
path = require('path');
foo = require('lib');


</pre>
        </div>
      </div>

      <p>You can easily require parts of modules with destructuring.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
require! {
    fs: filesystem
    'prelude-ls': {map, id}
    path: {join, resolve}:p
}
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var filesystem, ref$, map, id, p, join, resolve;
filesystem = require('fs');
ref$ = require('prelude-ls'), map = ref$.map, id = ref$.id;
p = require('path'), join = p.join, resolve = p.resolve;
</pre>
        </div>
      </div>

      <p>Filenames are automatically extracted.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

require! 'lib.js'
require! './dir/lib1.js'
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var lib, lib1;
lib = require('lib.js');
lib1 = require('./dir/lib1.js');
</pre>
        </div>
      </div>

    </div>

    <div id="functions" class="section">
      <a name="functions"></a>
      <h2>Functions</h2>

      <p>Defining functions is very lightweight in LiveScript:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

(x, y) -> x + y


-> # an empty function

times = (x, y) ->
  x * y
# multiple lines, and be assigned to
# a var like in JavaScript
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var times;
(function(x, y){
  return x + y;
});
(function(){});

times = function(x, y){
  return x * y;
};
</pre>
        </div>
      </div>

      <p>As you see, function definitions are considerably shorter! You may also have noticed that we have omitted <code>return</code>. In LiveScript, almost everything is an expression and the last one reached is automatically returned.

      <p>You can prepend the function arrow with a bang <code>!</code> to suppress automatic returning.


      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
f = !-> 2
g = (x) !-> x + 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var f, g;
f = function(){
  2;
};
g = function(x){
  x + 2;
};
</pre>
        </div>
      </div>

      <h3 id="functions-calling">Calling</h3>

      <p>You can omit the parentheses when calling a function, and you can omit the comma separating the arguments if the preceding item is not callable, just like in arrays.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

x = 4
Math.pow x, 3 #=> 64
Math.pow 2 3  #=> 8
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 4;
Math.pow(x, 3);
Math.pow(2, 3);
</pre>
        </div>
      </div>

      <p>If you are calling the function with no arguments, you can use a bang <code>!</code> - as well you don't need to use a dot when chaining banged functions.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
f!
[1 2 3].reverse!slice 1 #=> [2,1]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
f();
[1, 2, 3].reverse().slice(1);
</pre>
        </div>
      </div>

      <p><code>and</code>, <code>or</code>, <code>xor</code>, spaced <code>.</code>  or <code>?.</code> all close implicit calls - allowing for parentheses free chaining.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
$ \h1 .find \a .text! #=> LiveScript
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
$('h1').find('a').text();
</pre>
        </div>
      </div>

      <p>You can use <code>do</code> to call functions with no arguments:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
do -> 3 + 2 #=> 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
(function(){
  return 3 + 2;
})();
</pre>
        </div>
      </div>

      <p>If you use <code>do</code> on a named function, when the <code>do</code> is not used as an expression, the named function will remain a function statement.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
i = 0
f 9 #=> 9
i   #=> 1
do function f x
  ++i
  x
i   #=> 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i;
i = 0;
f(9);
i;
function f(x){
  ++i;
  return x;
} f();
i;
</pre>
        </div>
      </div>

      <p>You can't call a function with an implicit object, if you want to do that you can use <code>do</code>:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
func do
  a: 1
  b: 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
func({
  a: 1,
  b: 2
});
</pre>
        </div>
      </div>

      <p><code>do</code> allows you to do many things without adding extra parentheses.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
pow do
  1
  2

h 1 do
  a: 2
  b: 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
pow(1, 2);


h(1, {
  a: 2,
  b: 5
});

</pre>
        </div>
      </div>

      <p>You can also call functions infix using backticks <code>`</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add = (x, y) -> x + y
3 `add` 4 #=> 7
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var add;
add = function(x, y){
  return x + y;
};
add(3, 4);
</pre>
        </div>
      </div>

      <p>Calling a function with bare splats <code>...</code> implies calling it with the arguments of the current function. Especially useful when calling <code>super</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
f = (x, y) ->
  x + y

g = (a, b) ->
  f ...

g 3 4 #=> 7
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var f, g;
f = function(x, y){
  return x + y;
};
g = function(a, b){
  return f.apply(this, arguments);
};
g(3, 4);
</pre>
        </div>
      </div>

      <h3 id="functions-paramaters">Parameters</h3>

      <p>Extended parameters:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
set-person-params = (
  person # target object to set params
  person.age
  person.height
) -> person

person = set-person-params {}, 21, 180cm
#=> {age: 21, height: 180}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var setPersonParams, person;
setPersonParams = function(person, age, height){
  person.age = age;
  person.height = height;
  return person;
};
person = setPersonParams({}, 21, 180);
</pre>
        </div>
      </div>

      <p>This is especially useful with <code>this</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
set-text = (@text) -> this
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var setText;
setText = function(text){
  this.text = text;
  return this;
};
</pre>
        </div>
      </div>

      <p>You can set default arguments:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add = (x = 4, y = 3) -> x + y
add 1 2 #=> 3
add 1   #=> 4
add!    #=> 7
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var add;
add = function(x, y){
  x == null && (x = 4);
  y == null && (y = 3);
  return x + y;
};
add(1, 2);
add(1);
add();
</pre>
        </div>
      </div>

      <p>...or indeed use any logical operator (in parameters, <code>x = 2</code> is just sugar for doing <code>x ? 2</code>):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add = (x && 4, y || 3) -> x + y
add 1 2 #=> 6
add 2 0 #=> 7
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var add;
add = function(x, y){
  x && (x = 4);
  y || (y = 3);
  return x + y;
};
add(1, 2);
add(2, 0);
</pre>
        </div>
      </div>

      <p>You can also destructure the arguments:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
set-cords = ({x, y}) -> "#x,#y"
set-cords y: 2, x: 3 #=> '3,2'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var setCords;
setCords = function(arg$){
  var x, y;
  x = arg$.x, y = arg$.y;
  return x + "," + y;
};
setCords({
  y: 2,
  x: 3
});
</pre>
        </div>
      </div>

      <p>...and even set defaults (or use any logic) on those destructured parameters, functioning like Python's keyword arguments.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
set-cords = ({x = 1, y = 3} = {}) -> "#x,#y"
set-cords y: 2, x: 3 #=> '3,2'
set-cords x: 2       #=> '2,3'
set-cords y: 7       #=> '1,7'
set-cords!           #=> '1,3'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var setCords;
setCords = function(arg$){
  var ref$, x, ref1$, y;
  ref$ = arg$ != null
    ? arg$
    : {}, x = (ref1$ = ref$.x) != null ? ref1$ : 1, y = (ref1$ = ref$.y) != null ? ref1$ : 3;
  return x + "," + y;
};
setCords({
  y: 2,
  x: 3
});
setCords({
  x: 2
});
setCords({
  y: 7
});
setCords();
</pre>
        </div>
      </div>

      <p>You can also use splats in your parameters:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
f = (x, ...ys) -> x + ys.1
f 1 2 3 4 #=> 4
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var f;
f = function(x){
  var ys, res$, i$, to$;
  res$ = [];
  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  ys = res$;
  return x + ys[1];
};
f(1, 2, 3, 4);
</pre>
        </div>
      </div>

      <a name="params-unary-ops"></a>

      <p>You can even use unary operators in your parameters. You could use <code>+</code> and <code>!!</code> to cast your parameters to a number or boolean respectively, or use the clone operator <code>^^</code> to make sure any changes you make to the object are not reflected in the original. You can still use extended parameters, eg. <code>(!!x.x) -&gt;</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

f = (!!x) -> x
f 'truthy string' #=> true




g = (+x) -> x
g '' #=> 0




obj = {prop: 1}
h = (^^x) ->
  x.prop = 99
  x
h obj
obj.prop #=> 1
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var f, g, obj, h;
f = function(x){
  x = !!x;
  return x;
};
f('truthy string');

g = function(x){
  x = +x;
  return x;
};
g('');

obj = {
  prop: 1
};
h = function(x){
  x = clone$(x);
  x.prop = 99;
  return x;
};
h(obj);
obj.prop;

function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
</pre>
        </div>
      </div>

      <h3 id="functions-currying">Currying</h3>

      <p>Curried functions are very powerful. Essentially, when called with less arguments than defined with, they return a partially applied function. This means that it returns a function whose arguments are those which you didn't supply, with the values for what you did supply already bound. They are defined in LiveScript using the long arrow. Perhaps an example will make things more clear:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
times = (x, y) --> x * y
times 2, 3       #=> 6 (normal use works as expected)
double = times 2
double 5         #=> 10
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var times, double;
times = curry$(function(x, y){
  return x * y;
});
times(2, 3);
double = times(2);
double(5);
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
</pre>
        </div>
      </div>

      <p>You can define bound curried functions with a long wavy arrow: <code>~~&gt;</code>

      <p>If you call a curried function with no arguments, it will evaluate as is, allowing you to use default arguments.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
f = (x = 5, y = 10) --> x + y
f! #=> 15
g = f 20
g 7 #=> 27
g!  #=> 30
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var f, g;
f = curry$(function(x, y){
  x == null && (x = 5);
  y == null && (y = 10);
  return x + y;
});
f();
g = f(20);
g(7);
g();
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
</pre>
        </div>
      </div>

      <h3 id="functions-named">Named Functions</h3>

      <p>You can create named functions whose definition is hoisted to the top of the scope - this is useful for defining utility functions at the end of the file instead of the top. Name functions are constants, and can't be redefined.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
util!  #=> 'available above declaration'
util2! #=> 2

function util
  'available above declaration'
function util2 then 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
util();
util2();
function util(){
  return 'available above declaration';
}
function util2(){
  return 2;
}
</pre>
        </div>
      </div>

      <p>You can prepend the function definition with a <code>~</code> to make it a bound function.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
~function add x, y
  @result = x + y
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var this$ = this;
function add(x, y){
  return this$.result = x + y;
}
</pre>
        </div>
      </div>

      <p>You can prepend it with a bang <code>!</code> to suppress returning.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
util! #=> nothing
!function util x then x
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
util();
function util(x){
  x;
}
</pre>
        </div>
      </div>

      <p>You can combine the <code>~</code> and <code>!</code> to make a bound non-returning function if you wish.

      <h3 id="functions-bound">Bound Functions</h3>

      <p>Defined using the wavy arrow <code>~&gt;</code>. Use the long wavy arrow for curried and bound functions <code>~~&gt;</code>. Prepend a <code>~</code> to named functions to make them bound.

      <p>Bound functions have <code>this</code> lexically bound, not dynamically bound as normally. This means that it does not matter in which context they are called, the value of <code>this</code> in their body will always be the value of <code>this</code> where they were defined.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = new
  @x      = 10
  @normal = -> @x
  @bound  = ~> @x

obj2 = x: 5
obj2.normal = obj.normal
obj2.bound  = obj.bound

obj2.normal! #=> 5
obj2.bound!  #=> 10
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj, obj2;
obj = new function(){
  var this$ = this;
  this.x = 10;
  this.normal = function(){
    return this.x;
  };
  this.bound = function(){
    return this$.x;
  };
};
obj2 = {
  x: 5
};
obj2.normal = obj.normal;
obj2.bound = obj.bound;
obj2.normal();
obj2.bound();
</pre>
        </div>
      </div>

      <p>Check out the <a href="#oop">OOP</a> section for more on bound functions when used in classes.

      <h3 id="functions-let-new">Let, New</h3>

      <p><code>let</code> is short for <code>(function(a){...}.call(this, b))</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
let $ = jQuery
  $.isArray [] #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
(function($){
  $.isArray([]);
}.call(this, jQuery));
</pre>
        </div>
      </div>

      <p>You can also define <code>this</code> (aka <code>@</code>) with <code>let</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = let @ = a: 1, b: 2
  @b ^ 3
x #=> 8
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = (function(){
  return Math.pow(this.b, 3);
}.call({
  a: 1,
  b: 2
}));
x;
</pre>
        </div>
      </div>

      <p>With new context:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

dog = new
  @name = \spot
  @mutt = true
#=> {name: 'spot', mutt: true}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var dog;
dog = new function(){
  this.name = 'spot';
  this.mutt = true;
};
</pre>
        </div>
      </div>

      <h3 id="functions-shorthand">Access/Call Function Shorthand</h3>

      <p>There are especially useful for higher order functions like map and filter.

      <p><code>(.prop)</code> is short for <code>(it) -> it.prop</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
map (.length), <[ hello there you ]>
#=> [5,5,3]

filter (.length < 4), <[ hello there you ]>
#=> ['you']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
map(function(it){
  return it.length;
}, ['hello', 'there', 'you']);
filter(function(it){
  return it.length < 4;
}, ['hello', 'there', 'you']);
</pre>
        </div>
      </div>

      <p>You can also use this to call methods:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
map (.join \|), [[1 2 3], [7 8 9]]
#=> ['1|2|3','7|8|9']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
map(function(it){
  return it.join('|');
}, [[1, 2, 3], [7, 8, 9]]);
</pre>
        </div>
      </div>

      <p><code>(obj.)</code> is short for <code>(it) -> obj[it]</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = one: 1, two: 2, three: 3
map (obj.), <[ one three ]>
#=> [1,3]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj;
obj = {
  one: 1,
  two: 2,
  three: 3
};
map(function(it){
  return obj[it];
}, ['one', 'three']);
</pre>
        </div>
      </div>

      <a name="backcalls"></a>
      <h3 id="functions-backcalls">Backcalls</h3>

      <p>Backcalls are very useful. They allow you to unnest callbacks. They are defined using arrows pointed to the left. All the syntax is the same as regular arrows for defining bound functions (<code><~</code>), curried functions (<code><--, <~~</code>), suppressing return (<code><-!</code>) - except that it is just pointing the other way.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
<- $
alert \boom
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
$(function(){
  return alert('boom');
});
</pre>
        </div>
      </div>

      <p>They can take arguments, and you can specify a placeholder for where you want it to go.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x <- map _, [1 to 3]
x * 2
#=> [2, 4, 6]
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
map(function(x){
  return x * 2;
}, [1, 2, 3]);
</pre>
        </div>
      </div>

      <p>If you wish to have further code after your backcalls, you can set them aside with a <code>do</code> statement.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
do
  data <-! $.get 'ajaxtest'
  $ '.result' .html data
  processed <-! $.get 'ajaxprocess', data
  $ '.result' .append processed

alert 'hi'
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
$.get('ajaxtest', function(data){
  $('.result').html(data);
  $.get('ajaxprocess', data, function(processed){
    $('.result').append(processed);
  });
});
alert('hi');
</pre>
        </div>
      </div>

      <h3 id="async-await">Async and Await</h2>

      <p>If you will be running your compiled code on a platform that supports the <code>async</code> and <code>await</code> JavaScript keywords, then you can write true asynchronous functions in LiveScript. To mark a function as async, either add an extra <code>&gt;</code> to the function arrow (<code>-&gt;&gt;</code>, <code>~&gt;&gt;</code>, <code>--&gt;&gt;</code>, etc.), or write <code>async function</code> instead of <code>function</code> for named functions. Inside an async function, you can use the <code>await</code> keyword as you would in JavaScript.

      <div class="example">
        <div class="example-ls">
      <pre class="prettyprint lang-ls">

f1 = (x) ->> await x


async function f2 x
  a = await f1 x

</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var f1;
f1 = async function(x){
  return (await x);
};
async function f2(x){
  var a;
  return a = (await f1(x));
}
</pre>
  </div>
</div>

      <h3 id="functions-partial">Partial Application</h3>

      <p>You can partially apply functions using the underscore <code>_</code> as a placeholder. Sometimes, the function you want to deal with isn't curried, or if it is the arguments are not in a good order. In these cases partial application is very useful.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

filter-nums = filter _, [1 to 5]
filter-nums even  #=> [2,4]
filter-nums odd   #=> [1,3,5]
filter-nums (< 3) #=> [1,2]
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var filterNums, slice$ = [].slice;
filterNums = partialize$.apply(this, [filter, [void 8, [1, 2, 3, 4, 5]], [0]]);
filterNums(even);
filterNums(odd);
filterNums((function(it){
  return it < 3;
}));
function partialize$(f, args, where){
  var context = this;
  return function(){
    var params = slice$.call(arguments), i,
        len = params.length, wlen = where.length,
        ta = args ? args.concat() : [], tw = where ? where.concat() : [];
    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
    return len < wlen && len ?
      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
  };
}
</pre>
        </div>
      </div>

      <p>If you call a partially applied function with no arguments, it will execute as is instead of returning itself, allowing you to use default arguments.

      <p>Partially applied functions are also really useful for piping if the functions you are using don't have a nice argument order and aren't curried (like in underscore.js for instance).

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[1 2 3]
|> _.map _, (* 2)
|> _.reduce _, (+), 0
#=> 12
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
_.reduce(_.map([1, 2, 3], (function(it){
  return it * 2;
})), curry$(function(x$, y$){
  return x$ + y$;
}), 0);
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
</pre>
        </div>
      </div>

      <h3 id="functions-arguments">Arguments</h3>

      <p>If you have only one argument, you can use <code>it</code> to access it without having to define an argument.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
f = -> it + 2
f 3 #=> 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var f;
f = function(it){
  return it + 2;
};
f(3);
</pre>
        </div>
      </div>

      <p>You can access the <code>arguments</code> object with the shorthand <code>&</code>. The first argument is <code>&0</code>, the second <code>&1</code>, and so on. <code>&</code> alone is <code>arguments</code> as a whole.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

add-three-numbers = -> &0 + &1 + &2
add-three-numbers 1 2 3 #=> 6
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var addThreeNumbers;
addThreeNumbers = function(){
  return arguments[0] + arguments[1] + arguments[2];
};
addThreeNumbers(1, 2, 3);
</pre>
        </div>
      </div>

      <p>Note that currying won't work in that situation, as the number of declared arguments in <code>add-three-numbers</code> is 0.

      <h3 id="functions-more">More</h3>

      <p>Check out the section on <a href="#composing">composing functions</a>, and <a href="#piping">piping</a> as well.

    </div>


    <div id="generators-yield" class="section">
      <a name="generators-yield"></a>
      <h2>Generators and Yield</h2>

      <p>You can use generators and yield in your LiveScript code! A brief rundown:

      <div class="example">
        <div class="example-ls">
      <pre class="prettyprint lang-ls">

function* f
    yield "foo"

g = ->*
    yield from f!
    yield "bar"

h = g!
h.next!.value + h.next!.value #=> "foobar"
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var g, h;
function* f(){
  return (yield "foo");
}
g = function*(){
  (yield* f());
  return (yield "bar");
};
h = g();
h.next().value + h.next().value;
</pre>
  </div>
</div>

      <p>You can create generators by either appending a star <code>*</code> to the <code>function</code> keyword, or appending it to LiveScript's arrow notation. This works with the variety of arrows we have.

      <p><code>yield</code> is simply the same as in JavaScript, and <code>yield from</code> is JavaScript's <code>yield*</code>.

      <p>To run code using generators and yield using node 0.11, use the <code>--harmony</code> flag. If running directly with <code>lsc</code>, use <code>lsc file.ls --nodejs --harmony</code> to pass the harmony flag to node.

    </div>


    <div id="if-unless" class="section">
      <a name="if-unless"></a>
      <h2>If and Unless</h2>

      <p>There are several ways to format an <code>if</code> statement. (Note that the <code>if</code> statement is actually an expression, and be used as such).

      <p>The standard:


      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
if 2 + 2 == 4
  'something'
else
  'something else'

if 2 + 2 == 4 then 'something' else 'something else'




if 2 + 2 == 4
then 'something'
else 'something else'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
if (2 + 2 === 4) {
  'something';
} else {
  'something else';
}
if (2 + 2 === 4) {
  'something';
} else {
  'something else';
}
if (2 + 2 === 4) {
  'something';
} else {
  'something else';
}
</pre>
        </div>
      </div>

      <p>The <code>else</code> is optional, and further <code>else if</code>s can be added.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
if 2 + 2 == 4
  'something'

if 2 + 2 == 6
  'something'
else if 2 + 2  == 5
  'something else'
else
  'the default'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
if (2 + 2 === 4) {
  'something';
}
if (2 + 2 === 6) {
  'something';
} else if (2 + 2 === 5) {
  'something else';
} else {
  'the default';
}
</pre>
        </div>
      </div>

      <p>It can be used as an expression:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
result = if 2 / 2 is 0
         then 'something'
         else 'something else'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var result;
result = 2 / 2 === 0 ? 'something' : 'something else';
</pre>
        </div>
      </div>

      <p>It can also be used postfix - it has a lower precedence than assignment, making this useful:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = 10
x = 3 if 2 + 2 == 4
x #=> 3
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 10;
if (2 + 2 === 4) {
  x = 3;
}
x;
</pre>
        </div>
      </div>

      <p><code>unless</code> is the equivalent to <code>if not</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

unless 2 + 2 == 5
  'something'

x = 10
x = 3 unless 2 + 2 == 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x;
if (2 + 2 !== 5) {
  'something';
}
x = 10;
if (2 + 2 !== 5) {
  x = 3;
}
</pre>
        </div>
      </div>

      <p><code>that</code> refers implicitly to the value of the condition. It will unwrap existence checks.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
time = days: 365



half-year = that / 2 if time.days
#=> 182.5

if /^e(.*)/ == 'enter'
  that.1   #=> 'nter'

if half-year?
  that * 2 #=> 365
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var time, that, halfYear;
time = {
  days: 365
};
if (that = time.days) {
  halfYear = that / 2;
}
if (that = /^e(.*)/.exec('enter')) {
  that[1];
}
if ((that = halfYear) != null) {
  that * 2;
}
</pre>
        </div>
      </div>

    </div>
    <div id="loops" class="section">
      <a name="loops"></a>
      <h2>Loops and Comprehensions</h2>

      <p>There are three basic forms of <code>for</code> loop. One that iterates through a range of numbers, one that iterates through items in a list, and one that iterates through keys and values of an object.

      <p>We will first examine the <code>for</code> loop that iterates through a range of numbers. It has the structure of: <code>for (let) (VAR) (from NUM) (to|til NUM) (by NUM) (when COND)</code> - (almost everything is optional).
      <p><code>let</code> has the effect of wrapping the loop body in an immediately invoked function expression, useful for when you are creating functions in a loop and want the loop variables to be the current - not final - values in the function when it is called. It's also useful as it means the variables in your loop are not exposed to the loops surrounding scope.
      <p>Counting <code>from</code> a number, if omitted defaults to <code>0</code>.
      <p>Counting up <code>to</code> and including a number, or counting up <code>til</code> (but not including) a number.
      <p><code>by</code> is the step value, the default is <code>1</code>.
      <p><code>when</code>, (alias <code>case</code>, <code>|</code>) is an optional guard.
      <p>If used as an expression, loops will evaluate to a list.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

for i from 1 to 10 by 3
  i
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i$, i;
for (i$ = 1; i$ <= 10; i$ += 3) {
  i = i$;
  i;
}
</pre>
        </div>
      </div>

      <p><code>for ... in</code> loops iterate through a list. They have the structure: <code>for (let) (VAL-VAR)(, INDEX-VAR) in EXP (by NUM) (when COND)</code> - again almost everything is optional.

      <p><code>let</code>, <code>by</code>, and <code>when</code> are as before.

      <p><code>VAL-VAR</code> evaluates to the current value, while <code>INDEX-VAR</code> evaluates to the current index of the list. Either one is optional.

      <p><code>EXP</code> should evaluate to an array.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
for x in [1 2 3]
  x

xs = for let x, i in [1 to 10] by 2 when x % 3 == 0
  -> i + x
xs[0]! #=> 5
xs[1]! #=> 17
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i$, ref$, len$, x, xs, res$, i;
for (i$ = 0, len$ = (ref$ = [1, 2, 3]).length; i$ < len$; ++i$) {
  x = ref$[i$];
  x;
}
res$ = [];
for (i$ = 0, len$ = (ref$ = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]).length; i$ < len$; i$ += 2) {
  i = i$;
  x = ref$[i$];
  if (x % 3 === 0) {
    res$.push((fn$.call(this, i, x)));
  }
}
xs = res$;
xs[0]();
xs[1]();
function fn$(i, x){
  return function(){
    return i + x;
  };
}
</pre>
        </div>
      </div>

      <p><code>for ... of</code> loops iterate through an object. They have the structure: <code>for (own) (let) (KEY-VAR)(, VAL-VAR) of EXP (when COND)</code> - again almost everything is optional.

      <p><code>let</code> and <code>when</code> are as before.

      <p><code>own</code> uses the <code>hasOwnProperty</code> check on the properties, stopping the iteration of properties higher up in the prototype chain.

      <p><code>KEY-VAR</code> evaluates to the key of the property, and <code>VAL-VAR</code> evaluates to the property value. Either one is optional.

      <p><code>EXP</code> should evaluate to an object.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
for k, v of {a: 1, b: 2}
  "#k#v"

xs = for own let key, value of {a: 1, b: 2, c: 3, d: 4} when value % 2 == 0
  -> key + value
xs[0]! #=> 'b2'
xs[1]! #=> 'd4'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var k, ref$, v, xs, res$, i$, key, value, own$ = {}.hasOwnProperty;
for (k in ref$ = {
  a: 1,
  b: 2
}) {
  v = ref$[k];
  k + "" + v;
}
res$ = [];
for (i$ in ref$ = {
  a: 1,
  b: 2,
  c: 3,
  d: 4
}) if (own$.call(ref$, i$)) {
  key = i$;
  value = ref$[i$];
  if (value % 2 === 0) {
    res$.push((fn$.call(this, key, value)));
  }
}
xs = res$;
xs[0]();
xs[1]();
function fn$(key, value){
  return function(){
    return key + value;
  };
}
</pre>
        </div>
      </div>

      <p>Regular nested loops will evaluate to a list of lists.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
result = for x to 3
  for y to 2
    x + y
result #=> [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var result, res$, i$, x, lresult$, j$, y;
res$ = [];
for (i$ = 0; i$ <= 3; ++i$) {
  x = i$;
  lresult$ = [];
  for (j$ = 0; j$ <= 2; ++j$) {
    y = j$;
    lresult$.push(x + y);
  }
  res$.push(lresult$);
}
result = res$;
result;
</pre>
        </div>
      </div>

      <p>You can omit one or both variables in <code>in</code>/<code>of</code> loops.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
res = for , i in [1 2 3]
  i
res #=> [0, 1, 2]

for til 3 then func!
# calls func three times

[6 for til 3] #=> [6, 6, 6]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var res, res$, i$, len$, i;
res$ = [];
for (i$ = 0, len$ = [1, 2, 3].length; i$ < len$; ++i$) {
  i = i$;
  res$.push(i);
}
res = res$;
res;
for (i$ = 0; i$ < 3; ++i$) {
  func();
}
for (i$ = 0; i$ < 3; ++i$) {
  6;
}
</pre>
        </div>
      </div>

      <p>List comprehensions always produce a list. Nested comprehensions produce a flattened list.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[x + 1 for x to 10 by 2 when x isnt 4]
#=> [1,3,7,9,11]







["#x#y" for x in [\a \b] for y in [1 2]]
#=> ['a1','a2','b1','b2']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i$, x, ref$, len$, j$, ref1$, len1$, y;
for (i$ = 0; i$ <= 10; i$ += 2) {
  x = i$;
  if (x !== 4) {
    x + 1;
  }
}
for (i$ = 0, len$ = (ref$ = ['a', 'b']).length; i$ < len$; ++i$) {
  x = ref$[i$];
  for (j$ = 0, len1$ = (ref1$ = [1, 2]).length; j$ < len1$; ++j$) {
    y = ref1$[j$];
    x + "" + y;
  }
}
</pre>
        </div>
      </div>

      <p>You can use whitespace to better format comprehensions.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[{id:id1, name, age} for {id:id1, name} in table1
                     for {id:id2, age} in table2
                     when id1 is id2]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i$, ref$, len$, ref1$, id1, name, j$, len1$, ref2$, id2, age;
for (i$ = 0, len$ = (ref$ = table1).length; i$ < len$; ++i$) {
  ref1$ = ref$[i$], id1 = ref1$.id, name = ref1$.name;
  for (j$ = 0, len1$ = (ref1$ = table2).length; j$ < len1$; ++j$) {
    ref2$ = ref1$[j$], id2 = ref2$.id, age = ref2$.age;
    if (id1 === id2) {
      ({
        id: id1,
        name: name,
        age: age
      });
    }
  }
}
</pre>
        </div>
      </div>

      <a name="cascade-implicit-map"></a>
      <p>You can use the cascade to implicit refer to the value being mapped.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

[.. + 1 for [1 2 3]] #=> [2, 3, 4]



list-of-obj =
  * name: 'Alice'
    age: 23
  * name: 'Betty'
    age: 26




[..name for list-of-obj] #=> ['Alice', 'Betty']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i$, x$, ref$, len$, listOfObj, y$;
for (i$ = 0, len$ = (ref$ = [1, 2, 3]).length; i$ < len$; ++i$) {
  x$ = ref$[i$];
  x$ + 1;
}
listOfObj = [
  {
    name: 'Alice',
    age: 23
  }, {
    name: 'Betty',
    age: 26
  }
];
for (i$ = 0, len$ = listOfObj.length; i$ < len$; ++i$) {
  y$ = listOfObj[i$];
  y$.name;
}
</pre>
        </div>
      </div>
      <p>Object comprehensions produce an object.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
{[key, val * 2] for key, val of {a: 1, b: 2}}
#=> {a: 2, b: 4}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var key, ref$, val;
for (key in ref$ = {
  a: 1,
  b: 2
}) {
  val = ref$[key];
  [key, val * 2];
}
</pre>
        </div>
      </div>

      <p><code>while</code> loops:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

i = 0
list = [1 to 10]
while n < 9
  n = list[++i]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i, list, n;
i = 0;
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
while (n < 9) {
  n = list[++i];
}
</pre>
        </div>
      </div>

      <p><code>until</code> is equivalent to <code>while not</code>.

      <p><code>while</code>/<code>until</code> can also accept a <code>when</code> guard, and an optional <code>else</code> clause which runs if the didn't run at all.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

i = 1
list = [1 to 10]
until i > 7 when n isnt 99
  n = list[++i]
else
  10
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i, list, yet$, n;
i = 1;
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
for (yet$ = true; !(i > 7);) {
  yet$ = false;
  if (n !== 99) {
    n = list[++i];
  }
} if (yet$) {
  10;
}
</pre>
        </div>
      </div>

      <p>Do while:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

i = 0
list = [1 to 10]
do
  i++
while list[i] < 9
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i, list;
i = 0;
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
do {
  i++;
} while (list[i] < 9);
</pre>
        </div>
      </div>

      <p>While can also accept an update clause.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

i = 0
list = [1 to 10]
while list[i] < 9, i++ then i
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i, list;
i = 0;
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
for (; list[i] < 9; i++) {
  i;
}
</pre>
        </div>
      </div>

      <p>While true:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

i = 0
loop
  \ha
  break if ++i > 20



i = 0
for ever
  \ha
  if ++i > 20
     break
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i;
i = 0;
for (;;) {
  'ha';
  if (++i > 20) {
    break;
  }
}
i = 0;
for (;;) {
  'ha';
  if (++i > 20) {
    break;
  }
}
</pre>
        </div>
      </div>

    </div>

    <div id="switch" class="section">
      <a name="switch"></a>
      <h2>Switch</h2>

      <p><code>break</code> is automatically inserted, and multiple conditions are allowed.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
switch 6
case 1    then \hello
case 2, 4 then \boom
case 6
  'here it is'
default \something
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
switch (6) {
case 1:
  'hello';
  break;
case 2:
case 4:
  'boom';
  break;
case 6:
  'here it is';
  break;
default:
  'something';
}
</pre>
        </div>
      </div>

      <p>If you switch on nothing, you switch on true. (It compile to switching on false so it can cast the cases to booleans with one <code>!</code> instead of two).

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
switch
case 5 == 6
  \never
case false
  'also never'
case 6 / 2 is 3
  'here'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
switch (false) {
case 5 !== 6:
  'never';
  break;
case !false:
  'also never';
  break;
case 6 / 2 !== 3:
  'here';
}
</pre>
        </div>
      </div>

      <p>You can use <code>fallthrough</code> to stop automatic <code>break</code> insertion. It must be the last expression of the case block. As well, you can use a switch statement as an expression.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
result = switch 6
case 6
  something = 5
  fallthrough
case 4
  'this is it'

result #=> 'this is it'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var result, something;
result = (function(){
  switch (6) {
  case 6:
    something = 5;
    // fallthrough
  case 4:
    return 'this is it';
  }
}());
result;
</pre>
        </div>
      </div>

      <p><code>|</code> is an alias for <code>case</code>, and <code>=&gt;</code> is an alias for <code>then</code>. <code>| otherwise</code> and <code>| _</code> are aliases for <code>default</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
switch 'moto'
| "some thing"     => \hello
| \explosion \bomb => \boom
| <[ the moto ? ]> => 'here it is'
| otherwise        => \something
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
switch ('moto') {
case "some thing":
  'hello';
  break;
case 'explosion':
case 'bomb':
  'boom';
  break;
case 'the':
case 'moto':
case '?':
  'here it is';
  break;
default:
  'something';
}
</pre>
        </div>
      </div>

      <p>You can use <code>that</code> with a switch statement:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

switch num
| 2         => console.log that
| otherwise => console.log that
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var that;
switch (that = num) {
case 2:
  console.log(that);
  break;
default:
  console.log(that);
}
</pre>
        </div>
      </div>

      <p>An implicit <code>switch</code> is added after arrows (eg. <code>-></code>), <code>:</code>, and <code>=</code> if the next token is <code>case</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
func = (param) ->
  | param.length < 5 => param.length
  | otherwise        => param.slice 3

func 'hello' #=> lo





state = | 2 + 2 is 5 => 'I love Big Brother'
        | _          => 'I love Julia'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var func, state;
func = function(param){
  switch (false) {
  case !(param.length < 5):
    return param.length;
  default:
    return param.slice(3);
  }
};
func('hello');
state = (function(){
  switch (false) {
  case 2 + 2 !== 5:
    return 'I love Big Brother';
  default:
    return 'I love Julia';
  }
}());
</pre>
        </div>
      </div>

      <p>You can also use CoffeeScript style <code>switch</code> statements.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
day = \Sun
switch day
  when "Mon" then 'go to work'
  when "Tue" then 'go to a movie'
  when "Thu" then 'go drinking'
  when "Fri", "Sat"
      'go dancing'
  when "Sun" then 'drink more'
  else 'go to work'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var day;
day = 'Sun';
switch (day) {
case "Mon":
  'go to work';
  break;
case "Tue":
  'go to a movie';
  break;
case "Thu":
  'go drinking';
  break;
case "Fri":
case "Sat":
  'go dancing';
  break;
case "Sun":
  'drink more';
  break;
default:
  'go to work';
}
</pre>
        </div>
      </div>

    </div>


    <div id="assignment" class="section">
      <a name="assignment"></a>
      <h2>Assignment</h2>

      <p>Basic assignment is as you would expect, <code>variable = value</code>, and there is no need for variable declarations. However, unlike CoffeeScript, you must use <code>:=</code> to modify variables in upper scopes.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

x = 10


do ->
  x = 5

x #=> 10

do ->
  x := 2

x #=> 2
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 10;

(function(){
  var x;
  return x = 5;
})();
x;

(function(){
  return x = 2;
})();
x;
</pre>
        </div>
      </div>

      <p>Almost everything is an expression, which means you can do things like:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = if 2 + 2 == 4
    then 10
    else 0
x #=> 10
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 2 + 2 === 4 ? 10 : 0;
x;
</pre>
        </div>
      </div>

      <p>Things such as loops, switch statements, and even try/catch statements are all expressions.

      <p>If you want to simply declare a variable and not initialize it, you can use <code>var</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
var x
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
</pre>
        </div>
      </div>

      <p>You can also declare constants in LiveScript using <code>const</code>. They are checked at compile time - the compiled JS is no different.

      <p>Attempting to compile the following:

<pre class="prettyprint lang-ls">
const x = 10
x = 0
</pre>

      <p>Results in <code>redeclaration of constant "x" on line 2</code>.

      <p>However, objects are not frozen if declared as constants - you can still modify their properties. You can force all variables to be constants if you compile with the <code>-k</code> or <code>--const</code> flags.

      <h3 id="assignment-operators">Operators</h3>

      <p>Compound assignment:

      <p>(<code>?</code>, <code>||</code>, or <code>&&</code> can prefix any compound assign.)

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

x = 2    #=> 2
x += 2   #=> 4
x -= 1   #=> 3
x *= 3   #=> 9
x /= 3   #=> 3
x %= 3   #=> 0
x %%= 3  #=> 0
x &lt;?= -1 #=> -1
x >?= 2  #=> 2
x **= 2  #=> 4
x ^= 2   #=> 16

x ?= 10
x        #=> 16

x ||= 5  #=> 16
x &&= 5  #=> 5

x &&+= 3 #=> 8
x ?*= 2  #=> 16

xs = [1 2]
xs ++= [3]
xs #=> [1 2 3]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x, ref$, xs;
x = 2;
x += 2;
x -= 1;
x *= 3;
x /= 3;
x %= 3;
x = ((x) % (ref$ = 3) + ref$) % ref$;
x <= (ref$ = -1) || (x = ref$);
x >= 2 || (x = 2);
x = Math.pow(x, 2);
x = Math.pow(x, 2);

x == null && (x = 10);
x;

x || (x = 5);
x && (x = 5);

x && (x += 3);
x != null && (x *= 2);

xs = [1, 2];
xs = xs.concat([3]);
xs;
</pre>
        </div>
      </div>

      <p>Unary Assignment:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

y = \45
+  = y   #=> 45   (make into number)
!! = y   #=> true (make into boolean)
-~-~ = y #=> 3    (intcasting bicrement)
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var y;
y = '45';
y = +y;
y = !!y;
y = -~-~y;
</pre>
        </div>
      </div>

      <p>Assignment defaults - you can use <code>||</code>, <code>&&</code>, and <code>?</code>.

      <p>You can use <code>=</code> instead of <code>?</code> in function parameters.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x ? y = 10
y        #=> 10

f = (z = 7) -> z
f 9      #=> 9
f!       #=> 7
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var y, f;
(typeof x == 'undefined' || x === null) && (y = 10);
y;
f = function(z){
  z == null && (z = 7);
  return z;
};
f(9);
f();
</pre>
        </div>
      </div>

      <p>Soak assign - performs assign only if the right operand exists:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

age = 21
x? = age
x #=> 21


x? = years
x #=> 21
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var age, x;
age = 21;
if (age != null) {
  x = age;
}
x;
if (typeof years != 'undefined' && years !== null) {
  x = years;
}
x;
</pre>
        </div>
      </div>

      <h3 id="assignment-destructuring">Destructuring</h3>

      <p>Destructuring is a powerful way to extract values from variables. Rather than assigning to a simple variable, you can assign to data structures, which extract the values. For example:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[first, second] = [1, 2]
first  #=> 1
second #=> 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$, first, second;
ref$ = [1, 2], first = ref$[0], second = ref$[1];
first;
second;
</pre>
        </div>
      </div>

      <p>You can also use splats:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

[head, ...tail] = [1 to 5]
head #=> 1
tail #=> [2,3,4,5]



[first, ...middle, last] = [1 to 5]
first  #=> 1
middle #=> [2,3,4]
last   #=> 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$, head, tail, first, i$, middle, last, slice$ = [].slice;
ref$ = [1, 2, 3, 4, 5], head = ref$[0], tail = slice$.call(ref$, 1);
head;
tail;
ref$ = [1, 2, 3, 4, 5], first = ref$[0], middle = 1 < (i$ = ref$.length - 1) ? slice$.call(ref$, 1, i$) : (i$ = 1, []), last = ref$[i$];
first;
middle;
last;
</pre>
        </div>
      </div>

      <p>...and objects too!

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

{name, age} = {weight: 110, name: 'emma', age: 20}
name #=> 'emma'
age  #=> 20
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$, name, age;
ref$ = {
  weight: 110,
  name: 'emma',
  age: 20
}, name = ref$.name, age = ref$.age;
name;
age;
</pre>
        </div>
      </div>

      <p>You can also name the entity which you are destructuring using <code>:label</code>, as well as arbitrarily nest the destructuring.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[[x, ...xs]:list1, [y, ...ys]:list2] = [[1,2,3],[4,5,6]]
x     #=> 1
xs    #=> [2,3]
list1 #=> [1,2,3]
y     #=> 4
ys    #=> [5,6]
list2 #=> [4,5,6]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$, list1, x, xs, list2, y, ys, slice$ = [].slice;
ref$ = [[1, 2, 3], [4, 5, 6]], list1 = ref$[0], x = list1[0], xs = slice$.call(list1, 1), list2 = ref$[1], y = list2[0], ys = slice$.call(list2, 1);
x;
xs;
list1;
y;
ys;
list2;
</pre>
        </div>
      </div>

      <h3 id="assignment-substructuring">Substructuring</h3>

      <p>Easily set properties of lists and objects.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
mitch =
  age:    21
  height: 180cm
  pets:    [\dog, \goldfish]


phile = {}
phile{height, pets} = mitch
phile.height #=> 180
phile.pets   #=> ['dog', 'goldfish']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var mitch, phile;
mitch = {
  age: 21,
  height: 180,
  pets: ['dog', 'goldfish']
};
phile = {};
phile.height = mitch.height, phile.pets = mitch.pets;
phile.height;
phile.pets;
</pre>
        </div>
      </div>

    </div>


    <div id="property-access" class="section">
      <a name="property-access"></a>
      <h2>Property Access</h2>

      <p>The standard:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[1 2 3][1]     #=> 2
{a: 1, b: 2}.b #=> 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
[1, 2, 3][1];
({
  a: 1,
  b: 2
}).b;
</pre>
        </div>
      </div>

      <p> Dot Access - dot operators can accept many more things other than identifiers as their right operand, including numbers, strings, parentheses, brackets, and braces.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = "hello world": [4 [5 boom: 6]]
x.'hello world'.1.[0] #=> 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = {
  "hello world": [
    4, [
      5, {
        boom: 6
      }
    ]
  ]
};
x['hello world'][1][0];
</pre>
        </div>
      </div>

      <p>Accessignment using <code>.=</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
document.title .= to-upper-case! #=> LIVESCRIPT ...
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
document.title = document.title.toUpperCase();
</pre>
        </div>
      </div>

      <p>Array slice and splice:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

list = [1 2 3 4 5]
list[2, 4]         #=> [3,5]
list[1 to 3]       #=> [2,3,4]
list[1 til 3]      #=> [2,3]
list[1 til 4 by 2] #=> [2,4]
list[1 til 3] = [7 8]
list               #=> [1,7,8,4,5]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var list, ref$;
list = [1, 2, 3, 4, 5];
[list[2], list[4]];
[list[1], list[2], list[3]];
[list[1], list[2]];
[list[1], list[3]];
ref$ = [7, 8], list[1] = ref$[0], list[2] = ref$[1];
list;
</pre>
        </div>
      </div>

      <p>Object slice:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = one: 1, two: 2
obj{first: one, two} #=> {first: 1, two: 2}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj;
obj = {
  one: 1,
  two: 2
};
({
  first: obj.one,
  two: obj.two
});
</pre>
        </div>
      </div>

      <p>Length star <code>*</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
list = [1 2 3 4 5]
list[*] = 6
list        #=> [1,2,3,4,5,6]
list[*-1]   #=> 6
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var list;
list = [1, 2, 3, 4, 5];
list[list.length] = 6;
list;
list[list.length - 1];
</pre>
        </div>
      </div>

      <p> Semiautovivification <code>.{}</code>, <code>.[]</code> ensures that the property exists as an object or as an array.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = "hello world": [4 [5 boom: 6]]
x.[]'hello world'.1.{}1.boom #=> 6


x.[]arr.{}1.y = 9
x.arr.1.y #=> 9
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x, ref$;
x = {
  "hello world": [
    4, [
      5, {
        boom: 6
      }
    ]
  ]
};
((ref$ = (x['hello world'] || (x['hello world'] = []))[1])[1] || (ref$[1] = {})).boom;
((ref$ = x.arr || (x.arr = []))[1] || (ref$[1] = {})).y = 9;
x.arr[1].y;
</pre>
        </div>
      </div>

      <p>Binding access <code>.~</code> retrieves an object's method as bound to the object. With automatic dot insertion you can just use <code>~</code>.

      <p>Note that this is not the same as the <code>.bind</code> method on <code>Function</code>. With <code>.~</code>, the method is dynamically bound; <code>foo~bar</code> will refer to the value of <code>bar</code> on <code>foo</code> at the time the bound function is invoked, not at the time the binding access is made.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj =
  x: 5
  add: (y) -> @x + y

target =
  x: 600
  not-bound: obj.add
  bound: obj~add

target.not-bound 5 #=> 605
target.bound 5     #=> 10

# Binding access is dynamic:
obj.add = (y) -> @x + 1000*y
target.bound 5     #=> 5005
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj, target;
obj = {
  x: 5,
  add: function(y){
    return this.x + y;
  }
};
target = {
  x: 600,
  notBound: obj.add,
  bound: bind$(obj, 'add')
};
target.notBound(5);
target.bound(5);
obj.add = function(y){
  return this.x + 1000 * y;
};
target.bound(5);
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
</pre>
        </div>
      </div>



      <a name="cascades"></a>
      <h3 id="property-access-cascades">Cascades</h3>

      <p>A cascade always evaluates to the item being accessed, and not to the return value of the accessing operations.

      <p>Beautiful chaining:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

a = [2 7 1 8]
  ..push 3
  ..shift!
  ..sort!
a #=> [1,3,7,8]

document.query-selector \h1
  ..style
    ..color = \red
    ..font-size = \large
  ..inner-HTML = 'LIVESCRIPT!'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x$, a, y$, z$;
x$ = a = [2, 7, 1, 8];
x$.push(3);
x$.shift();
x$.sort();
a;
y$ = document.querySelector('h1');
z$ = y$.style;
z$.color = 'red';
z$.fontSize = 'large';
y$.innerHTML = 'LIVESCRIPT!';
</pre>
        </div>
      </div>

      <p>Cascades are callable, and can include arbitrary code.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
console.log
  x = 1
  y = 2
  .. x, y
# prints `1 2` to the console
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x$, x, y;
x$ = console.log;
x = 1;
y = 2;
x$(x, y);
</pre>
        </div>
      </div>

      <p>You can use <code>with</code> to specify the part of the preceding expression to cascade.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = with {a: 1, b: 2}
  ..a = 7
  ..b += 9
x #=>  {a: 7, b: 11}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x, x$;
x = (x$ = {
  a: 1,
  b: 2
}, x$.a = 7, x$.b += 9, x$);
x;
</pre>
        </div>
      </div>

    </div>

    <div id="exceptions" class="section">
      <a name="exceptions"></a>
      <h2>Exceptions</h2>

      <p>You can throw exceptions with the aptly named <code>throw</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
throw new Error 'an error has occurred!'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
throw new Error('an error has occurred!');
</pre>
        </div>
      </div>

      <p>You can catch and deal with exceptions with the <code>try</code> <code>catch</code> <code>finally</code> block. Both <code>catch</code> and <code>finally</code> are optional.

      <p>The <code>try</code> block is attempted. If an exception occurs, the <code>catch</code> block is executed. It is supplied with the exception object. If you do not specify the name of this variable it will default to <code>e</code>. Unlike JavaScript, the exception variable is scoped to the nearest function, not the <code>catch</code> block. You can destructure the exception object if you wish.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
try
  ...

try
  ...
catch
  2 + 2
e.message

x = try
  ...
catch {message}
  message

x #=> unimplemented
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var e, x, message;
try {
  throw Error('unimplemented');
} catch (e$) {}
try {
  throw Error('unimplemented');
} catch (e$) {
  e = e$;
  2 + 2;
}
e.message;
x = (function(){
  try {
    throw Error('unimplemented');
  } catch (e$) {
    message = e$.message;
    return message;
  }
}());
x;
</pre>
        </div>
      </div>

      <p>The <code>finally</code> block is executed after the <code>try</code> or <code>catch</code>, regardless of what has happened.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
try
  ...
catch
  handle-exception e
finally
  do-something!

try
  ...
finally
  do-something!
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var e;
try {
  throw Error('unimplemented');
} catch (e$) {
  e = e$;
  handleException(e);
} finally {
  doSomething();
}
try {
  throw Error('unimplemented');
} finally {
  doSomething();
}
</pre>
        </div>
      </div>

    </div>

    <div id="oop" class="section">
      <a name="oop"></a>
      <h2>Object Oriented Programming</h2>

      <p>Classes are simple sugar for the definition of constructor functions and the setting of their prototype.

      <p>The constructor function is defined as function literal at the top level of the class definition.

      <p>Properties of its prototype are defined by object literals at the top level.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
class A
  (num) ->
    @x = num
  property: 1
  method: (y) ->
    @x + @property + y

a = new A 3
a.x        #=> 3
a.property #=> 1
a.method 6 #=> 10
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var A, a;
A = (function(){
  A.displayName = 'A';
  var prototype = A.prototype, constructor = A;
  function A(num){
    this.x = num;
  }
  A.prototype.property = 1;
  A.prototype.method = function(y){
    return this.x + this.property + y;
  };
  return A;
}());
a = new A(3);
a.x;
a.property;
a.method(6);
</pre>
        </div>
      </div>

      <p>Static properties (properties attached to the constructor) are defined by adding properties to <code>this</code> at the top level. These properties can be accessed in methods by accessing <code>constructor</code> (shorthand <code>@@</code>).

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
class A
  @static-prop = 10
  get-static: ->
    @@static-prop + 2

A.static-prop #=> 10
a = new A
a.get-static! #=> 12
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var A, a;
A = (function(){
  A.displayName = 'A';
  var prototype = A.prototype, constructor = A;
  A.staticProp = 10;
  A.prototype.getStatic = function(){
    return constructor.staticProp + 2;
  };
  function A(){}
  return A;
}());
A.staticProp;
a = new A;
a.getStatic();
</pre>
        </div>
      </div>

      <p>Private static properties are defined as just regular variables in the class body. (note: private instance properties are not possible in JavaScript, and thus, LiveScript.)

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
class A
  secret = 10

  get-secret: ->
    secret

a = new A
a.get-secret! #=> 10
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var A, a;
A = (function(){
  A.displayName = 'A';
  var secret, prototype = A.prototype, constructor = A;
  secret = 10;
  A.prototype.getSecret = function(){
    return secret;
  };
  function A(){}
  return A;
}());
a = new A;
a.getSecret();
</pre>
        </div>
      </div>

      <p>You can define bound methods (using <code>~></code>, which have their definition of <code>this</code> bound to the instance.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
class A
  x: 10
  bound-func: (x) ~>
    @x
  reg-func: (x) ->
    @x

a = new A
obj =
  x: 1
  bound: a.bound-func
  reg: a.reg-func

obj.bound! #=> 10
obj.reg!   #=> 1
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var A, a, obj;
A = (function(){
  A.displayName = 'A';
  var prototype = A.prototype, constructor = A;
  A.prototype.x = 10;
  A.prototype.boundFunc = function(x){
    return this.x;
  };
  A.prototype.regFunc = function(x){
    return this.x;
  };
  function A(){
    this.boundFunc = bind$(this, 'boundFunc', prototype);
  }
  return A;
}());
a = new A;
obj = {
  x: 1,
  bound: a.boundFunc,
  reg: a.regFunc
};
obj.bound();
obj.reg();
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
</pre>
        </div>
      </div>

      <p>You can easily set properties in constructor functions and in methods using the object setting parameter shorthand.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
class A
  (@x) ->

  f: (@y) ->
    @x + @y

a = new A 2
a.x   #=> 2
a.f 3 #=> 5
a.y   #=> 3
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var A, a;
A = (function(){
  A.displayName = 'A';
  var prototype = A.prototype, constructor = A;
  function A(x){
    this.x = x;
  }
  A.prototype.f = function(y){
    this.y = y;
    return this.x + this.y;
  };
  return A;
}());
a = new A(2);
a.x;
a.f(3);
a.y;
</pre>
        </div>
      </div>

      <p>If you define the constructor as a bound function <code>~></code>, you don't need to use <code>new</code> when making a new instance.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
class A
  (@x) ~>

a = A 4
a.x #=> 4
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var A, a;
A = (function(){
  A.displayName = 'A';
  var prototype = A.prototype, constructor = A;
  function A(x){
    var this$ = this instanceof ctor$ ? this : new ctor$;
    this$.x = x;
    return this$;
  } function ctor$(){} ctor$.prototype = prototype;
  return A;
}());
a = A(4);
a.x;
</pre>
        </div>
      </div>

      <p>For higher level libraries and frameworks, there is the ability to define the constructor as an external function, by setting the property <code>constructor$$</code>. This is not recommended for regular coding.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
f = (@x) ->

class A
  constructor$$: f

a = new A 5
a.x #=> 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var f, A, a;
f = function(x){
  this.x = x;
};
A = (function(){
  A.displayName = 'A';
  var constructor$$, prototype = A.prototype, constructor = A;
  function A(){
    return constructor$$.apply(this, arguments);
  }
  constructor$$ = f;
  return A;
}());
a = new A(5);
a.x;
</pre>
        </div>
      </div>

      <p>You can inherit with <code>extends</code>

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
class A
  ->
    @x = 1
  @static-prop = 8
  method: ->
    @x + 2

class B extends A
  ->
    @x = 10

B.static-prop #=> 8
b = new B
b.x       #=> 10
b.method! #=> 12
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var A, B, b;
A = (function(){
  A.displayName = 'A';
  var prototype = A.prototype, constructor = A;
  function A(){
    this.x = 1;
  }
  A.staticProp = 8;
  A.prototype.method = function(){
    return this.x + 2;
  };
  return A;
}());
B = (function(superclass){
  var prototype = extend$((import$(B, superclass).displayName = 'B', B), superclass).prototype, constructor = B;
  function B(){
    this.x = 10;
  }
  return B;
}(A));
B.staticProp;
b = new B;
b.x;
b.method();
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
</pre>
        </div>
      </div>

      <p>This is especially useful with <code>super</code>. If bare, <code>super</code> is a reference to the appropriate function. If you want to call it with all arguments, use <code>super ...</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
class A
  ->
    @x = 1
  method: (num) ->
    @x + num

class B extends A
  ->
    @y = 2
    super!

  method: (num) ->
    @y + super ...

b = new B
b.y #=> 2
b.method 10 #=> 13
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var A, B, b;
A = (function(){
  A.displayName = 'A';
  var prototype = A.prototype, constructor = A;
  function A(){
    this.x = 1;
  }
  A.prototype.method = function(num){
    return this.x + num;
  };
  return A;
}());
B = (function(superclass){
  var prototype = extend$((import$(B, superclass).displayName = 'B', B), superclass).prototype, constructor = B;
  function B(){
    this.y = 2;
    B.superclass.call(this);
  }
  B.prototype.method = function(num){
    return this.y + superclass.prototype.method.apply(this, arguments);
  };
  return B;
}(A));
b = new B;
b.y;
b.method(10);
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
</pre>
        </div>
      </div>

      <p>You can use mixins through <code>implements</code>. You can only inherit from one class, but can mixin as many objects as you like. Remember, if you want to implement a class, not just a simple object, you must implement the class's prototype.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
Renameable =
  set-name: (@name) ->
  get-name: -> @name ? @id

class A implements Renameable
  ->
    @id = Math.random! * 1000

a = new A
a.get-name! #=> some random number
a.set-name 'moo'
a.get-name! #=> 'moo'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var Renameable, A, a;
Renameable = {
  setName: function(name){
    this.name = name;
  },
  getName: function(){
    var ref$;
    return (ref$ = this.name) != null
      ? ref$
      : this.id;
  }
};
A = (function(){
  A.displayName = 'A';
  var prototype = A.prototype, constructor = A;
  importAll$(prototype, arguments[0]);
  function A(){
    this.id = Math.random() * 1000;
  }
  return A;
}(Renameable));
a = new A;
a.getName();
a.setName('moo');
a.getName();
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
</pre>
        </div>
      </div>

      <p>To modify the prototype, you can use the shorthand <code>::</code>, and you can use the <code>::=</code> operator if you wish to modify several properties.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
class A
  prop: 10
  f: ->
    @prop

a = new A
b = new A
a.f! #=> 10

A::prop = 6
a.f! #=> 6
b.f! #=> 6

A ::=
  prop: 5
  f: ->
    @prop + 4
a.f! #=> 9
b.f! #=> 9
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var A, a, b, ref$;
A = (function(){
  A.displayName = 'A';
  var prototype = A.prototype, constructor = A;
  A.prototype.prop = 10;
  A.prototype.f = function(){
    return this.prop;
  };
  function A(){}
  return A;
}());
a = new A;
b = new A;
a.f();
A.prototype.prop = 6;
a.f();
b.f();
ref$ = A.prototype;
ref$.prop = 5;
ref$.f = function(){
  return this.prop + 4;
};
a.f();
b.f();
</pre>
        </div>
      </div>

      <p>If you don't wish to support older browsers, and desire the use of <code>Object.defineProperty</code>, you can use the following shorthand:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
class Box
  dimensions:~
    -> @d
    ([width, height]) -> @d = "#{width}x#height"

b = new Box
b.dimensions = [10 5]
b.dimensions #=> '10x5'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var Box, b;
Box = (function(){
  Box.displayName = 'Box';
  var prototype = Box.prototype, constructor = Box;
  Object.defineProperty(Box.prototype, 'dimensions', {
    get: function(){
      return this.d;
    },
    set: function(arg$){
      var width, height;
      width = arg$[0], height = arg$[1];
      this.d = width + "x" + height;
    },
    configurable: true,
    enumerable: true
  });
  function Box(){}
  return Box;
}());
b = new Box;
b.dimensions = [10, 5];
b.dimensions;
</pre>
        </div>
      </div>

    </div>
    <hr>
    <div class="section" id="coffee-to-ls">
      <a name="coffee-to-ls"></a>
      <h2>CoffeeScript to LiveScript Conversion Guide</h2>
      <ul>
        <li>Change all your fat arrows <code>=></code> to wavy arrows <code>~></code>
        <li>Change all your block comments <code>### ###</code> to <code>/* */</code>
        <li>Change all <code>undefined</code> to <code>void</code>
        <li>Change any range syntax creating lists from <code>[x..y]</code> to <code>[x to y]</code> and change <code>[x...y]</code> to <code>[x til y]</code>. If your range goes downwards, ie. from a larger number to a smaller number, and it is not obvious (the from and to are not literals), then you must add <code>by -1</code>, eg. <code>[x to -3 by -1]</code>
        <li>Similarly, change any range syntax in for loops from <code>for i in [x..y]</code> to <code>for i from x to y</code> and change <code>for i in [x...y]</code> to <code>for i from x til y</code>
        <li>Change any list comprehensions from <code>(x for x in list)</code> to <code>[x for x in list]</code>. Any postfix loops which you do not want returning a list, change to not postfixed, eg. change <code>increase x for x in list</code> to <code>for x in list then increase x</code>. You can shave characters if you wish by using the alias to <code>then</code>, the fat arrow <code>=></code>
        <li>Change any number literals starting with a dot, eg. <code>.5</code> to start with a zero <code>0.5</code>
        <li>Change any regular expression literals from <code>/// ///</code> to <code>// //</code>
        <li>Change any splats you are using from <code>(args...) -></code> to be prefixed like <code>(...args) -></code>
        <li>Remove the parentheses from function definitions with no parameters, <code>() -></code> simply becomes <code>-></code> - this is because <code>()</code> is always a call.
        <li>Change your constructor functions in your classes from being defined as
<pre>
class Item
  constructor: ->
</pre> to simply being functions at the top level of your class body, eg.
<pre>
class Item
  ->
</pre>
        If your constructor is an external function, define it with the special property <code>constructor$$</code>.
        <li>Change any calls to super from <code>super</code> to <code>super ...</code> - this is because <code>super</code> is a direct reference to the parent function rather than a call itself.
        <li>Change any bitwise operators to themselves surrounded by dots. Eg. <code>&amp;</code> is now <code>.&amp;.</code> and <code>&gt;&gt;</code> is now <code>.&gt;&gt;.</code>
        <li>If you are modifying variables in upper scopes at any time, eg.
<pre>
x = 10
do ->
  x = 5
</pre> you must use <code>:=</code> instead of just <code>=</code> as that will declare a new (shadowing) variable in LiveScript. Thus, the above code would need to be
<pre>
x = 10
do ->
  x := 5
</pre> if you wanted to modify <code>x</code>
      <li>If you are using nested list comprehensions (eg. <code>(x + y for x in [1, 2] for y in [3, 4])</code>, you will need to change this to a regular (non-postfixed) nested loop, as instead of the result being a lists within a list as in CoffeScript (the result of the example would be <code>[[4,5],[5,6]]</code>), the result is flattened (the result of the example in LiveScript would be <code>[4,5,5,6]</code>). Eg. change
<pre>
result = (x + y for x in [1, 2] for y in [3, 4])
</pre>
      to
<pre>
result = for x in [1, 2]
  for y in [3, 4]
    x + y
</pre>
      in order to get the non-flattened result.
      <li>Change the name of any of your variables named <code>it</code>, <code>that</code>, <code>fallthrough</code>, or <code>otherwise</code>. Those are terrible names for variables so you should change them anyway. This technically isn't required in all cases, but will be less confusing if you do so in all cases. <code>it</code> is used as the implicit argument of functions defined with no parameters, eg. <code>reverse = -> it.reverse!</code>. <code>that</code> refers to the value of the condition, for instance <code>that + 2 if (x + 10)/(y - 18)</code>, <code>that == (x + 10)/(y-18)</code>. <code>fallthrough</code>, if used at the end of a case block makes that block fallthrough to the next case. <code>otherwise</code>, if used directly after case, turns that case into default.
      <li>If you have any multiline strings non triple quoted strings (using <code>"string"</code> or <code>'string'</code>), eg.
<pre>
text = "hi 
        there"
</pre> you will have to change them as in CoffeeScript this would be <code>"hi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;there"</code> while LiveScript ignores indentation after newlines so it would be <code>"hi there"</code>
      <li><code>and</code>, <code>or</code> and spaced <code>.</code> and <code>?.</code> close implicit calls, so you will have to change any code involving those where you have depended on CoffeeScript to not close the call. Eg. <code>f a .g b or h c</code> would be <code>f(a.g(b || h(c)))</code> in CoffeeScript and <code>f(a).g(b) || h(c)</code> in LiveScript. You can use <code>||</code> instead of <code>or</code> and <code>&amp;&amp;</code> instead of <code>and</code> as those versions do not close implicit calls.
      <li>Change any <code>do</code>s special casing function literals to using <code>let</code>. Eg. in CoffeeScript <code>do ($ = jQuery) -> $</code> change to
<pre>
let $ = jQuery
  $
</pre>
      <li>Change any implicit calls against blocks starting with an implicit objects to use <code>do</code>. Eg. change
<pre>
f
  a: b
</pre> into
<pre>
f do
  a: b
</pre>
      <li>Change any JavaScript code literals, eg. <code>`js code here`</code> to <code>``js code here``</code>
      <li>Change any dually spaced property access, eg. <code>x . y</code> to be either spaced on only one side or not at all. A dually spaced dot is now used to compose functions.
      <li>Change any non spaced identifier subtraction, eg. <code>a-b</code> to spaced <code>a - b</code>. <code>a-1</code> and <code>1-b</code> are still fine. This is because <code>a-b</code> is a valid identifier in LiveScript, equivalent to its camel case, <code>aB</code>.
      </ul>
    </div>
    <div id="changelog" class="section">
      <a name="changelog"></a>
      <h2>Changelog</h2>
      <h3>1.6.0</h3>
      <h4>Breaking changes</h4>
      <ul>
        <li><code>{a, b, ...c} = a: 1 b: 2 c: 3 x: 4</code> now sets <code>c = c: 3 x: 4</code> instead of <code>c = {} &lt;&lt;&lt; 3</code>. (See <a href="https://github.com/gkz/LiveScript/issues/941">#941</a>.)
        <li><code>o{k: a.complex.expression}</code>, <code>{a xor b}</code>, <code>foo.bar = [a, b]:c</code>, <code>{...x ? y} = z</code> are all now errors. (See <a href="https://github.com/gkz/LiveScript/pull/958">#958</a> for rationales.)
        <li><code>a ?+= b</code> now means <code>a? &amp;&amp; a += b</code> instead of <code>a? || a += b</code> (See <a href="https://github.com/gkz/LiveScript/pull/969">#969</a>.)
      </ul>
      <h4>Features</h4>
      <ul>
        <li>Added <code>async</code> functions and generators (<a href="https://github.com/gkz/LiveScript/pull/978">#978</a>, <a href="https://github.com/gkz/LiveScript/pull/1063">#1063</a>)
        <li>Added support for more complex object shorthand, such as <code>{a.b!c?key}</code> (<a href="https://github.com/gkz/LiveScript/pull/958">#958</a>)
        <li>Support ES6 iterators in splats (<a href="https://github.com/gkz/LiveScript/issues/963">#963</a>)
        <li>In Node, added a <code>process.argv.lsc</code> property for getting interpreted script arguments reliably (<a href="https://github.com/gkz/LiveScript/pull/1014">#1014</a>)
      </ul>
      <h4>Fixes</h4>
      <ul>
        <li>Anaphorization bugs (<a href="https://github.com/gkz/LiveScript/issues/743">#743</a>, <a href="https://github.com/gkz/LiveScript/pull/957">#957</a>)
        <li>Report error for labeled and curried functions (<a href="https://github.com/gkz/LiveScript/issues/751">#751</a>)
        <li>Implicit <code>it</code> parameter not defined when used in object shorthand (<a href="https://github.com/gkz/LiveScript/issues/899">#899</a>)
        <li>Forking bug (<a href="https://github.com/gkz/LiveScript/issues/916">#916</a>)
        <li><code>for in</code> lexing bug (<a href="https://github.com/gkz/LiveScript/issues/923">#923</a>)
        <li><code>match</code> bug (<a href="https://github.com/gkz/LiveScript/issues/926">#926</a>)
        <li>REPL bugs (<a href="https://github.com/gkz/LiveScript/pull/928">#928</a>, <a href="https://github.com/gkz/LiveScript/pull/929">#929</a>)
        <li>Binding access and object slices (<a href="https://github.com/gkz/LiveScript/issues/930">#930</a>)
        <li>Reporting source file line numbers (<a href="https://github.com/gkz/LiveScript/issues/953">#953</a>)
        <li>Various bugs with object slicing (<a href="https://github.com/gkz/LiveScript/pull/958">#958</a>)
        <li>No more unreachable <code>break</code>s in compiled <code>switch</code> code (<a href="https://github.com/gkz/LiveScript/issues/931">#931</a>)
        <li>Fixes for <code>-ce</code>, <code>-aj</code> combinations of options (<a href="https://github.com/gkz/LiveScript/issues/993">#993</a>)
        <li>Loop variable in <code>for let ... when</code> guard (<a href="https://github.com/gkz/LiveScript/issues/992">#992</a>)
        <li>Script argument regression (<a href="https://github.com/gkz/LiveScript/issues/1013">#1013</a>)
        <li><code>a[]b ++ c</code>, <code>a[]b ++= c</code> (<a href="https://github.com/gkz/LiveScript/issues/542">#542</a>, <a href="https://github.com/gkz/LiveScript/issues/1028">#1028</a>)
        <li>Show errors when running with <code>-w</code> option (<a href="https://github.com/gkz/LiveScript/issues/1015">#1015</a>)
        <li><code>for [] ... else</code> (<a href="https://github.com/gkz/LiveScript/issues/1035">#1035</a>)
        <li>Move shebang lines above header comment (<a href="https://github.com/gkz/LiveScript/pull/1032">#1032</a>)
        <li>Empty words literal <code>&lt;[ ]&gt;</code> (<a href="https://github.com/gkz/LiveScript/issues/739">#739</a>)
        <li><code>for arr case .. in</code> (<a href="https://github.com/gkz/LiveScript/issues/1039">#1039</a>)
        <li>Fix for <code>_.member</code> in <code>match</code> (<a href="https://github.com/gkz/LiveScript/issues/1025">#1025</a>)
        <li><code>yield</code> and <code>await</code> inside various <code>let</code> blocks (<a href="https://github.com/gkz/LiveScript/issues/1019">#1019</a>, <a href="https://github.com/gkz/LiveScript/issues/1021">#1021</a>, <a href="https://github.com/gkz/LiveScript/issues/1023">#1023</a>)
        <li>REPL mode on Windows (<a href="https://github.com/gkz/LiveScript/issues/897">#897</a>)
      </ul>
      <h3>1.5.0</h3>
      <h4>Breaking changes</h4>
      <ul>
        <li>The LHS of <code>[a, ..., b, c, d] = [1 2 3]</code> now behaves the same as <code>[a, ...m, b, c, d]</code>. (See <a href="https://github.com/gkz/LiveScript/issues/858">#858</a>.)
        <li>Unary operator spreading now requires a <code>...</code> before the list to spread over. (See <a href="https://github.com/gkz/LiveScript/pull/863">#863</a>.)
      </ul>
      <h4>Features</h4>
      <ul>
        <li>REPL gains a saved history file and autocompletion for globals (<a href="https://github.com/gkz/LiveScript/pull/695">#695</a>)
        <li>Embedded source maps get generated when requiring a <code>.ls</code> file (<a href="https://github.com/gkz/LiveScript/pull/786">#786</a>)
        <li><code>.json.ls</code> files are handled appropriately when <code>require</code>d (<a href="https://github.com/gkz/LiveScript/pull/884">#884</a>)
        <li>Class members are now assigned using the <code>ClassName.prototype.memberName =</code> pattern that permits JS optimization tools to identify them as such (<a href="https://github.com/gkz/LiveScript/issues/853">#853</a>)
        <li>Added support for <code>[for x by y]</code> (<a href="https://github.com/gkz/LiveScript/pull/837">#837</a>), <code>[.. for from i to j by k]</code> (<a href="https://github.com/gkz/LiveScript/pull/859">#859</a>)
      </ul>
      <h4>Fixes</h4>
      <ul>
        <li>Grouping of logical expressions in match cases (<a href="https://github.com/gkz/LiveScript/issues/584">#584</a>)
        <li>Bound binary operators (<a href="https://github.com/gkz/LiveScript/issues/634">#634</a>)
        <li>Yield inside for-let (<a href="https://github.com/gkz/LiveScript/issues/749">#749</a>)
        <li>Yield is callable (<a href="https://github.com/gkz/LiveScript/pull/823">#823</a>)
        <li>Error evaluating <code>.ls</code> files with source maps on (<a href="https://github.com/gkz/LiveScript/issues/830">#830</a>)
        <li>Windows path bug (<a href="https://github.com/gkz/LiveScript/pull/835">#835</a>)
        <li>Loop edge cases you are very unlikely to encounter (<a href="https://github.com/gkz/LiveScript/pull/841">#841</a>)
        <li>Heregexes (<a href="https://github.com/gkz/LiveScript/issues/844">#844</a>)
        <li>Autovivification with slices (<a href="https://github.com/gkz/LiveScript/issues/847">#847</a>)
        <li>Parsing error with nested comprehensions (<a href="https://github.com/gkz/LiveScript/issues/854">#854</a>)
        <li>Performance improvement for splat args (<a href="https://github.com/gkz/LiveScript/issues/857">#857</a>)
      </ul>
      <h3>1.4.0</h3>
      <ul>
          <li>Changed npm name to <code>livescript</code> as npm no longer allows publishing updates to packages with upper-case letters
          <li>Added source map support using the <code>-m,--map</code> flag
          <li>Added command line JSON processing with JSON and the <code>-e,--eval</code> flag. Inbound JSON is bound to <code>this</code>
          <li>Fixed a regression from previous versions that did not allow for flag style positionals after a first positional (eg. <code>lsc app.ls --flag</code> caused an error)
          <li>Generators are no longer auto-hushed, moving behavior in line with what was expected
          <li>Allow backcall generators, eg. <code>*&lt;-</code>
          <li>Added back <code>-k</code> shorthand for the <code>--const</code> flag
          <li>Made it possible to use the <code>by</code> keyword in slices, eg. <code>list[1 til 5 by 2]</code>
          <li>Object comprehension bug fixes
          <li>Fixed various backcall issues
          <li>Fixed composition operator spacing issues
          <li>Yield bug fixes - including allowing it to be used with no operand
          <li>Replaced deprecated usage of <code>customFds</code> in <code>child_process.spawn</code>
          <li>Added CLI tests
          <li>Many other bug fixes
      </ul>
      <h3>1.3.1</h3>
      <ul>
          <li>Fixed bug with calling lsc file.ls with arguments (<a href="https://github.com/gkz/LiveScript/issues/569">#569</a>)
          <li>Some object comprehension fixes
          <li>Fixed prededence of <code>return</code> and <code>throw</code> in respect to pipes.
          <li>Added back the <code>--require</code> option missing in 1.3.0, this option is great when starting the REPL. Also made modules accesible in a similar manner to <code>require!</code>. Eg. <code>--require './boom.js'</code> requires the file and allows you to access it with <code>boom</code>.
          <li>Fixed bug with <code>require!</code> compilation - an error is now thrown when it should be
      </ul>
      <h3>1.3.0</h3>
      <ul>
        <li>Added support for generators and yield
        <li>Improved <code>require!</code>, more like regular destructering now
        <li>Fixed pipe and assign precedence
        <li>Removed auto infused IIFE, just use <code>for let</code> now
        <li>Browser versions changed to use browserify
        <li>Option parsing uses <a href="https://github.com/gkz/optionator">Optionator</a>
        <li>Added <code>--no-header</code> option, to remove "Generated by..." header
        <li>Removed <code>livescript</code> from bin, just use <code>lsc</code>
        <li>Removed Slake and Slakefiles
        <li>Can now use <code>that</code> in the default case of a switch statement
      </ul>
      <h3>1.2.0</h3>
      <ul>
        <li>Bug fixes
        <li>Better compilation of partially applied functions, eg. <code>10 |> f _, 2</code> is the same as <code>f 10, 2</code> when compiled
        <li>Better compilation of compose - no longer using helper function
        <li>Using prelude.ls version 1.0.3
        <li><code>--prelude/-d</code> flag only used for repl now, does not add prelude.ls include when compiling
        <li>Generated header is added to the top of compiled files, specifying which version of LiveScript the JS was compiled with
        <li>Removed single line cascade due to lack of usefulness and ambiguity with other syntax
        <li>Removed deprecated features - inexistance op <code>!?</code>, <code>+++</code>, <code>where</code>, <code>undefined</code> (alias to void), short function syntax
        <li>To hush functions (stop them from automatically adding a return statement), you can now always add a <code>!</code> in front of the arrow. Eg. <code>(x) !-&gt; x + x</code>
        <li>Autocompile <code>.json.ls</code> to <code>.json</code>
        <li>Added <code>for let</code>
      </ul>
      <h3>1.1.1</h3>
      <ul>
        <li>Fix/close <a href="https://github.com/gkz/LiveScript/issues/194">#194</a>, <a href="https://github.com/gkz/LiveScript/issues/206">#206</a>, <a href="https://github.com/gkz/LiveScript/issues/150">#150</a>, <a href="https://github.com/gkz/LiveScript/issues/217">#217</a>, <a href="https://github.com/gkz/LiveScript/issues/236">#236</a>, <a href="https://github.com/gkz/LiveScript/issues/238">#238</a>, <a href="https://github.com/gkz/LiveScript/issues/151">#151</a>, <a href="https://github.com/gkz/LiveScript/issues/215">#215</a>, <a href="https://github.com/gkz/LiveScript/issues/213">#213</a>, <a href="https://github.com/gkz/LiveScript/issues/237">#237</a>, <a href="https://github.com/gkz/LiveScript/issues/232">#232</a>, <a href="https://github.com/gkz/LiveScript/issues/161">#161</a>, <a href="https://github.com/gkz/LiveScript/issues/241">#241</a>
        <li>Added <code>++</code> as array concat operator, to replace <code>+++</code> (which is now deprecated).
        <li>Added <code>++=</code> operator to complement the above.
        <li>Added quick map in comprehensions, using cascade reference. For example, instead of doing <code>[x + 1 for x in xs]</code> you can now write <code>[.. + 1 for xs]</code>, <code>..</code> being the implicit value. See <a href="#cascade-implicit-map">section for more details</a>.
        <li>Added the ability to have unary operators in parameters. Eg. <code>(!x) -&gt; ...</code> desugars to <code>(x) -&gt; x = !x; ...</code>. You can use this to cast parameters to either booleans <code>(!!x) -&gt;</code> or numbers <code>(+x) -&gt;</code>. You can also clone objects so that you don't modify the original: <code>(^^x) -&gt;</code>. See <a href="#params-unary-ops">section for more</a>.
        <li>Bound curried functions <code>~~&gt;</code> actually work now, and partially applied functions, eg. <code>f _, 1</code> are bound at the first time they are partially applied.
        <li>Deprecated the <code>+++</code> array concatenation operator, please use <code>++</code> instead. <code>+++</code> will be removed in the next major LiveScript release.
        <li>Deprecated the <code>where</code> statement. Please use <code>let</code> and/or local variables instead. <code>where</code> will be removed in the next major LiveScript release.
        <li>Deprecated <code>undefined</code> as an alias to <code>void</code>. Please use <code>void</code> instead. <code>undefined</code> will be removed in the next major LiveScript release.
        <li>Deprecated the <code>!?</code> inexistence operator. When used postfix, please negate the existence operator instead, eg. change <code>x!?</code> to <code>not x?</code>. If used as a logic operator, please use an if statement and the existence operator instead, eg. change <code>x !? f!</code> to <code>f! if x?</code>. <code>!?</code> will be removed in the next major LiveScript release.
        <li>Please also remember that the short function syntax is also currently deprecated and will be removed in the next major LiveScript release. Eg. <code>f(x) = ...</code> type functions - please use the long arrow to defined curried functions instead, eg. <code>f = (x) --> ...</code>.
      </ul>
      <h3>1.1.0</h3>
      <ul>
        <li><code>lsc</code> is now an alias for the <code>livescript</code> command, as <code>livescript</code> is quite long. Think "LiveScript Compiler".
        <li>Added single line cascades. Eg. <code>[1 2 3]..push 3 ..shift!..sort!</code>
        <li>Cascades are callable, eg.
<pre>
(+)
  .. 2 3
</pre>
        <li>Removed previous usage of <code>with</code>, use <code>let @ = x</code> instead.
        <li><code>with</code> can be used to specify the part of the expression to cascade. Eg.
<pre>
x = with [1 2 3]
  ..push 3
</pre>
        <li>An empty catch <code>try x catch</code> returns its catchee.
        <li><code>by -1</code> is not required in ranges where it is obvious.
        <li>Added shorthand for <code>constructor</code>: <code>@@</code>
        <li>Changed semiautovivification from using <code>x@y</code> and <code>x@@y</code> to using <code>x{}y</code> and <code>x[]y</code>
        <li>Nested loops (not comprehensions) no longer return flattened results when used as an expression.
<pre>
res = for x to 2
  for y to 3
    "#x#y"
res #=> [ ['00', '01', '02', '03'], ['10', '11', '12', '13'], ['20', '21', '22', '23'] ]
</pre>
        Use comprehensions instead if you want a flattened result. To make things easier, comprehensions can now be multiline.
<pre>
["#x#y" for x to 2
              for y to 3]
#=> ['00', '01', '02', '03', '10', '11', '12', '13', '20', '21', '22', '23']
</pre>
        <li>Fixed bug where comprehensions inside comprehensions were returning flattened results, eg.
<pre>
[[x + y for x to 2] for y to 3]
#=> [ [0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5] ]
</pre>
        now returns an array of arrays as expected. If you were relying on this behavior, simply remove the brackets of the inner comprehension to make it a nested comprehension.
        <li>Added <code>require!</code>, which takes either a object, array, or string literal and creates a series of require statements. See <a href="#require">documentation</a>.
        <li>Added the ability to call <code>super</code> outside of the class body, when adding static or instance methods to a class. Eg.
<pre>
class A extends B
A::meth -> super ...
A.stat -> super ...
</pre>
        <li>The 'from' number in a range can be omitted, to be consistent with for loops. If the number is omitted, it is assumed to be <code>0</code>.
<pre>
[to 3]  #=> [0, 1, 2, 3]
[til 3] #=> [0, 1, 2]
</pre>
        <li>You can now define an external constructor in a class. This is mostly for compatibility with CoffeeScript, and for higher level libraries and frameworks. It is defined with <code>constructor$$:</code>. eg.
<pre>
class A
  constructor$$: some-external-func
</pre>
        <li>You can now splat <code>new</code> eg. <code>new A ...a</code>
        <li>Class bodies are now executable. You can do things like:
<pre>
class A
  if condition
    method: -> ...
  else
    method2: -> ...

  for key of obj
    (key): -> ...
</pre>
        <li>If you <code>do</code> a named function, and the <code>do</code> statement is not being used as an expression, the function retains its hoisting. Eg.
<pre>
f 1 #=> 1
do function f x
  x
</pre>
        compiles to
<pre>
f(1);
function f(x){
  return x;
} f();
</pre>
        <li>You can now omit all variables from for loop definitions over a range. Eg.
<pre>
[1 for til 3] #=> [1, 1, 1]
for til 3 then f!
[f! for from 1 to 5]
</pre>
        <li>Added <code>delete!</code> statement, like <code>delete</code> in JavaScript. This is slightly different from <code>delete</code> in LiveScript, which returns the deleted item if used as an expression.
<pre>
delete! x.y
</pre>
        <li>Added back JavaScript code literals, for the sole purpose of allowing CoffeeScript to LiveScript compilation compatibility. Not to be used in regular code. JS literals are denoted with two backticks. <code>``js code``</code>
        <li><code>for</code> loop and comprehension indices are immutable. Use a <code>while</code> loop if you want to mutate indices. Also, the last value of the index is the last value it has in the loop.
        <li>You can destructure the <code>catch</code> parameter.
        <li><code>in</code> works on sparse arrays for compatibility with CoffeeScript.
        <li>Bug fixes.
      </ul>
      <h3>1.0.1</h3>
      <ul>
        <li>Bug fixes.
      </ul>
      <h3>1.0.0</h3>
      <ul>
        <li>Nicer compilation for the compose op
        <li>The <code>--prelude</code>/<code>-d</code> flags work for the repl
        <li>New func syntax eg. <code>f(x) = x</code> now uses <code>~</code> for bound funcs, liked named funcs, eg. <code>~f(x) = x</code>
        <li>Removed no return option for new func syntax
        <li>Added function keyword arguments ala python, eg. <code>f = ({x = 2, y = 3}) -&gt; x + y</code>, and then application with <code>f y: 4</code>
        <li>Removed overloading of <code>+</code> for list concatination (just use <code>+++</code>)
        <li>Readded bitwise compound assign, eg. <code>.&.=</code>
        <li>Added <code>where</code>, like <code>let</code> but comes after instead of before - also allows for nested assignments
        <li>Changed fuzzy equals (<code>==</code> in JS) to <code>~=</code>, <code>!~=</code> for the negation
        <li>Added <code>xor</code> operator, exclusive or - true if only one side or the other is true
        <li>Doing equals on a regex literal will compile to an exec, eg. <code>x == /[ae]/g</code> is <code>/[ae]/g.exec(x)</code> - you can use <code>that</code> to get the results if used in an if statement. The negation simply uses test.
        <li>Binary logic is callable, eg. <code>(f or g) x</code> is <code>f(x) || g(x)</code>
        <li>Allow splicing like in CoffeeScript, eg. <code>list[1 to x] = [1 2 3]</code>
        <li>Static functions are now inherited and support calls to <code>super</code>
        <li>Generated reference variables are now named with a <code>$</code> after them instead of <code>__</code> preceding. eg. <code>ref$</code> instead of <code>__ref</code>
        <li>Removed constructor shorthand, just use <code>constructor</code>
        <li>Added cascade op from coco <code>..</code>
        <li>Added deep compare, allows the comparison of objects, arrays, and more. <code>===</code> - experimental
        <li>Added <code>match</code> statement - experimental
      </ul>
      <h3>0.9.12</h3>
      <ul>
        <li>Changed bitwise/shift operator syntax to be more clear. Now simply as in JS, but surrounded by dots. Eg. <code>&</code> is <code>.&.</code>, and <code>&gt;&gt;</code> is <code>.&gt;&gt;.</code>
        <li>Speed improvements
        <li>Allowed arbitrary expressions in slicing syntax, eg. <code>list[1 to x]</code>
        <li>Made classes work more like in CoffeeScript - details:
        <li>Constructors are now inherited
        <li>Allowed empty class definitions, eg. <code>class A extends B</code>
        <li>Bound methods (eg. <code>f: ~></code>) are bound to the instance, not to the class
      </ul>
      <h3>0.9.11</h3>
      <ul>
        <li>Bug fixes
        <li>Updated to work with node 0.8.x
        <li>Added partial application of funcs using <code>_</code> placeholder
        <li>Added infix <code>with</code> "cloneport", clones head and imports tail into that
        <li>Allow partial application of pipe <code>|&gt;</code> and backpipe <code>&lt;|</code> and use as function
        <li>Better compilation of various operators-as-functions
        <li>Added existential soak implicit call/lookup, eg. <code>(?length)</code>
        <li>Allow partially applied assign - <code>=</code>, <code>+=</code>, etc.
        <li>Removed <code>|&gt;&gt;</code> pipe operator - use normal pipes and partial application now
        <li>Changed backcall placeholder to underscore <code>_</code>
        <li>Added underscore <code>_</code> as alias to <code>otherwise</code> in switch statements
        <li>Added <code>--prelude</code> or <code>-d</code> option to automatically include <a href="http://gkz.github.com/prelude-ls/">prelude.ls</a> in compiled files
        <li>Added <code>--const</code> or <code>-k</code> option to compile as if all variables are constants
        <li>Added partial application of property accessor eg. <code>(obj.)</code>
        <li>Removed cons <code>&</code> operator
        <li>Added <code>&</code> as alias to <code>arguments</code>, allowing <code>-> &0 + &1</code> etc.
        <li>Removed <code>@@</code> as alias to <code>arguments</code>
        <li>Increased precedence of the pipe <code>|&gt;</code> operator to allow assignment of the entire thing without parens, not just of the first section
        <li>Added mixin feature <code>implements</code> thanks to Coco, eg. <code>class Cow extends Animal implements Mooer</code>, which does <code>::&lt;&lt;&lt; Mooer</code> in the class body.
      </ul>
      <h3>0.9.10</h3>
      <ul>
        <li>Now have `const` and `var` thanks to Coco
        <li>Implicit access and call functions, eg. <code>(.length)</code> and <code>(.join \|)</code> - useful for mapping/filtering, etc.
        <li>Bug fixes
        <li>Improved repl
      </ul>
      <h3>0.9.9</h3>
      <ul>
        <li>Various bug fixes
        <li>Calling a curried funciton with no args calls it as is rather than returning itself
        <li>Allow partial application of second arg for infix functions
      </ul>
      <h3>0.9.8</h3>
      <ul>
        <li>Object comprehensions added
        <li>Dashes in identifiers allowed (transformed to camel case)
      </ul>
      <h3>0.9.7</h3>
      <ul>
        <li>Bug fixes
        <li>Precedence change of <code>&</code> and <code>+++</code>
        <li>Nicer pipe <code>|&gt;</code> compilation
      </ul>
      <h3>0.9.6</h3>
      <ul>
        <li>Partially applied operators
        <li>Operators as functions
      </ul>
      <h3>0.9.5</h3>
      <ul>
        <li>Infix function calls added
        <li>JS literals removed
        <li>Improved CLI
      </ul>
      <h3>0.9.4</h3>
      <ul>
        <li>Added proper list comprehensions
        <li>Removed post-fix loops
      </ul>
      <h3>0.9.3</h3>
      <ul>
        <li>Changed node requirements
      </ul>
      <h3>0.9.2</h3>
      <ul>
        <li>Improved CLI
        <li>Enabled expressions in range syntax
      </ul>
      <h3>0.9.1</h3>
      <ul>
        <li>Changed number radix symbol to <code>~</code>
        <li>Added <code>%%=</code>
      </ul>
      <h3>0.9.0</h3>
      <ul>
        <li>Initial public release, many changes. See <a href="#changes">Changes from Coco</a> for more details.
      </ul>
      <p>For more details see <a href="#changes">Changes from Coco</a>.
    </div>
    <hr>
    <div id="inspiration" class="section">
      <a name="inspiration"></a>
      <h2>Inspiration</h2>
        <ul>
          <li>Functional languages in general
          <li>Haskell
          <li>F#
        </ul>
    </div>
    <div id="name" class="section">
      <a name="name"></a>
      <h2>Name</h2>
        <p>LiveScript was one of the original names for JavaScript, so it seemed fitting. It's an inside joke for those who know JavaScript well.
    </div>
    <div id="thanks" class="section">
      <a name="thanks"></a>
      <h2>Thanks</h2>
      <p>You can find the full list of contributors <a href="https://github.com/gkz/LiveScript/graphs/contributors">here</a>. That list includes contributors to LiveScript and its predecessors.
      <p>People who have contributed directly to LiveScript include <a href="https://github.com/gkz">George Zahariev</a>, <a href="https://github.com/satyr">Satoshi Murakami</a>, <a href="https://github.com/josher19">Joshua Weinstein</a>, <a href="https://github.com/goatslacker">Josh Perez</a>, <a href="https://github.com/paulmillr">Paul Miller</a>, <a href="https://github.com/vendethiel">vendethiel</a>, <a href="https://github.com/killdream">killdream</a>, <a href="https://github.com/audreyt">audreyt</a>, <a href="https://github.com/clkao">clkao</a>, <a href="https://github.com/viclib">viclib</a>, <a href="https://github.com/dtinth">dtinth</a>, <a href="https://github.com/racklin">racklin</a>, <a href="https://github.com/raine">Raine Virta</a>, <a href="https://github.com/Diggsey">Diggory Blake</a>, <a href="https://github.com/Haspaker">Haspaker</a>, <a href="https://github.com/synapsos">synapsos</a>, <a href="https://github.com/blvz">Rafael Belvederese</a>, <a href="https://github.com/apaleslimghost">Kara Brightwell</a>, <a href="https://github.com/rhendric">Ryan Hendrickson</a>, <a href="https://github.com/impinball">impinball</a>, <a href="https://github.com/skovsgaard">skovsgaard</a>, <a href="https://github.com/piotrklibert">Piotr Klibert</a>, <a href="https://github.com/appedemic">appedemic</a>, <a href="https://github.com/gkovacs">Geza Kovacs</a>, <a href="https://github.com/isiahmeadows">Isiah Meadows</a>, <a href="https://github.com/kevgo">Kevin Goslar</a>, <a href="https://github.com/kkirby">Kyle Kirby</a>, <a href="https://github.com/igl">Richard</a>, <a href="https://github.com/RobLoach">Rob Loach</a>, <a href="https://github.com/unclechu">Viacheslav Lotsmanov</a>, <a href="https://github.com/darky">Vladislav Botvin</a>, <a href="https://github.com/summivox">Yin Zhong</a>, <a href="https://github.com/misterfish">Allen Haim</a>, <a href="https://github.com/bartosz-m">Bartosz</a>, <a href="https://github.com/dk00">dk00</a>, <a href="https://github.com/pepkin88">Marek Pepke</a>, <a href="https://github.com/patrickkettner">Patrick Kettner</a>.
      <p>Thank you to <a href="http://nielsgrootobbink.com/">Niels Groot Obbink</a> for giving me the <a href="http://livescript.org">livescript.org</a> domain name.
      <p>An extra special thanks to Satoshi, as this project is a fork of his project <a href="https://github.com/satyr/coco">Coco</a> and would not be possible without it. It has been a pleasure to work off of his beautiful Coco compiler.
    </div>
    <div id="contributing" class="section">
      <a name="contributing"></a>
      <h2>Contributing Guide</h2>
      <p>Fork <a href="https://github.com/gkz/LiveScript">LiveScript</a> and make your changes. Always write tests first (in the <code>/test</code> directory).
      <p>Check out the Makefile included - it has all the available commands.
      <p>Always make sure you can <code>make full</code> - ie. build the compiler itself. Useful: <code>git checkout -- lib &&  make full</code>: cleans out your <code>lib</code> and compiles twice and tests. Only send a pull requests if all tests pass. Once all tests pass, rewrite any of the compiler that needs rewriting, and then <code>make full</code>. Use <code>make test-harmony</code> to test with generators and such with node's <code>--harmony</code> flag.
      <p>Don't submit patches with a built browser file (<code>browser/livescript.js</code>) created by <code>make build-browser</code>. This file is only built before releasing a new version.
    </div>
    <div class="section" id="changes">
      <a name="changes"></a>
      <h2>Changes from Coco: Detail and Rationale</h2>
      <p>This section is has not been updated since 1.0.x
      <ul>
      <li>Renamed everything from Coco and Coke to LiveScript and Slake, and file extension from .co to .ls. Rationale for names chosen: LiveScript was the name of JavaScript before it was named JavaScript - thus it seemed like an appropriate name, also few if any other projects are named LiveScript. Slake because lake was taken and lsake sounds bad.
      <li>Switched so that <code>==</code> compiles into <code>===</code>, and also for the negatives. Rationale: Most people would want to use the JavaScript <code>===</code> more often than <code>==</code> and less typing is better, also this makes things more similar to CoffeeScript which compiles <code>==</code> to <code>===</code> so there is less code for people to change coming from CoffeeScript. The compilation of <code>is</code> to <code>===</code> stays the same.
      <li>Switched <code>in</code> and <code>of</code> so that they are like in CoffeeScript. In goes over values, of over keys. Rationale: People have to change less of their CoffeeScript code, they're used to it, and using <code>in</code> for checking if a value is in an array just seems right, using <code>of</code> just feels weird.
      <li>All bitwise operators except <code>~</code> have changed to be surrounded by dots, eg. <code>&amp;</code> is now <code>.&amp;.</code> and <code>&gt;&gt;</code> is <code>.&gt;&gt;.</code>. Bitwise assign equals (eg. <code>&amp;=</code>) have been removed. Rationale: People rarely use the bitwise operators all the time, and they take up valuable symbols that could be used for other purposes. They are still available, just in a longer form. <code>~</code> is still there as is.
      <li><code>=></code>, the pipe operator using <code>_</code>, is removed. Free up => (for <code>then</code> alias), (<code>|</code> is used as an alias for case). Use other pipes (<code>|></code>) and partial application instead.
      <li><code>|</code> is an alias for <code>case</code> (used in switch) Rationale: less typing, looks good. Modelled after Haskell's guards.
      <li><code>=></code> is an alias for <code>then</code>. Rationale: will not be encouraged for use in if statements as it looks slightly odd - really for use in switch statements, when combined with <code>|</code>, to create a succinct and easy to understand structure. Based off of Haskell's use of -> in case expressions.
      <li>Added <code>otherwise</code> and underscore <code>_</code> as a contextual keyword, when used after <code>case</code> or <code>|</code>, making that the default statement. Rationale: same as in Haskell (otherwise), underscore as in Scala - and shorter. It allows <code>| otherwise => 4 + 9</code>, which fits in with the rest of the structure.
      <li>Added implicit <code>switch</code> after <code>-></code>, <code>~></code>, <code>:</code>, or an assign when they are followed by case tokens (either <code>case</code> or <code>|</code>). Rationale: reduces typing and increases beauty in a common situation for using a switch, with no increase in ambiguity.
      <li>Added list concat operator, <code>+++</code>. Eg. <code>xs +++ ys</code> is <code>xs.concat(ys)</code>. Rationale: less typing, more beautiful, inspired by the ++ function in Haskell (had to use 3 pluses in order to avoid ambiguity with increment operator.)
      <li><code>^</code> is now an alias to <code>**</code>, the power operator. Rationale: it was available, and is used in other languages.
      <li>Power precedence is now proper, and the power operator has precedence over multiplication and division. It also has higher precedence than unary ops. Eg. 2*4^2 == 32, not 64 as in Coco. Also, -2^2 == -4. Rationale: math should work properly - this is how it's done in many languages including Haskell.
      <li>Power operator is now right associative. eg. 2^2^3 == 2^(2^3) == 256. Rationale: follwing Haskell's and many other languages lead on this one.
      <li>Added magic auto curried functions, defined using <code>--></code> and <code>~~></code>. With this you can do <code>times = (x, y) --> x * y</code>, <code>timesTwo = times 2</code>, <code>timesTwo 4 #=> 8</code>. If you call a curried function with no arguments, it calls itself as is, instead of returning itself (you can just reference it if you want it itself). Rationale: more Haskell like, useful functionality.
      <li>Added new function definition syntax, eg. <code>add(x, y) = x + y</code> == <code>add = (x, y) --> x + y</code>. You can also use it in object literals and class definitions eg. <code>add(x, y): x + y</code> == <code>add: (x, y) --> x + y</code>. You can also suppress return on both by starting with a bang, eg. <code>!nothingness(params) = true</code> will not return anything. As well you can have lexically bound this using <code>id@(param) = something</code> which is suger for <code>id = (param) ~~> something</code> (notice the wavy arrow). You can go crazy and do something like this if you wish: <code>@!func@! = something</code> which is a function assigned to this, which takes no parameters and returns nothing, while being lexically bound to this. All functions defined using this syntax are curried. Rationale: more beautiful, less typing, more Haskell like.
      <li>Added <code>obj ::= obj2</code> as alias to <code>obj::&lt;&lt;&lt;obj2</code>. Rationale: seems to be the intuitive behavior expected, looks cleaner.
      <li>Added <code>yes / on</code> as aliases to <code>true</code> and <code>no / off</code> as aliases to <code>false</code>. Added <code>undefined</code> as an alias to <code>void</code>, and aliased <code>isnt</code> to <code>is not</code>. Rationale: ease transition from CoffeeScript, which has all these features, to LiveScript.
      <li>Added <code>when</code> as alias to <code>case</code> (and <code>|</code>). Rationale: ease transition from CoffeeScript.
      <li>Allowed guards in loops using case statement, eg. <code>x for x from 1 to 10 when x % 2 is 0</code>. Rationale: ease transition from CoffeeScript and have guards in comprehensions like other languages (Haskell).
      <li>Added the use of <code>else</code> for default in switch. Rationale: ease transition from CoffeeScript.
      <li>Added <code>loop</code> as alias for <code>while true</code>. Rationale: ease transition from CoffeeScript.
      <li>Added pipe operator <code>|></code> ala F#, <code>val |> func</code> is the same as <code>func(val)</code>. Very useful in combination with curried functions. Rationale: useful, as in F#.
      <li>Added backwards pipe operator <code><|</code> ala F#: <code>f <| x</code> is the same as <code>f x</code>. This is more useful than it looks, and can help you avoid parens. For instance for a definition of toCase that returns a function that either uppercases or lowercases a word, <code>toCase \up <| \hello</code> rather than <code>toCase(\up) \hello</code>. Rationale: useful as per above, as in F#.
      <li>Added function composition operators ala F#. <code>&gt;&gt;</code> and <code>&lt;&lt;</code>. <code>(f &gt;&gt; g) x</code> is <code>g(f(x))</code> and <code>(f &lt;&lt; g) x</code> is <code>f(g(x))</code>. Rationale: very useful, especially with curried functions. As in F# (and Haskell, there it's the dot operator).
      <li>Added <code>%%</code> operator (and corresponding <code>%%=</code> operator), <code>x %% y</code> is <code>(x % y + y) % y</code>. Eg. <code>-3 % 4 == -3; -3 %% 4 == 1</code>. Rationale: this is how the <code>%</code> op behaves in other languages such as Python and Ruby.
      <li>Changed number base format from <code>7r4</code> to <code>7~4</code>. This is because using <code>r</code> causes ambiguity with number comments. For instance, <code>36rpm</code> - is that the number <code>36</code> with the number comment <code>rpm</code> or is it <code>pm</code> base <code>36</code> (922). Also now accept any number as radix, so that a better error can be thrown when that radix is not 2-36. Rationale: fixes ambiguity.
      <li>Allowed expression in range syntax, eg. <code>[x to y/2]</code> instead of just number literals. This has the side effect of removing naked ranges, eg. <code>2 to 5</code> without enclosing brackets (for loops remain unchanged). Rationale: expressions in ranges are useful, much more than naked ranges which have really limited use. Also closer to CoffeeScript, easing transition again.
      <li>Changed CLI to bare compilation so that defined variables are attached to global scope. Improved repl to continue when lines end with <code>-></code>, <code>~></code>, or <code>=</code>
      <li>Added list comprehensions (eg. <code>[x for x in list when x is \something]</code>) and removed postfix loops (eg. <code>something x for x in list</code>). Comprehensions always return a list. Nested list comprehensions behave properly, ie. the last for is the inner most loop. Rationale: following Haskell and Python. More consistent behavior. Easier to deal with in your head. More intuitive.
      <li>Changed JS literals to use two backticks, eg. <code>``js code here``</code> instead of <code>`js code here`</code>. Rationale: it was seldom needed; frees up backticks for infix function application.
      <li>Add infix function application, eg. <code>3 `add` 2</code>. Rationale: as in Haskell. This allows for partial application of their second argument, like operators eg. <code>(`times` 2)</code>.
      <li>Changed unary clone operator from <code>^</code> to <code>^^</code>. Rationale: disambiguate with partial application of power operator.
      <li>Added partial application of operators. Eg. <code>(+ 2)</code> returns a function which adds 2 to its argument. Also allowed is simply <code>(*)</code> which is a function which multiplies its two arguments. <code>(+x)</code> and <code>(-x)</code> still mean the application of those unary operators - the operator must be spaced to be the partial application of that operator. Using the length star <code>*</code> is no longer allowed within parens (sometimes used when setting dynamic keys), due to ambiguity with the partially applied multiplication operator. Rationale: awesome. As in Haskell.
      <li>Added unary operators as functions. Eg. you can use <code>(not)</code> as a function, compose it, etc. Rationale: very useful, as in Haskell.
      <li>Added <code>.</code> as alias to <code>&lt;&lt;</code> in composing functions. This disallows property access in the style of <code>x . y</code>. Rationale: as in Haskell. Dually spaced property access should never be used anyway.
      <li>Added object comprehensions. Eg. <code>{[key, val * 2] for key, val of obj}</code> would return an object with all the values double of the original. The first part of the array literal gets translated into the key, the second part into the value. Rationale: very useful when dealing with objects. Can now map and filter objects back into objects.
      <li>Dashes are now supported in identifiers, they get converted into camel case. Eg. <code>get-room</code> is equivalent to <code>getRoom</code>, <code>encode-URI</code> is <code>encodeURI</code>. Rationale: enable different styles which other people may enjoy. As in the lisp family of languages.
      <li>Added implicit call/lookup eg. <code>(.length)</code> is equivalent to <code>-> it.length</code> and <code>(.join \*)</code> is equivalent to <code>-> it.join \*</code>. <code>(obj.)</code> is <code>-> obj[it]</code>. Rationale: useful when mapping, filtering, etc.
      <li>Added infix <code>with</code> operator ("cloneport"). Eg. <code>personA = personB with name: \alice</code> is equivalent to <code>personA = ^^personB &lt;&lt;&lt; name: \alice</code>. Ie. it clones the head and imports the tail into that new object. <code>personB</code> is unmodified. Rationale: really nice may to create new objects out of old ones.
      <li>Add partial application, <code>_</code> is the placeholder. Eg. <code>f = add-three-numbers 1, _, 3</code> then <code>f 2 #=> 6</code>. Can be multiple times, and like curried functions if called with no args will invoke, allowing use of default args. Rationale: really useful, for when function args aren't in a nice order so you can use a curried version.
      <li>Changed backcall <code>&lt;-</code> placeholder to underscore <code>_</code>. Rationale: fit in with partial application placeholder.
      <li>Changed <code>arguments</code> alias to <code>&</code>, removed <code>@@</code> as that alias. Eg. <code>-> &amp;0 + &amp;1</code>. Rationale: shorter - less typing.
      <li>Added <code>-d, --prelude</code> option for automatically adding prelude.ls. Rationale: make it easier to use prelude.ls.
      <li>Added <code>-k, --const</code> option for compiling as if all variables as constants. Rationale: some people coming from languages with all immutable values may find this nice.
      <li>Allowed arbitrary expressions in slicing syntax, eg. <code>list[1 to x]</code>. Rationale: useful.
      <li>Changed so that constructors are inherited. Rationale: useful, and more like in CoffeeScript.
      <li>Allowed empty class definitions, ie. with no block. Rationale: useful and more like CoffeeScript.
      <li>Bound methods are bound to the instance, not the class. Rationale: seems pretty useless to be bound to the class, so this is more useful. Also more like CoffeeScript.
      <li>Added function keyword arguments like in python. Rationale: useful.
      <li>Added a exclusive or <code>xor</code> operator. Rationale: logic completeness.
      <li>Binary logic is callable. Ratioanle: useful.
      <li>Allow splicing like in CoffeeScript. Rationale: easier transition, useful.
      <li>Overloaded equals when using regex to mean exec/test. Rationale: shorter.
      <li>Static functions are inherited. Rationale: as in CoffeeScript - ease transition.
      <li>Removed the constructor shorthand. Rationale: rarely useful, use it for cascade instead.
      <li>Changed cascade op from <code>&</code> to <code>..</code>. Rationale: like in other languages.
      <li>Added match statement and deep compare. Rationale: experimental, will see if good.
      <li>For changes after 1.0.0, see the <a href="#changelog">changelog</a> section.
      </ul>
    </div>
  </div>
</div>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

<script src="jquery-1.8.3.min.js"></script>

<script src="bootstrap/js/bootstrap.js"></script>
<script src="bootstrap/js/bootstrap-scrollspy.js"></script>

<script src="google-code-prettify/prettify.js"></script>
<script src="lang-ls-1.6.0.js"></script>

<script src="underscore-min.js"></script>
<script src="prelude-browser-min-1.1.2.js"></script>
<script src="livescript-1.6.0-min.js"></script>
<script src="site.js"></script>

</body>
</html>
