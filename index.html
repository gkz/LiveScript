<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<title>LiveScript - a language which compiles to JavaScript</title>
<meta name='description' content="LiveScript is a language that compiles down to JavaScript. It is a fork of Coco, which is in turn derived from CoffeeScript. LiveScript is Coco that is much more compatible with CoffeeScript, more functional, and more feature rich.">

<link rel="icon" type="image/png" href="images/icon.png">


<link href="bootstrap/themes/cerulean.bootstrap.min.css" rel="stylesheet">

<link href="google-code-prettify/prettify.css" rel="stylesheet">

<link href="styles.css" rel="stylesheet">

<script>
  if(window.location.host === "gkz.github.com") {
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-7402515-5']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    //start mixpanel
    (function(c,a){window.mixpanel=a;var b,d,h,e;b=c.createElement("script");b.type="text/javascript";b.async=!0;b.src=("https:"===c.location.protocol?"https:":"http:")+'//api.mixpanel.com/site_media/js/api/mixpanel.2.js';d=c.getElementsByTagName("script")[0];d.parentNode.insertBefore(b,d);a._i=[];a.init=function(b,c,f){function d(a,b){var c=b.split(".");2==c.length&&(a=a[c[0]],b=c[1]);a[b]=function(){a.push([b].concat(Array.prototype.slice.call(arguments,0)))}}var g=a;"undefined"!==
    typeof f?g=a[f]=[]:f="mixpanel";g.people=g.people||[];h="disable track track_pageview track_links track_forms register register_once unregister identify name_tag set_config people.set people.increment".split(" ");for(e=0;e<h.length;e++)d(g,h[e]);a._i.push([b,c,f])};a.__SV=1.1})(document,window.mixpanel||[]);
    mixpanel.init("e15b4dc3bc8fa58ccccbcb823c581b9b");
    mixpanel.track('teset');
  }
</script>
</head>
<body data-spy="scroll">
<div class="site container-fluid">
  <div class="row-fluid side-row">
    <div class="span2 sidebar">
      <h1><a href="#">LiveScript</a><img src="images/icon.png"></h1>
      <ul class="nav nav-list">
        <li class="active"><a href="#overview">Overview</a></li> 
        <li class="divider">
        <li><a href="#installation">Installation</a></li> 
        <li><a href="#usage">Usage</a></li> 
        <li><a href="#community">Community</a></li> 
        <li><a href="#editor-support">Text Editor Support</a></li> 
        <li><a href="#prelude-ls">Standard Library</a></li>
        <li class="divider">
        <li><a href="#introduction">Introduction</a></li> 
        <li><a href="#literals">Literals</a></li> 
        <li><a href="#operators">Operators</a></li> 
        <li><a href="#functions">Functions</a></li> 
        <li><a href="#if-unless">If and Unless</a></li> 
        <li><a href="#loops">Loops and Comprehensions</a></li> 
        <li><a href="#switch">Switch</a></li> 
        <li><a href="#assignment">Assignment</a></li> 
        <li><a href="#property-access">Property Access</a></li> 
        <li><a href="#oop">OOP</a></li> 
        <li class="divider">
        <li><a href="#coffee-to-ls">Converting from CoffeeScript</a></li> 
        <li><a href="#speed">Speed</a></li> 
        <li><a href="#changes">Changes from Coco</a></li> 
        <li><a href="#changelog">Changelog</a></li> 
        <li class="divider">
        <li><a href="#inspiration">Inspiration</a></li> 
        <li><a href="#name">Name</a></li> 
        <li><a href="#thanks">Thanks</a></li> 
        <li><a href="#contributing">Contributing Guide</a></li> 
      </ul>
    </div>
    <div class="span4 compiler">
      <div class="compiler-box">
      <div class="github-buttons">
<a href="https://twitter.com/share" class="twitter-share-button" data-url="http://gkz.github.com/LiveScript/" data-text="LiveScript - functional CoffeeScript" data-related="gkzahariev:The Creator" data-via="gkzahariev">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
        <iframe src="http://ghbtns.com/github-btn.html?user=gkz&repo=LiveScript&type=watch&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="120px" height="20px"></iframe>
      </div>
        <textarea placeholder="Enter LiveScript here"></textarea>
        <div class="actions">
          <button class="btn btn-primary" data-action="compile" title="Convert LiveScript to JavaScript">Compile</button>
          <button class="btn" data-action="run" title="Run compiled JavaScript">Run</button>
          <button class="btn" data-action="ast" title="Abstract Syntax Tree">AST</button>
          <button class="btn" data-action="tokens" title="Tokenization of input">Tokens</button>
          <button class="btn" data-action="lex" title="Same as tokens, but skipping rewriting">Lex</button>
        </div>
      </div>
      <div class="compiler-output">

      </div>
    </div>
  </div>
  <div class="row-fluid content-row">
    <div class="span2">&nbsp;</div>
    <div class="span6 content">
      <div id="overview" class="section">
        <a name="overview"></a>
        <h2>Overview</h2>
        <p>LiveScript is a language which compiles to JavaScript. It is a fork of <a href="http://satyr.github.com/coco/">Coco</a> which is in turn derived from <a href="http://coffeescript.org/">CoffeeScript</a>. Like those two it has a relatively straightforward mapping to JavaScript. LiveScript is Coco but much more compatible with CoffeeScript, more functional, and more feature rich. LiveScript aims for increased expressiveness and code beauty.
        <p>While adding features to assist in functional style programming, LiveScript also deeply supports imperative and object oriented programming, and has an optional class system with inheritance, calls to super, and more.
        <div class="major-actions">
          <h3 class="download">1.0.0:</h3>
          <a href="https://github.com/gkz/LiveScript/zipball/1.0.0"><div class="btn btn-large btn">zip</div></a>
          <a href="https://github.com/gkz/LiveScript/tarball/1.0.0"><div class="btn btn-large btn">tar.gz</div></a>
          <a href="https://github.com/gkz/LiveScript"><div class="btn btn-large btn-primary">View project on GitHub</div></a>
          <iframe src="http://ghbtns.com/github-btn.html?user=gkz&repo=LiveScript&type=watch&size=large&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="150" height="40"></iframe>
          <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://gkz.github.com/LiveScript/" data-text="LiveScript - functional CoffeeScript" data-size="large" data-related="gkzahariev:The Creator" data-via="gkzahariev">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
        </div>
<p><a href="https://twitter.com/gkzahariev" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @gkzahariev</a> for updates on LiveScript. Looking for an intern in early 2013? <strong><a id="email">Hire me</a></strong>!
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
        <p>Featured blog post: <strong><a href="blog/powerful-jquery-with-livescript.html">Powerful jQuery with LiveScript</a></strong>
        <p>Double-click an example to load it into the compiler/repl. CoffeeScript users check out the <a href="#coffee-to-ls">CoffeeScript to LiveScript Conversion Guide</a>.
      <h3>Some Examples</h3>
      <p>Unnested callbacks and parentheses free chaining:
      <div class="example">
        <div class="example-ls">
        <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
<-! $ \h1 .on \click
alert \boom!
</pre>
        </div>
        <div class="example-js">
        <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
$('h1').on('click', function(){
  alert('boom!');
});
</pre>
        </div>
      </div>
      <p>Curried functions, implicit switch, the concat operator, and function composition:
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
take(n, [x, ...xs]:list) =
  | n <= 0     => []
  | empty list => []
  | otherwise  => [x] +++ take n - 1, xs









take 2, [1 2 3 4 5] #=> [1, 2]

take-three = take 3
take-three [3 to 8] #=> [3, 4, 5]

# Function composition, 'reverse' from prelude.ls
last-three = reverse >> take-three >> reverse
last-three [1 to 8] #=> [6, 7, 8]
</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var take, takeThree, lastThree, slice$ = [].slice;
take = curry$(function(n, list){
  var x, xs;
  x = list[0], xs = slice$.call(list, 1);
  switch (false) {
  case !(n <= 0):
    return [];
  case !empty(list):
    return [];
  default:
    return [x].concat(take(n - 1, xs));
  }
});
take(2, [1, 2, 3, 4, 5]);

takeThree = take(3);
takeThree([3, 4, 5, 6, 7, 8]);


lastThree = compose$([reverse, takeThree, reverse]);
lastThree([1, 2, 3, 4, 5, 6, 7, 8]);
function curry$(f, args){
  return f.length > 1 ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length && arguments.length ?
      curry$.call(this, f, params) : f.apply(this, params);
  } : f;
}
function compose$(fs){
  return function(){
    var i, args = arguments;
    for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }
    return args[0];
  };
}
</pre>
        </div>
      </div>
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">

# Easy listing of implicit objects using asterisks
table1 =
  * id: 1
    name: \george
  * id: 2
    name: \mike
  * id: 3
    name: \donald

table2 =
  * id: 2
    age: 21
  * id: 1
    age: 20
  * id: 3
    age: 26

# Implicit access, accessignment
up-case-name = (.name .= to-upper-case!)

# Curried functions using -->
sort-by = (prop, list) --> list.sort (a, b) -> 
  | a[prop] < b[prop] => -1
  | a[prop] > b[prop] => 1
  | otherwise         => 0







# List comprehensions, destructuring, piping
[{id:id1, name, age} for {id:id1, name} in table1 for {id:id2, age} in table2 when id1 is id2]
|> sort-by \id
|> each up-case-name # using 'each' from prelude.ls
|> JSON.stringify
#=>
#[{"id":1,"name":"GEORGE","age":20},
# {"id":2,"name":"MIKE",  "age":21},
# {"id":3,"name":"DONALD","age":26}]















# operators as functions, backpipe
fold1 (+) <| map (.age), table2
#=> 67 ('fold1' and 'map' from prelude.ls)
</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var table1, table2, upCaseName,
    sortBy, id1, name, id2, age;
table1 = [
  { id: 1,
    name: 'george' },
  { id: 2,
    name: 'mike' },
  { id: 3,
    name: 'donald' }
];
table2 = [
  { id: 2,
    age: 21 },
  { id: 1,
    age: 20 },
  { id: 3,
    age: 26 }
];
upCaseName = function(it){
  return it.name = it.name.toUpperCase();
};
sortBy = curry$(function(prop, list){
  return list.sort(function(a, b){
    switch (false) {
    case !(a[prop] < b[prop]):
      return -1;
    case !(a[prop] > b[prop]):
      return 1;
    default:
      return 0;
    }
  });
});
JSON.stringify(
each(upCaseName)(
sortBy('id')(
(function(){
  var i$, ref$, len$, ref1$, j$, len1$, ref2$, results$ = [];
  for (i$ = 0, len$ = (ref$ = table1).length; i$ < len$; ++i$) {
    ref1$ = ref$[i$], id1 = ref1$.id, name = ref1$.name;
    for (j$ = 0, len1$ = (ref1$ = table2).length; j$ < len1$; ++j$) {
      ref2$ = ref1$[j$], id2 = ref2$.id, age = ref2$.age;
      if (id1 === id2) {
        results$.push({
          id: id1,
          name: name,
          age: age
        });
      }
    }
  }
  return results$;
}()))));
fold1(curry$(function(x$, y$){
  return x$ + y$;
}))(map(function(it){
  return it.age;
}, table2));
function curry$(f, args){
  return f.length > 1 ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length && arguments.length ?
      curry$.call(this, f, params) : f.apply(this, params);
  } : f;
}
</pre>
        </div>
      </div>
    </div>
    <hr>
    <div id="installation" class="section">
      <a name="installation"></a>
      <h2>Installation</h2>
      <p>You can install LiveScript through the <a href="http://npmjs.org">Node Package Manager</a>: <strong><code>sudo npm install -g LiveScript</code></strong>.
      <p>Alternately, you can also download it (<a href="https://github.com/gkz/LiveScript/zipball/1.0.0">zip</a>, <a href="https://github.com/gkz/LiveScript/tarball/1.0.0">tar.gz</a>), enter its directory, and run <code>sudo bin/slake install</code>. Using git to download: <code>git clone git://github.com/gkz/LiveScript.git && cd LiveScript && sudo bin/slake install</code>. <a href="http:/nodejs.org">Node.js</a> is required to be installed on your system.</p>
      <p>You can also use it directly in the browser by including the file in <code>LiveScript/extras/livescript.js</code> via a script tag. In fact, this is how this page operates.</p>
    </div>
    <div id="usage" class="section">
      <a name="usage"></a>
      <h2>Usage</h2>
      <p>Usage: <code>livescript [options] [files] [arguments]</code></p>
      <h3>Options</h3>
      <table class="usage-options table table-striped table-bordered">
        <tr><td>-i, --interactive</td><td>start REPL; use ^J for multiline input</td></tr>
        <tr><td>-c, --compile</td><td>compile to JavaScript and save as .js files</td></tr>
        <tr><td>-d, --prelude</td><td>automatically import prelude.ls</td></tr>
        <tr><td>-k, --const</td><td>compile all variables as constants</td></tr>
        <tr><td>-o, --output DIR</td><td>compile into the specified directory</td></tr>
        <tr><td>-w, --watch</td><td>watch scripts for changes, and repeat</td></tr>
        <tr><td>-s, --stdin</td><td>read stdin</td></tr>
        <tr><td>-e, --eval</td><td>read command line arguments as script</td></tr>
        <tr><td>-r, --require FILE+</td><td>require libraries before executing</td></tr>
        <tr><td>-b, --bare</td><td>compile without the top-level function wrapper</td></tr>
        <tr><td>-p, --print</td><td>print the result to stdout</td></tr>
        <tr><td>-l, --lex</td><td>print the tokens the lexer produces</td></tr>
        <tr><td>-t, --tokens</td><td>print the tokens the rewriter produces</td></tr>
        <tr><td>-a, --ast</td><td>print the syntax tree the parser produces</td></tr>
        <tr><td>-j, --json</td><td>print/compile as JSON</td></tr>
        <tr><td>-n, --nodejs ARGS+</td><td>pass options through to the "node" binary</td></tr>
        <tr><td>-v, --version</td><td>display version</td></tr>
        <tr><td>-h, --help</td><td>display this</td></tr>
      </table>

      <h3>Examples</h3>

      <ul>
        <li>Run a LiveScript file (through node.js): <code>livescript file.ls</code> - you can omit the <code>.ls</code> if you wish.
        <li>Compile a LiveScript file, creating a <code>file.js</code>: <code>livescript -c file.ls</code>
        <li>Watch a file and compile on changes: <code>livescript -wc file.ls</code>
        <li>Compile a directory and output to another directory: <code>livescript -co output src</code>
        <li>Watch a directory, compile on change into an output directory: <code>livescript -wco output src</code>
        <li>Compile a one-liner and print the JS: <code>livescript -bpe '[1 to 5]'</code>
        <li>Start the LiveScript REPL: <code>livescript</code> - <code>Ctrl-D</code> to exit, use <code>Ctrl-J</code> for multiline input.
      </ul>
    </div>
    <div id="community" class="section">
      <a name="community"></a>
      <h2>Community</h2>
      <ul>
        <li><a href="https://groups.google.com/forum/#!forum/livescript">Google Groups</a>
        <li><a href="http://www.reddit.com/r/livescript/">r/livescript</a>
        <li><a href="http://ost.io/gkz/LiveScript">ost.io/gkz/LiveScript</a>
      </ul>
      <a name="blog"></a>
      <h3>Blog</h3>
      <ul>
        <li><a href="blog/powerful-jquery-with-livescript.html">Powerful jQuery with LiveScript</a>
        <li><a href="blog/livescript-1.0.0.html">LiveScript 1.0.0 Released</a>
        <li><a href="blog/functional-programming-in-javascript-using-livescript-part-2.html">Functional Programming in JavaScript using LiveScript - Part 2</a>
        <li><a href="blog/ten-reasons-to-switch-from-coffeescript.html">10 Reasons to Switch from CoffeeScript to LiveScript</a>
        <li><a href="blog/functional-programming-in-javascript-using-livescript-and-prelude-ls.html">Functional Programming in JavaScript using LiveScript and prelude.ls</a>
        <li><a href="blog/livescript-one-liners-to-impress-your-friends.html">10 LiveScript One Liners to Impress Your Friends</a>
      </ul>
      <h3>In the Wild</h3>
      <ul>
        <li><a href="https://github.com/gkz/LiveScript/wiki/Projects-using-LiveScript">Projects using LiveScript</a>
        <li><a href="https://github.com/gkz/LiveScript/wiki/Projects-supporting-LiveScript">Projects supporting LiveScript</a>
      </ul>
      <p>Add your own projects to the lists!
    </div>
    <div id="editor-support" class="section">
      <a name="editor-support"></a>
      <h2>Text Editor Support</h2>
      <ul>
        <li>Vim users check out <a href="https://github.com/gkz/vim-ls">vim-ls</a>.
        <li>TextMate, Chocolat, and Sublime Text bundle for LiveScript: <a href="https://github.com/paulmillr/LiveScript.tmbundle">LiveScript.tmbundle</a>.
        <li>Emacs basic LiveScript support: <a href="https://github.com/tensai-cirno/livescript-mode">livescript-mode</a>
      </ul>
      <p>Add yours to the <a href="https://github.com/gkz/LiveScript/wiki/Projects-supporting-LiveScript">wiki page</a>.
    </div>
    <div id="prelude-ls" class="section">
      <a name="prelude-ls">
      <h2>Standard Library</h2>
      <p><a href="http://gkz.github.com/prelude-ls/">prelude.ls</a> is the recommended base library when using LiveScript. It allows you to do things such as:

<pre class="prettyprint lang-ls">
[1 2 3] |> map (* 2) |> filter (> 3) |> fold1 (+) 
#=> 10
</pre>

      <p>You can automatically import prelude.ls when compiling or using the repl by using the <code>-d</code> or <code>--prelude</code> options.

      <p>Prelude is loaded on this page and you can use it when running things in the compiler/repl to the right.
    </div>
    <hr>
    <div id="introduction" class="section">
      <a name="introduction"></a>
      <h2>Introduction</h2>
      <p>Like many modern languages, blocks are delimited by whitespace indentation and newlines are used instead of semicolons to terminate statements (you can still use semicolons if you want to fit more than one statement on a line).

      <p>For example (LiveScript on the left, compiled JavaScript on the right):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
if 2 + 2 == 4
  do-something()
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
if (2 + 2 === 4) {
  doSomething();
}
</pre>
        </div>
      </div>

      <p class="note">You can try all these examples for yourself using the LiveScript compiler/repl to the right.

      <p>To further clear things up, you can omit the parentheses when calling a function.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add 2, 3
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
add(2, 3);
</pre>
        </div>
      </div>

      <p>And comments are:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
# from here to the end of the line.
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
// from here to the end of the line.
</pre>
        </div>
      </div>

      <p class="note">Lisp hackers, you may be pleased to know that you can use dashes in the name of your variables and functions. The names are equivalent to, and are compiled to, camel case. Eg. <code>my-value = 42</code> == <code>myValue = 42</code>.

      <p>The file extension for LiveScript is <code>.ls</code>.


      <h3>Defining Functions</h3>

      <p>Defining functions is very lightweight in LiveScript:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

(x, y) -> x + y 

-> # an empty function 

times = (x, y) ->
  x * y
# multiple lines, and be assigned to 
# a var like in JavaScript
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var times;
(function(x, y){ return x + y; });

(function(){});

times = function(x, y){ 
  return x * y;
};


</pre>
        </div>
      </div>

      <p>As you see, function definitions are considerably shorter! You may also have noticed that we have omitted <code>return</code>. In LiveScript, almost everything is an expression and the last one reached is automatically returned. However, you can still use <code>return</code> to force returns if you want, and you can add a bang to your definitions to suppress auto-returning <code>no-ret = !(x) -> ...</code>.

      <h3>Assignment</h3>
      <p>Basic assignment is as you would expect, <code>variable = value</code>, and there is no need for variable declarations. However, unlike CoffeeScript, you must use <code>:=</code> to modify variables in upper scopes. 

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

x = 10


do ->
  x = 5

x #=> 10

do ->
  x := 2

x #=> 2
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 10;

(function(){
  var x;
  return x = 5;
})();
x;

(function(){
  return x = 2;
})();
x;
</pre>
        </div>
      </div>
      
      <p>Almost everything is an expression, which means you can do things like:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = if 2 + 2 == 4
    then 10
    else 0
x #=> 10
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 2 + 2 === 4 ? 10 : 0;

x;
</pre>
        </div>
      </div>

      <p>Things such as loops, switch statements, and even try/catch statements are all expressions. 

      <p>If you want to simply declare a variable and not initialize it, you can use <code>var</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
var x
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
</pre>
        </div>
      </div>

      <p>You can also declare constants in LiveScript using <code>const</code>. They are checked at compile time - the compiled JS is no different.
      
      <p>Attempting to compile the following:

<pre class="prettyprint lang-ls">
const x = 10
x = 0
</pre>

      <p>Results in <code>redeclaration of constant "x" on line 2</code>. 

      <p>However, objects are not frozen if declared as constants - you can still modify their properties. You can force all variables to be constants if you compile with the <code>-k</code> or <code>--const</code> flags.


      <h3>Info</h3>

      <p>For differences from CoffeeScript, see the <a href="#coffee-to-ls">CoffeeScript to LiveScript Conversion Guide</a>.
      <p>You can double click any of the examples to load the LiveScript code into the compiler to the right, or you can play around and try out your own code. Press run to execute the compiled JavaScript. Note that LiveScript wraps compiled JS in a safety wrapper <code>(function(){...contents...}).call(this);</code> - this wrapper has been omitted in all examples and this page's compiler output for conciseness.
    </div>
    <div id="literals" class="section">
      <a name="literal"></a>
      <h2>Literals</h2>

      <h3>Numbers</h3>

      <p><code>.4</code> is not valid, it must be preceded with a zero, eg. <code>0.4</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
42
17.34
0.4
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
42;
17.34;
0.4;
</pre>
        </div>
      </div>

      <p>Underscores and appended letters are ignored.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
64_000km
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
64000;
</pre>
        </div>
      </div>

      <p>Any base can be used from 2 to 36 using <code>~</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
6~12
2~1000
16~ff
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
8;
8;
255;
</pre>
        </div>
      </div>

      <h3>Booleans, Undefined, Null</h3>

      <p>Aliases as in CoffeeScript.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
true
false
on
off
yes
no
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
true;
false;
true;
false;
true;
false;
</pre>
        </div>
      </div>

      <p>In JavaScript, <code>undefined</code> can be redefined, so it is prudent to use the <code>void</code> operator which produces the undefined value, always.

      <p><code>void</code> at the top level compiles to nothing (for use as a placeholder) - it must be used as a value to compile.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

void
x = void
y = undefined

null
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x, y;
// void compiles to nothing here!
x = void 8;
y = void 8;

null;
</pre>
        </div>
      </div>

      <h3>Strings</h3>

      <p>You can use double or single quotes.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
'a string'
"a string"
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
'a string';
"a string";
</pre>
        </div>
      </div>


      <p>Strings without whitespace can be written with a preceding backslash instead of quotes.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
\word
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
'word';
</pre>
        </div>
      </div>

      <p>Double quoted strings allow interpolation. Single quoted strings are passed through as-is. Simple variables can be interpolated without curly braces.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

"The answer is #{2 + 2}"
'As #{is}'

variable = "world"
"Hello #variable"
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var variable;
"The answer is " + (2 + 2);
'As #{is}';

variable = "world";
"Hello " + variable;
</pre>
        </div>
      </div>

      <p>Multiline strings (can also do the same but with double quotes for use with interpolation):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
multiline = 'string can be multiline 
            and go on and on 
            beginning whitespace is 
            ignored'
heredoc = '''
            string can be multiline
            with newlines
            and go on and on
            beginning whitespace is
            ignored
'''
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var multiline, heredoc;
multiline = 'string can be multiline and go on and on beginning whitespace is ignored';

heredoc = 'string can be multiline\nwith newlines\nand go on and on\nbeginning whitespace is\nignored';






</pre>
        </div>
      </div>

      <h3>Comments</h3>

      <p>Single line comments start off with a <code>#</code>. They are not passed through to the compiled output.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
# single line comment
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">


</pre>
        </div>
      </div>

      <p>Multiline comments are preserved in the output.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
/* multiline comments
   use this format and are preserved
   in the output unlike single line ones
*/
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
/* multiline comments
   use this format and are preserved
   in the output unlike single line ones
*/
</pre>
        </div>
      </div>

      <h3>Objects</h3>

      <p>Braces are optional:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

obj = {prop: 1, thing: 'moo'}



person =
  age:      23
  eye-color: \green
  height:   180cm

oneline = color: \blue, heat: 4
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj, person, oneline;
obj = {
  prop: 1,
  thing: 'moo'
};
person = {
  age: 23,
  eyeColor: 'green',
  height: 180
};
oneline = {
  color: 'blue',
  heat: 4
};
</pre>
        </div>
      </div>

      <p>Dynamic keys:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj =
  "#variable": 234
  (person.eye-color): false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$, obj;
obj = (ref$ = {}, ref$[variable + ""] = 234, ref$[person.eyeColor] = false, ref$);
</pre>
        </div>
      </div>

      <p>Property setting shorthand - easily set properties with variables if you want the property name to be the same as the variable name.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = 1
y = 2
obj = {x, y}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x, y, obj;
x = 1;
y = 2;
obj = {
  x: x,
  y: y
};
</pre>
        </div>
      </div>

      <p>Flagging shorthand - easily set boolean properties.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
{+debug, -live}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
({
  debug: true,
  live: false
});
</pre>
        </div>
      </div>

      <p>This - no need to use a dot <code>.</code> to access properties.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
this
@
@location
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
this;
this;
this.location;
</pre>
        </div>
      </div>

      <h3>Regular Expressions</h3>

      <p>Regular regex delineated with a single <code>/</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
/moo/gi
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
/moo/gi;
</pre>
        </div>
      </div>

      <p>Delineated with <code>//</code> - multiline, comments, spacing!

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
//
| [!=]==?             # equality
| @@                  # arguments
| <\[(?:[\s\S]*?\]>)? # words
//g
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
/|[!=]==?|@@|<\[(?:[\s\S]*?\]>)?/g;





</pre>
        </div>
      </div>

      <h3>Lists</h3>

      <p>Regular list literal delineated with brackets:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[1, person.age, 'French Fries']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
[1, person.age, 'French Fries'];
</pre>
        </div>
      </div>

      <p>Commas are not needed if the item preceding is not callable:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[1 2 3 true void \word 'hello there']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
[1, 2, 3, true, void 8, 'word', 'hello there'];
</pre>
        </div>
      </div>

      <p>Implicit lists created with an indented block. They need at least two items for it to work. If you have only one item, you can add a yaddayaddayadda <code>...</code> to force the implicit list.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
my-list =
  32 + 1
  person.height
  \beautiful

one-item =
  1
  ...
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var myList, oneItem;
myList = [32 + 1, person.height, 'beautiful'];



oneItem = [1];



</pre>
        </div>
      </div>

      <p>Listing using asterisks:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
tree =
  * * 1
    * * 2
      * 3
    * 4
  * * 5
    * 6
    * * 7
      * 8
      * * 9
        * 10
    * 11

obj-list =
  * name: \tessa
    age:  23
  * name: \kendall
    age:  19
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var tree, objList;
tree = [[1, [2, 3], 4], [5, 6, [7, 8, [9, 10]], 11]];







objList = [
  {
    name: 'tessa',
    age: 23
  }, {
    name: 'kendall',
    age: 19
  }
];
</pre>
        </div>
      </div>

      <p>Lists of words:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
<[ list of words ]>
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
['list', 'of', 'words'];
</pre>
        </div>
      </div>

      <h3>Ranges</h3>

      <p>With number/string literals:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[2 to 20 by 3]
[4 til 6]
[\A to \D]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
[2, 5, 8, 11, 14, 17, 20];
[4, 5];
["A", "B", "C", "D"];
</pre>
        </div>
      </div>

      <p>With any expression:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = 4
r = [1 to x] #=> [1,2,3,4]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x, res$, ridx$, r;
x = 4;
res$ = [];
for (ridx$ = 1; ridx$ <= x; ++ridx$) {
  res$.push(ridx$);
}
r = res$;
</pre>
        </div>
      </div>
      <h3>Misc</h3>

      <p>Labels (useful for nested loops):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
:label 4 + 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
label: {
  4 + 2;
}
</pre>
        </div>
      </div>

      <p>Yaddayaddayadda - a placeholder:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
...
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
throw Error('unimplemented');
</pre>
        </div>
      </div>
    </div>

    <div id="operators" class="section">
      <a name="operators"></a>
      <h2>Operators</h2>

      <h3>Number</h3>

      <p>The standard math operators:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
1 + 2 #=> 3
3 - 4 #=> -1
6 * 2 #=> 12
8 / 4 #=> 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
1 + 2;
3 - 4;
6 * 2;
8 / 4;
</pre>
        </div>
      </div>

      <p>There is a remainder operator, as in JavaScript - but we also add a proper modulo operator.


      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

-3 % 4  #=> -3
-3 %% 4 #=> 1
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$;
-3 % 4;
((-3) % (ref$ = 4) + ref$) % ref$;
</pre>
        </div>
      </div>

      <p>The power is right associative, and has higher precedence than unary ops. <code>^</code> is an alias for <code>**</code>

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
2 ** 4     #=> 16
3 ^ 4      #=> 81
-2 ^ 2 ^ 3 #=> -256
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
Math.pow(2, 4);
Math.pow(3, 4);
-Math.pow(2, Math.pow(2, 3));
</pre>
        </div>
      </div>

      <p>Increments and decrements:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

n = 0
n++ #=> 0
++n #=> 2
n-- #=> 2
--n #=> 0
x = n++ #=> 0
x #=> 0
n #=> 1
x = ++n #=> 2
x #=> 2
n #=> 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var n, x;
n = 0;
n++;
++n;
n--;
--n;
x = n++;
x;
n;
x = ++n;
x;
n;
</pre>
        </div>
      </div>

      <p>Bitwise and shift operators:


      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
14 .&. 9   #=> 8
14 .|. 9   #=> 15
14 .^. 9   #=> 7
~9         #=> -10
9  .<<. 2  #=> 36
-9 .>>. 2  #=> -3
-9 .>>>. 2 #=> 1073741821
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
14 & 9;
14 | 9;
14 ^ 9;
~9;
9 << 2;
-9 >> 2;
-9 >>> 2;
</pre>
        </div>
      </div>

      <p>Casting to a number:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
+'4' #=>  4
-'3' #=> -3
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
+'4';
-'3';
</pre>
        </div>
      </div>

      <h3>Comparison</h3>

      <p>Strict equality (no type coercion):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
2 + 4 == 6      #=> true
\boom is 'boom' #=> true

\boom != null   #=> true
2 + 2 is not 4  #=> false
0 + 1 isnt 1    #=> false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
2 + 4 === 6;
'boom' === 'boom';

'boom' !== null;
2 + 2 !== 4;
0 + 1 !== 1;
</pre>
        </div>
      </div>

      <p>Fuzzy equality (with type coercion):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
2 ~= '2'       #=> true
\1 !~= 1       #=> false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
2 == '2';
'1' != 1;
</pre>
        </div>
      </div>

      <p>Greater/less than:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
2 < 4           #=> true
9 > 7           #=> true
8 <= 8          #=> true
7 >= 8          #=> false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
2 < 4;
9 > 7;
8 <= 8;
7 >= 8;
</pre>
        </div>
      </div>

      <p>Chained comparison:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

1 < 2 < 4        #=> true
1 < 2 == 4/2 > 0 #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$;
1 < 2 && 2 < 4;
1 < 2 && 2 === (ref$ = 4 / 2) && ref$ > 0;
</pre>
        </div>
      </div>

      <p>Minimum/maximum - returns the smaller/larger of the two operands.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

4 >? 8     #=> 8
9 - 5 &lt;? 6 #=> 4
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$;
4 > 8 ? 4 : 8;
(ref$ = 9 - 5) < 6 ? ref$ : 6;
</pre>
        </div>
      </div>

      <p>When one of the operands of a equals (<code>==</code> or <code>is</code>, and the negatives for that) is a regex literal if will test the other operand against it. Equality compiles to <code>exec</code> so you can use the results, while the negative simply compiles to <code>test</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
/^e(.*)/ is 'enter' #=> ["enter","nter"]
/^e(.*)/ == 'zx'    #=> null
/moo/ != 'loo'      #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
/^e(.*)/.exec('enter');
/^e(.*)/.exec('zx');
!/moo/.test('loo');
</pre>
        </div>
      </div>


      <h3>Logic</h3>

      <p>The basics:</p>

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
true and false #=> false
true && false  #=> false

true or false  #=> true
true || false  #=> true

not false      #=> true
!false         #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
true && false;
true && false;

true || false;
true || false;

!false;
!false;
</pre>
        </div>
      </div>

      <p>A logical operator not commonly seen in other languages - exclusive or:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
false xor true  #=> true
false xor false #=> false
1 xor 0         #=> 1
1 xor 1         #=> false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
((true, false) || true) && !(false && true) && (false || true);
((false, false) || false) && !(false && false) && (false || false);
((0, 1) || 0) && !(1 && 0) && (1 || 0);
((1, 1) || 1) && !(1 && 1) && (1 || 1);
</pre>
        </div>
      </div>

      <p><code>and</code>, <code>or</code>, and <code>xor</code> close implicit calls, while <code>||</code> and <code>&amp;&amp;</code> do not.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
even 0 and 3 #=> 3
even 0 &&  3 #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
even(0) && 3;
even(0 && 3);
</pre>
        </div>
      </div>

      <p>You can call logic operators.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
(f or g) 1
(f and g or h) 3 4
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
f(1) || g(1);
f(3, 4) && g(3, 4) || h(3, 4);
</pre>
        </div>
      </div>

      <h3>In/Of</h3>

      <p>Use <code>in</code> to check if and element is in a list; use <code>of</code> to check if a key is in an object.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

list = [7 8 9]
2 in [1 2 3 4 5]             #=> true
3 in list                    #=> false
\id of id: 23, name: \rogers #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var list;
list = [7, 8, 9];
2 == 1 || 2 == 2 || 2 == 3 || 2 == 4 || 2 == 5;
in$(3, list);
'id' in {
  id: 23,
  name: 'rogers'
};
function in$(x, arr){
  var i = 0, l = arr.length >>> 0;
  while (i < l) if (x === arr[i++]) return true;
  return false;
}
</pre>
        </div>
      </div>

      <a name="piping"></a>
      <h3>Piping</h3>

      <p>Instead of a series of nested function calls, you can pipe values in. <code>x |> f</code> and <code>f <| x</code> are equivalent to <code>f(x)</code>.


      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[1 2 3] |> reverse |> head #=> 3


reverse <| [1 2 3]         #=> [3,2,1]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
head(
reverse(
[1, 2, 3]));
reverse([1, 2, 3]);
</pre>
        </div>
      </div>

      <p>You can use newlines to space things out better.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
4
|> (+ 1)
|> even
#=> false
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
even(
(function(it){
  return it + 1;
})(
4));
</pre>
        </div>
      </div>

      <a name="composing"></a>
      <h3>Function</h3>

      <p>Composing allows you to create functions by <em>composing</em> them out of a series of functions. LiveScript has two operators for composing, forward <code>&gt;&gt;</code> and backwards <code>&lt;&lt;</code>.

      <p><code>(f &lt;&lt; g) x</code> is equivalent to <code>f(g(x))</code>, and <code>(f &gt;&gt; g) x</code> is equivalent to <code>g(f(x))</code>. For example:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

odd     = (not) << even
odd 3   #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var odd;
odd = compose$([not$, even]);
odd(3);
function compose$(fs){
  return function(){
    var i, args = arguments;
    for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }
    return args[0];
  };
}
function not$(x){ return !x; }
</pre>
        </div>
      </div>

      <p>To be a bit more clear about the difference between the two operators:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add-two-times-two = (+ 2) >> (* 2)
times-two-add-two = (+ 2) << (* 2)

add-two-times-two 3 #=> 10
times-two-add-two 3 #=> 8
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var addTwoTimesTwo, timesTwoAddTwo;
addTwoTimesTwo = compose$([
  (function(it){
    return it * 2;
  }), (function(it){
    return it + 2;
  })
]);
timesTwoAddTwo = compose$([
  (function(it){
    return it + 2;
  }), (function(it){
    return it * 2;
  })
]);
addTwoTimesTwo(3);
timesTwoAddTwo(3);
function compose$(fs){
  return function(){
    var i, args = arguments;
    for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }
    return args[0];
  };
}
</pre>
        </div>
      </div>

      <p>You can use a spaced dot as an alias to <code>&lt;&lt;</code>, for example <code>f . g</code>, just as in Haskell.

      <h3>List</h3>

      <p>You can concatenate two lists together:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
<[ one two three ]> +++ [\four]
#=> ['one','two','three','four']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
['one', 'two', 'three'].concat(['four']);


</pre>
        </div>
      </div>

      <p>List repetition when first is list literal:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[\ha] * 3 #=> ['ha','ha','ha']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
['ha', 'ha', 'ha'];
</pre>
        </div>
      </div>

      <p>Join when the right operand is a string literal:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
<[ one two three ]> * \|      #=> 'one|two|three'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
['one', 'two', 'three'].join('|');
</pre>
        </div>
      </div>

      <p>Unary spread - when the operand is a list literal, apply the unary op to each item:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

r = -[4 5 6]  #=> [-4,-5,-6]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var r;
r = [-4, -5, -6];
</pre>
        </div>
      </div>

      <h3>String</h3>

      <p>String concatenation:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
'hello' + ' ' + 'world' #=> 'hello world'
string = 'say '         #=> 'say '
string += \yeah         #=> 'say yeah'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var string;
'hello' + ' ' + 'world';
string = 'say ';
string += 'yeah';
</pre>
        </div>
      </div>

      <p>String repetition when the first operand is a string literal:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
'X' * 3      #=> 'XXX'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
'XXX';
</pre>
        </div>
      </div>

      <p>String subtraction/division when the right operand is a string or regex literal - subtraction means <code>replace</code>, division is <code>split</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
'say yeah' - /h/ #=> 'say yea'
'say yeah' / \y  #=> ['sa',' ','eah']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
'say yeah'.replace(/h/, '');
'say yeah'.split('y');
</pre>
        </div>
      </div>

      <h3>Existence/Inexistence</h3>

      <p>The <code>?</code> operator can be used in a variety of context to check for existence. The <code>!?</code> is its companion - checking for inexistence.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
bigfoot ? 'grizzly bear'     #=> 'grizzly bear'
string = \boom if window?    #=> 'boom'
string = 'yeah' if bigfoot!? #=> 'yeah'
document?.host               #=> 'gkz.github.com'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var string;
(typeof bigfoot == 'undefined' || bigfoot === null) && 'grizzly bear';
if (typeof window != 'undefined' && window !== null) {
  string = 'boom';
}
if (typeof bigfoot == 'undefined' || bigfoot === null) {
  string = 'yeah';
}
if (typeof document != 'undefined' && document !== null) {
  document.host;
}
</pre>
        </div>
      </div>

      <h3>Object</h3>

      <p>Instanceof - list literals to the right get expanded:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

new Date() instanceof Date           #=> true
new Date() instanceof [Date, Object] #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$;
new Date() instanceof Date;
(ref$ = new Date()) instanceof Date || ref$ instanceof Object;
</pre>
        </div>
      </div>

      <p>Typeof - add a bang for a useful alternative:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

typeof /^/  #=> object
typeof! /^/ #=> RegEx
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var toString$ = {}.toString;
typeof /^/;
toString$.call(/^/).slice(8, -1);
</pre>
        </div>
      </div>

      <p>Delete returns the value of the deleted item:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = {one: 1, two: 2}
r = delete obj.one
r #=> 1
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj, r;
obj = {
  one: 1,
  two: 2
};
r = obj.one, delete obj.one;
r;
</pre>
        </div>
      </div>

      <p>Property copy - copy enumerable properties from right to left, and evaluate to the left. <code>&lt;&lt;&lt;</code> for own properties, <code>&lt;&lt;&lt;&lt;</code> for all properties. <code>import</code> and <code>importAll</code> are aliases for the two respectively. If you leave out the left operand, <code>this</code> is presumed.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = {one: 1, two: 2}
obj <<< three: 3 #=> {two: 2, three: 3}
{go: true} <<<< window
import obj
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj;
obj = {
  one: 1,
  two: 2
};
obj.three = 3;
importAll$({
  go: true
}, window);
import$(this, obj);
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
</pre>
        </div>
      </div>

      <p>Clone - creates a prototypical clone of the operand. Ie. the resulting object's prototype is the operand.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = {one: 1}
obj2 = ^^obj
obj2.two = 2
obj2 #=> {one: 1, two: 2}
obj  #=> {one: 1}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj, obj2;
obj = {
  one: 1
};
obj2 = clone$(obj);
obj2.two = 2;
obj2;
obj2.one;
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
</pre>
        </div>
      </div>

      <p>The infix <em>with</em> (aka the <em>cloneport</em>) combines the clone and property copy operators for easy object creation. It is equivalent to <code>^^obj &lt;&lt;&lt; obj2</code>

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
girl = {name: \hanna, age: 22}
guy  = girl with name: \john
guy  #=> {name: 'john',  age: 22}
girl #=> {name: 'hanna', age: 22}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var girl, ref$, guy;
girl = {
  name: 'hanna',
  age: 22
};
guy = (ref$ = clone$(girl), ref$.name = 'john', ref$);
guy;
guy.age;
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
</pre>
        </div>
      </div>

      <h3>Partial Application, Operators as Functions</h3>

      <p>You can partially apply operators and use them as functions

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
(+ 2) 4         #=> 6
(*) 4 3         #=> 12

(not) true      #=> false
(in [1 to 3]) 2 #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
(function(it){
  return it + 2;
})(4);
curry$(function(x$, y$){
  return x$ * y$;
})(4, 3);
not$(true);
(function(it){
  return it == 1 || it == 2 || it == 3;
})(2);
function curry$(f, args){
  return f.length > 1 ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length && arguments.length ?
      curry$.call(this, f, params) : f.apply(this, params);
  } : f;
}
function not$(x){ return !x; }
</pre>
        </div>
      </div>

    </div>

    <div id="functions" class="section">
      <a name="functions"></a>
      <h2>Functions</h2>

      <p>Defining functions is very lightweight in LiveScript:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

(x, y) -> x + y


-> # an empty function

times = (x, y) ->
  x * y
# multiple lines, and be assigned to
# a var like in JavaScript
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var times;
(function(x, y){
  return x + y;
});
(function(){});

times = function(x, y){
  return x * y;
};
</pre>
        </div>
      </div>

      <p>As you see, function definitions are considerably shorter! You may also have noticed that we have omitted <code>return</code>. In LiveScript, almost everything is an expression and the last one reached is automatically returned.

      <p>You can prepend the function definition with a bang <code>!</code> to suppress automatic returning. The <code>!</code> must go before the entire function literal.


      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
f = !-> 2
g = !(x) -> x + 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var f, g;
f = function(){
  2;
};
g = function(x){
  x + 2;
};
</pre>
        </div>
      </div>

      <h3>Calling</h3>

      <p>You can omit the parentheses when calling a function, and you can omit the comma separating the arguments if the preceding item is not callable, just like in arrays.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

x = 4
Math.pow x, 3 #=> 64
Math.pow 2 3  #=> 8
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 4;
Math.pow(x, 3);
Math.pow(2, 3);
</pre>
        </div>
      </div>

      <p>If you are calling the function with no arguments, you can use a bang <code>!</code> - as well you don't need to use a dot when chaining banged functions.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
f!
[1 2 3].reverse!slice 1 #=> [2,1]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
f();
[1, 2, 3].reverse().slice(1);
</pre>
        </div>
      </div>

      <p><code>and</code>, <code>or</code>, <code>xor</code>, spaced <code>.</code>  or <code>?.</code> all close implicit calls - allowing for parentheses free chaining.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
$ \h1 .find \a .text! #=> LiveScript
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
$('h1').find('a').text();
</pre>
        </div>
      </div>

      <p>You can use <code>do</code> to call functions with no arguments:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
do -> 3 + 2 #=> 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
(function(){
  return 3 + 2;
})();
</pre>
        </div>
      </div>

      <p>You can also call functions infix using backticks <code>`</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add = (x, y) -> x + y
3 `add` 4 #=> 7
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var add;
add = function(x, y){
  return x + y;
};
add(3, 4);
</pre>
        </div>
      </div>

      <h3>Parameters</h3>

      <p>Extended parameters:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
set-person-params = (
  person # target object to set params
  person.age
  person.height
) -> person

person = set-person-params {}, 21, 180cm
#=> {age: 12, height: 180}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var setPersonParams, person;
setPersonParams = function(person, age, height){
  person.age = age;
  person.height = height;
  return person;
};
person = setPersonParams({}, 21, 180);
</pre>
        </div>
      </div>

      <p>This is especially useful with <code>this</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
set-text = (@text) -> this
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var setText;
setText = function(text){
  this.text = text;
  return this;
};
</pre>
        </div>
      </div>

      <p>You can set default arguments:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add = (x = 4, y = 3) -> x + y
add 1 2 #=> 3
add 1   #=> 4
add!    #=> 7
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var add;
add = function(x, y){
  x == null && (x = 4);
  y == null && (y = 3);
  return x + y;
};
add(1, 2);
</pre>
        </div>
      </div>

      <p>...or indeed use any logical operator (in parameters, <code>x = 2</code> is just sugar for doing <code>x ? 2</code>):

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add = (x && 4, y || 3) -> x + y
add 1 2 #=> 6
add 2 0 #=> 7
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var add;
add = function(x, y){
  x && (x = 4);
  y || (y = 3);
  return x + y;
};
add(1, 2);
add(2, 0);
</pre>
        </div>
      </div>

      <p>You can also destructure the arguments:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
set-cords = ({x, y}) -> "#x,#y"
set-cords y: 2, x: 3 #=> '3,2'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var setCords;
setCords = function(arg$){
  var x, y;
  x = arg$.x, y = arg$.y;
  return x + "," + y;
};
setCords({
  y: 2,
  x: 3
});
</pre>
        </div>
      </div>

      <p>...and even set defaults (or use any logic) on those destructured parameters, functioning like Python's keyword arguments.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
set-cords = ({x = 1, y = 3} = {}) -> "#x,#y"
set-cords y: 2, x: 3 #=> '3,2'
set-cords x: 2       #=> '2,3'
set-cords y: 7       #=> '1,7'
set-cords!           #=> '1,3'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var setCords;
setCords = function(arg$){
  var ref$, ref1$, x, y;
  ref$ = arg$ != null
    ? arg$
    : {}, x = (ref1$ = ref$.x) != null ? ref1$ : 1, y = (ref1$ = ref$.y) != null ? ref1$ : 3;
  return x + "," + y;
};
setCords({
  y: 2,
  x: 3
});
setCords({
  x: 2
});
setCords({
  y: 7
});
setCords();
</pre>
        </div>
      </div>

      <h3>Currying</h3>

      <p>Curried functions are very powerful. Essentially, when called with less arguments than defined with, they return a partially applied function. This means that it returns a function whose arguments are those which you didn't supply, with the values for what you did supply already bound. They are defined in LiveScript using the long arrow. Perhaps an example will make things more clear:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
times = (x, y) --> x * y
times 2, 3       #=> 6 (normal use works as expected)
double = times 2
double 5         #=> 10
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var times, double;
times = curry$(function(x, y){
  return x * y;
});
times(2, 3);
double = times(2);
double(5);
function curry$(f, args){
  return f.length > 1 ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length && arguments.length ?
      curry$.call(this, f, params) : f.apply(this, params);
  } : f;
}
</pre>
        </div>
      </div>

      <p>You can define bound curried functions with a long wavy arrow: <code>~~&gt;</code>

      <h3>Short Function Syntax</h3>

      <p>A shorter way to define functions, which are always curried:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
add(x, y) = x + y
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var add;
add = curry$(function(x, y){
  return x + y;
});
function curry$(f, args){
  return f.length > 1 ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length && arguments.length ?
      curry$.call(this, f, params) : f.apply(this, params);
  } : f;
}
</pre>
        </div>
      </div>

      <p>You can prepend the function definition with a <code>~</code> to make it bound.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
~set-x(val) =
  @x = val / 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var setX, this$ = this;
setX = curry$(function(val){
  return this$.x = val / 2;
});
function curry$(f, args){
  return f.length > 1 ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length && arguments.length ?
      curry$.call(this, f, params) : f.apply(this, params);
  } : f;
}
</pre>
        </div>
      </div>

      <h3>Named Functions</h3>

      <p>You can create named functions whose definition is hoisted to the top of the scope - this is useful for defining utility functions at the end of the file instead of the top. Name functions are constants, and can't be redefined.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
util!  #=> 'available above declaration'
util2! #=> 2

function util
  'available above declaration'
function util2 then 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
util();
util2();
function util(){
  return 'available above declaration';
}
function util2(){
  return 2;
}
</pre>
        </div>
      </div>

      <p>You can prepend the function definition with a <code>~</code> to make it a bound function.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
~function add x, y
  @result = x + y
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var this$ = this;
function add(x, y){
  return this$.result = x + y;
}
</pre>
        </div>
      </div>

      <p>You can prepend it with a bang <code>!</code> to suppress returning.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
util! #=> nothing
!function util x then x
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
util();
function util(x){
  x;
}
</pre>
        </div>
      </div>

      <p>You can combine the <code>~</code> and <code>!</code> to make a bound non-returning function if you wish.

      <h3>Bound Functions</h3>

      <p>Defined using the wavy arrow <code>~&gt;</code>. Use the long wavy arrow for curried and bound functions <code>~~&gt;</code>. Prepend a <code>~</code> to named functions or the short function syntax to make them bound.

      <p>Bound functions have <code>this</code> lexically bound, not dynamically bound as normally. This means that it does not matter in which context they are called, the value of <code>this</code> in their body will always be the value of <code>this</code> where they were defined.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = new
  @x      = 10
  @normal = -> @x
  @bound  = ~> @x

obj2 = x: 5
obj2.normal = obj.normal
obj2.bound  = obj.bound

obj2.normal! #=> 5
obj2.bound!  #=> 10
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj, obj2;
obj = new function(){
  var this$ = this;
  this.x = 10;
  this.normal = function(){
    return this.x;
  };
  this.bound = function(){
    return this$.x;
  };
};
obj2 = {
  x: 5
};
obj2.normal = obj.normal;
obj2.bound = obj.bound;
obj2.normal();
obj2.bound();
</pre>
        </div>
      </div>

      <p>Check out the <a href="#oop">OOP</a> section for more on bound functions when used in classes.

      <h3>Let, Where, With</h3>

      <p><code>let</code> is short for <code>(function(a){...}.call(this, b))</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
let $ = jQuery
  $.isArray [] #=> true
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
(function($){
  $.isArray([]);
}.call(this, jQuery));
</pre>
        </div>
      </div>

      <p><code>where</code> is like <code>let</code>, but defined after the body. It also is slightly different in that it allows for nested variable declarations.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
result = x + y
       where x = 4,
             y = x + 1
       #=> 9
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var result;
result = (function(x, y){
  x = 4;
  y = x + 1;
  return x + y;
}.call(this, void 8, void 8));
</pre>
        </div>
      </div>

      <p><code>with</code> is short for <code>(function(){...}.call(x))</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
with document
  @title = 'LiveScript!'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
(function(){
  this.title = 'LiveScript!';
}.call(document));
</pre>
        </div>
      </div>

      <p>With new context:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

dog = new
  @name = \spot
  @mutt = true
#=> {name: 'spot', mutt: true}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var dog;
dog = new function(){
  this.name = 'spot';
  this.mutt = true;
};
</pre>
        </div>
      </div>

      <h3>Access/Call Function Shorthand</h3>

      <p>There are especially useful for higher order functions like map and filter.

      <p><code>(.prop)</code> is short for <code>(it) -> it.prop</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
map (.length), <[ hello there you ]>
#=> [5,5,3]

filter (.length < 4), <[ hello there you ]>
#=> ['you']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
map(function(it){
  return it.length;
}, ['hello', 'there', 'you']);
filter(function(it){
  return it.length < 4;
}, ['hello', 'there', 'you']);
</pre>
        </div>
      </div>

      <p>You can also use this to call methods:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
map (.join \|), [[1 2 3], [7 8 9]]
#=> ['1|2|3','7|8|9']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
map(function(it){
  return it.join('|');
}, [[1, 2, 3], [7, 8, 9]]);
</pre>
        </div>
      </div>

      <p><code>(obj.)</code> is short for <code>(it) -> obj[it]</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = one: 1, two: 2, three: 3
map (obj.), <[ one three ]>
#=> [1,3]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj;
obj = {
  one: 1,
  two: 2,
  three: 3
};
map(function(it){
  return obj[it];
}, ['one', 'three']);
</pre>
        </div>
      </div>

      <h3>Backcalls</h3>

      <p>Backcalls are very useful. They allow you to unnest callbacks. They are defined using arrows pointed to the left. All the syntax is the same as regular arrows for defining bound functions (<code><~</code>), curried functions (<code><--, <~~</code>), suppressing return (<code><-!</code>) - except that it is just pointing the other way.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
<- $
alert \boom
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
$(function(){
  return alert('boom');
});
</pre>
        </div>
      </div>

      <p>They can take arguments, and you can specify a placeholder for where you want it to go.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x <- map _, [1 to 3]
x * 2
#=> [2, 4, 6]
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
map(function(x){
  return x * 2;
}, [1, 2, 3]);
</pre>
        </div>
      </div>

      <p>If you want further async functionality, you can use <a href="https://github.com/caolan/async/">async.js</a> with LiveScript.

      <h3>Partial Application</h3>

      <p>You can partially apply functions using the underscore <code>_</code> as a placeholder. Sometimes, the function you want to deal with isn't curried, or if it is the arguments are not in a good order. In these cases partial application is very useful. 

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

filter-nums = filter _, [1 to 5]
filter-nums even  #=> [2,4]
filter-nums odd   #=> [1,3,5]
filter-nums (< 3) #=> [1,2]
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var filterNums, slice$ = [].slice;
filterNums = partialize$(filter, [void 8, [1, 2, 3, 4, 5]], [0]);
filterNums(even);
filterNums(odd);
filterNums((function(it){
  return it < 3;
}));
function partialize$(f, args, where){
  return function(){
    var params = slice$.call(arguments), i,
        len = params.length, wlen = where.length,
        ta = args ? args.concat() : [], tw = where ? where.concat() : [];
    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
    return len < wlen && len ? partialize$(f, ta, tw) : f.apply(this, ta);
  };
}
</pre>
        </div>
      </div>

      <p>If you call a partially applied function with no arguments, it will execute as is instead of returning itself, allowing you to use default arguments.

      <p>Partially applied functions are also really useful for piping if the functions you are using don't have a nice argument order and aren't curried (like in underscore.js for instance).

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[1 2 3]
|> _.map _, (* 2)
|> _.reduce _, (+), 0
#=> 12
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var slice$ = [].slice;
partialize$(_.reduce, [
  void 8, curry$(function(x$, y$){
    return x$ + y$;
  }), 0
], [0])(
partialize$(_.map, [
  void 8, (function(it){
    return it * 2;
  })
], [0])(
[1, 2, 3]));
function partialize$(f, args, where){
  return function(){
    var params = slice$.call(arguments), i,
        len = params.length, wlen = where.length,
        ta = args ? args.concat() : [], tw = where ? where.concat() : [];
    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
    return len < wlen && len ? partialize$(f, ta, tw) : f.apply(this, ta);
  };
}
function curry$(f, args){
  return f.length > 1 ? function(){
    var params = args ? args.concat() : [];
    return params.push.apply(params, arguments) < f.length && arguments.length ?
      curry$.call(this, f, params) : f.apply(this, params);
  } : f;
}
</pre>
        </div>
      </div>

      <h3>Arguments</h3>

      <p>If you have only one argument, you can use <code>it</code> to access it without having to define an argument.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
f = -> it + 2
f 3 #=> 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var f;
f = function(it){
  return it + 2;
};
f(3);
</pre>
        </div>
      </div>

      <p>You can access the <code>arguments</code> object with the shorthand <code>&</code>. The first argument is <code>&0</code>, the second <code>&1</code>, and so on. <code>&</code> alone is <code>arguments</code> as a whole.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

add-three-numbers = -> &0 + &1 + &2
add-three-numbers 1 2 3 #=> 6
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var addThreeNumbers;
addThreeNumbers = function(){
  return arguments[0] + arguments[1] + arguments[2];
};
addThreeNumbers(1, 2, 3);
</pre>
        </div>
      </div>

      <p>Note that currying won't work in that situation, as the number of declared arguments in <code>add-three-numbers</code> is 0.

      <h3>More</h3>

      <p>Check out the section on <a href="#composing">composing functions</a>, and <a href="#piping">piping</a> as well.

    </div>

    <div id="if-unless" class="section">
      <a name="if-unless"></a>
      <h2>If and Unless</h2>

      <p>There are several ways to format an <code>if</code> statement. (Note that the <code>if</code> statement is actually an expression, and be used as such).

      <p>The standard:


      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
if 2 + 2 == 4
  'something'
else
  'something else'

if 2 + 2 == 4 then 'something' else 'something else'




if 2 + 2 == 4
then 'something'
else 'something else'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
if (2 + 2 === 4) {
  'something';
} else {
  'something else';
}
if (2 + 2 === 4) {
  'something';
} else {
  'something else';
}
if (2 + 2 === 4) {
  'something';
} else {
  'something else';
}
</pre>
        </div>
      </div>

      <p>The <code>else</code> is optional, and further <code>else if</code>s can be added.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
if 2 + 2 == 4
  'something'

if 2 + 2 == 6
  'something'
else if 2 + 2  == 5
  'something else'
else
  'the default'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
if (2 + 2 === 4) {
  'something';
}
if (2 + 2 === 6) {
  'something';
} else if (2 + 2 === 5) {
  'something else';
} else {
  'the default';
}
</pre>
        </div>
      </div>

      <p>It can be used as an expression:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
result = if 2 / 2 is 0
         then 'something'
         else 'something else'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var result;
result = 2 / 2 === 0 ? 'something' : 'something else';
</pre>
        </div>
      </div>

      <p>It can also be used postfix - it has a lower precedence than assignment, making this useful:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = 10
x = 3 if 2 + 2 == 4
x #=> 3
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 10;
if (2 + 2 === 4) {
  x = 3;
}
x;
</pre>
        </div>
      </div>

      <p><code>unless</code> is the equivalent to <code>if not</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

unless 2 + 2 == 5
  'something'

x = 10
x = 3 unless 2 + 2 == 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x;
if (2 + 2 !== 5) {
  'something';
}
x = 10;
if (2 + 2 !== 5) {
  x = 3;
}
</pre>
        </div>
      </div>

      <p><code>that</code> refers implicitly to the value of the condition. It will unwrap existence checks.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
time = days: 365



half-year = that / 2 if time.days
#=> 182.5

if /^e(.*)/ == 'enter'
  that.1   #=> 'nter'

if half-year?
  that * 2 #=> 365
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var time, that, halfYear;
time = {
  days: 365
};
if (that = time.days) {
  halfYear = that / 2;
}
if (that = /^e(.*)/.exec('enter')) {
  that[1];
}
if ((that = halfYear) != null) {
  that * 2;
}
</pre>
        </div>
      </div>

    </div>
    <div id="loops" class="section">
      <a name="loops"></a>
      <h2>Loops and Comprehensions</h2>

      <p><code>for</code> loops have the structure <code>for (from) (to|til) (by) (when)</code> - (everything is optional).
      <p><code>by</code> is the step value, the default is <code>1</code>.
      <p><code>from</code>, if omitted defaults to <code>0</code>.
      <p><code>when</code>, (alias <code>case</code>, <code>|</code>) is an optional guard.
      <p>Use <code>in</code> to iterate through lists, and <code>of</code> to iterate through objects.
      <p>If used as an expression, loops will produce a list.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

for i from 1 to 10 by 3
  i

for val, i in [7 8 9]
  val



for key, val of {one: 1, two: 2}
  key
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i, ref$, len$, val, key;
for (i = 1; i <= 10; i += 3) {
  i;
}
for (i = 0, len$ = (ref$ = [7, 8, 9]).length; i < len$; ++i) {
  val = ref$[i];
  val;
}
for (key in ref$ = {
  one: 1,
  two: 2
}) {
  val = ref$[key];
  key;
}
</pre>
        </div>
      </div>

      <p>List comprehensions always produce a list.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
r = [x + 1 for x to 10 by 2 when x isnt 4]
# r => [1,3,7,9,11]







r = ["#x#y" for x in [\a \b] for y in [1 2]]
# r => ['a1','a2','b1','b2']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var res$, x, r, i$, ref$, len$, j$, ref1$, len1$, y;
res$ = [];
for (x = 0; x <= 10; x += 2) {
  if (x !== 4) {
    res$.push(x + 1);
  }
}
r = res$;
res$ = [];
for (i$ = 0, len$ = (ref$ = ['a', 'b']).length; i$ < len$; ++i$) {
  x = ref$[i$];
  for (j$ = 0, len1$ = (ref1$ = [1, 2]).length; j$ < len1$; ++j$) {
    y = ref1$[j$];
    res$.push(x + "" + y);
  }
}
r = res$;
</pre>
        </div>
      </div>

      <p>Object comprehensions produce an object.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
r = {[key, val * 2] for key, val of {a: 1, b: 2}}
# r => {a: 2, b: 4}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var res$, key, ref$, val, r;
res$ = {};
for (key in ref$ = {
  a: 1,
  b: 2
}) {
  val = ref$[key];
  res$[key] = val * 2;
}
r = res$;
</pre>
        </div>
      </div>

      <p><code>while</code> loops:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

i = 0
list = [1 to 10]
while n < 9
  n = list[++i]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i, list, n;
i = 0;
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
while (n < 9) {
  n = list[++i];
}
</pre>
        </div>
      </div>

      <p><code>until</code> is equivalent to <code>while not</code>.

      <p><code>while</code>/<code>until</code> can also accept a <code>when</code> guard, and an optional <code>else</code> clause which runs if the didn't run at all.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

i = 1
list = [1 to 10]
until i > 7 when n isnt 99
  n = list[++i]
else
  10
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i, list, yet$, n;
i = 1;
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
for (yet$ = true; !(i > 7);) {
  yet$ = false;
  if (n !== 99) {
    n = list[++i];
  }
} if (yet$) {
  10;
}
</pre>
        </div>
      </div>

      <p>Do while:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

i = 0
list = [1 to 10]
do
  i++
while list[i] < 9 
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i, list;
i = 0;
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
do {
  i++;
} while (list[i] < 9);
</pre>
        </div>
      </div>

      <p>While can also accept an update clause.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

i = 0
list = [1 to 10]
while list[i] < 9, i++ then i
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i, list;
i = 0;
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
for (; list[i] < 9; i++) {
  i;
}
</pre>
        </div>
      </div>

      <p>While true:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

i = 0
loop
  \ha
  break if ++i > 20



i = 0
for ever
  \ha
  if ++i > 20
     break
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var i;
i = 0;
for (;;) {
  'ha';
  if (++i > 20) {
    break;
  }
}
i = 0;
for (;;) {
  'ha';
  if (++i > 20) {
    break;
  }
}
</pre>
        </div>
      </div>

    </div>

    <div id="switch" class="section">
      <a name="switch"></a>
      <h2>Switch</h2>

      <p><code>break</code> is automatically inserted, and multiple conditions are allowed.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
switch 6
case 1    then \hello
case 2, 4 then \boom
case 6
  'here it is'
default \something
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
switch (6) {
case 1:
  'hello';
  break;
case 2:
case 4:
  'boom';
  break;
case 6:
  'here it is';
  break;
default:
  'something';
}
</pre>
        </div>
      </div>

      <p>If you switch on nothing, you switch on true. (It compile to switching on false so it can cast the cases to booleans with one <code>!</code> instead of two.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
switch
case 5 == 6
  \never
case false
  'also never'
case 6 / 2 is 3
  'here'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
switch (false) {
case 5 !== 6:
  'never';
  break;
case !false:
  'also never';
  break;
case 6 / 2 !== 3:
  'here';
}
</pre>
        </div>
      </div>

      <p>You can use <code>fallthrough</code> to stop automatic <code>break</code> insertion. It must be the last expression of the case block. As well, you can use a switch statement as an expression.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
result = switch 6
case 6
  something = 5
  fallthrough
case 4
  'this is it'

result #=> 'this is it'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var something, result;
result = (function(){
  switch (6) {
  case 6:
    something = 5;
    // fallthrough
  case 4:
    return 'this is it';
  }
}());
result;
</pre>
        </div>
      </div>

      <p><code>|</code> is an alias for <code>case</code>, and <code>=&gt;</code> is an alias for <code>then</code>. <code>| otherwise</code> and <code>| _</code> are aliases for <code>default</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
switch 'moto'
| "some thing"     => \hello
| \explosion \bomb => \boom
| <[ the moto ? ]> => 'here it is'
| otherwise        => \something
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
switch ('moto') {
case "some thing":
  'hello';
  break;
case 'explosion':
case 'bomb':
  'boom';
  break;
case 'the':
case 'moto':
case '?':
  'here it is';
  break;
default:
  'something';
}
</pre>
        </div>
      </div>

      <p>An implicit <code>switch</code> is added after arrows (eg. <code>-></code>), <code>:</code>, and <code>=</code> if the next token is <code>case</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
func = (param) ->
  | param.length < 5 => param.length
  | otherwise        => param.slice 3

func 'hello' #=> lo





state = | 2 + 2 is 5 => 'I love Big Brother'
        | _          => 'I love Julia'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var func, state;
func = function(param){
  switch (false) {
  case !(param.length < 5):
    return param.length;
  default:
    return param.slice(3);
  }
};
func('hello');
state = (function(){
  switch (false) {
  case 2 + 2 !== 5:
    return 'I love Big Brother';
  default:
    return 'I love Julia';
  }
}());
</pre>
        </div>
      </div>

      <p>You can also use CoffeeScript style <code>switch</code> statements.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
day = \Sun
switch day
  when "Mon" then 'go to work'
  when "Tue" then 'go to a movie'
  when "Thu" then 'go drinking'
  when "Fri", "Sat"
      'go dancing'
  when "Sun" then 'drink more'
  else 'go to work'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var day;
day = 'Sun';
switch (day) {
case "Mon":
  'go to work';
  break;
case "Tue":
  'go to a movie';
  break;
case "Thu":
  'go drinking';
  break;
case "Fri":
case "Sat":
  'go dancing';
  break;
case "Sun":
  'drink more';
  break;
default:
  'go to work';
}
</pre>
        </div>
      </div>

    </div>


    <div id="assignment" class="section">
      <a name="assignment"></a>
      <h2>Assignment</h2>

      <p>Basic assignment is as you would expect, <code>variable = value</code>, and there is no need for variable declarations. However, unlike CoffeeScript, you must use <code>:=</code> to modify variables in upper scopes. 

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

x = 10


do ->
  x = 5

x #=> 10

do ->
  x := 2

x #=> 2
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 10;

(function(){
  var x;
  return x = 5;
})();
x;

(function(){
  return x = 2;
})();
x;
</pre>
        </div>
      </div>

      <p>Almost everything is an expression, which means you can do things like:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = if 2 + 2 == 4
    then 10
    else 0
x #=> 10
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = 2 + 2 === 4 ? 10 : 0;

x;
</pre>
        </div>
      </div>

      <p>Things such as loops, switch statements, and even try/catch statements are all expressions.

      <p>If you want to simply declare a variable and not initialize it, you can use <code>var</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
var x
</pre>
  </div>
  <div class="example-js">
<pre class="prettyprint lang-js">
var x;
</pre>
        </div>
      </div>

      <p>You can also declare constants in LiveScript using <code>const</code>. They are checked at compile time - the compiled JS is no different.

      <p>Attempting to compile the following:

<pre class="prettyprint lang-ls">
const x = 10
x = 0
</pre>

      <p>Results in <code>redeclaration of constant "x" on line 2</code>.

      <p>However, objects are not frozen if declared as constants - you can still modify their properties. You can force all variables to be constants if you compile with the <code>-k</code> or <code>--const</code> flags.

      <h3>Operators</h3>

      <p>Compound assignment:

      <p>(<code>?</code>, <code>!?</code>, <code>||</code>, or <code>&&</code> can prefix any compound assign.)

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

x = 2    #=> 2
x += 2   #=> 4
x -= 1   #=> 3
x *= 3   #=> 9
x /= 3   #=> 3
x %= 3   #=> 0
x %%= 3  #=> 0
x &lt;?= -1 #=> -1
x >?= 2  #=> 2
x **= 2  #=> 4
x ^= 2   #=> 16

x ?= 10
x        #=> 16
x !?= 8
x        #=> 8

x ||= 5  #=> 8
x &&= 5  #=> 5

x &&+= 3 #=> 8
x ?*= 2
x        #=> 8
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x, ref$;
x = 2;
x += 2;
x -= 1;
x *= 3;
x /= 3;
x %= 3;
x = ((x) % (ref$ = 3) + ref$) % ref$;
x <= (ref$ = -1) || (x = ref$);
x >= 2 || (x = 2);
x = Math.pow(x, 2);
x = Math.pow(x, 2);

x == null && (x = 10);
x;
x != null && (x = 8);
x;

x || (x = 5);
x && (x = 5);

x && (x += 3);
x == null && (x *= 2);
x;
</pre>
        </div>
      </div>

      <p>Unary Assignment:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

y = \45
+  = y   #=> 45   (make into number)
!! = y   #=> true (make into boolean)
-~-~ = y #=> 3    (int-coercing double crement)
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var y;
y = '45';
y = +y;
y = !!y;
y = -~-~y;
</pre>
        </div>
      </div>

      <p>Assignment defaults - you can use <code>||</code>, <code>&&</code>, <code>?</code>, and <code>!?</code>.

      <p>You can use <code>=</code> instead of <code>?</code> in function parameters.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x ? y = 10
y        #=> 10

f = (z = 7) -> z
f 9      #=> 9
f!       #=> 7
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var y, f;
(typeof x == 'undefined' || x === null) && (y = 10);
y;
f = function(z){
  z == null && (z = 7);
  return z;
};
f(9);
f();
</pre>
        </div>
      </div>

      <p>Soak assign - performs assign only if the right operand exists:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

age = 21
x? = age
x #=> 21


x? = years
x #=> 21
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var age, x;
age = 21;
if (age != null) {
  x = age;
}
x;
if (typeof years != 'undefined' && years !== null) {
  x = years;
}
x;
</pre>
        </div>
      </div>

      <h3>Destructuring</h3>

      <p>Destructuring is a powerful way to extract values from variables. Rather than assigning to a simple variable, you can assign to data structures, which extract the values. For example:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[first, second] = [1, 2]
first  #=> 1
second #=> 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$, first, second;
ref$ = [1, 2], first = ref$[0], second = ref$[1];
first;
second;
</pre>
        </div>
      </div>

      <p>You can also use splats:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

[head, ...tail] = [1 to 5]
head #=> 1
tail #=> [2,3,4,5]



[first, ...middle, last] = [1 to 5]
first  #=> 1
middle #=> [2,3,4]
last   #=> 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$, head, tail, first, i$, middle, last, slice$ = [].slice;
ref$ = [1, 2, 3, 4, 5], head = ref$[0], tail = slice$.call(ref$, 1);
head;
tail;
ref$ = [1, 2, 3, 4, 5], first = ref$[0], middle = 1 < (i$ = ref$.length - 1) ? slice$.call(ref$, 1, i$) : (i$ = 1, []), last = ref$[i$];
first;
middle;
last;
</pre>
        </div>
      </div>

      <p>...and objects too!

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

{name, age} = {weight: 110, name: 'emma', age: 20}
name #=> 'emma'
age  #=> 20
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$, name, age;
ref$ = {
  weight: 110,
  name: 'emma',
  age: 20
}, name = ref$.name, age = ref$.age;
name;
age;
</pre>
        </div>
      </div>

      <p>You can also name the entity which you are destructuring using <code>:label</code>, as well as arbitrarily nest the destructuring.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[[x, ...xs]:list1, [y, ...ys]:list2] = [[1,2,3],[4,5,6]]
x     #=> 1
xs    #=> [2,3]
list1 #=> [1,2,3]
y     #=> 4
ys    #=> [5,6]
list2 #=> [4,5,6]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var ref$, list1, x, xs, list2, y, ys, slice$ = [].slice;
ref$ = [[1, 2, 3], [4, 5, 6]], list1 = ref$[0], x = list1[0], xs = slice$.call(list1, 1), list2 = ref$[1], y = list2[0], ys = slice$.call(list2, 1);
x;
xs;
list1;
y;
ys;
list2;
</pre>
        </div>
      </div>

      <h3>Substructuring</h3>

      <p>Easily set properties of lists and objects.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
mitch =
  age:    21
  height: 180cm
  pets:    [\dog, \goldfish]


phile = {}
phile{height, pets} = mitch
phile.height #=> 180
phile.pets   #=> ['dog', 'goldfish']
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var mitch, phile;
mitch = {
  age: 21,
  height: 180,
  pets: ['dog', 'goldfish']
};
phile = {};
phile.height = mitch.height, phile.pets = mitch.pets;
phile.height;
phile.pets;
</pre>
        </div>
      </div>

    </div>


    <div id="property-access" class="section">
      <a name="property-access"></a>
      <h2>Property Access</h2>

      <p>The standard:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
[1 2 3][1]     #=> 2
{a: 1, b: 2}.b #=> 2
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
[1, 2, 3][1];
({
  a: 1,
  b: 2
}).b;
</pre>
        </div>
      </div>

      <p> Dot Access - dot operators can accept many more things other than identifiers as their right operand, including numbers, strings, parentheses, brackets, and braces.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = "hello world": [4 [5 boom: 6]]
x.'hello world'.1.[0] #=> 5
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x;
x = {
  "hello world": [
    4, [
      5, {
        boom: 6
      }
    ]
  ]
};
x['hello world'][1][0];
</pre>
        </div>
      </div>

      <p>Accessignment using <code>.=</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
document.title .= to-upper-case! #=> LIVESCRIPT ...
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
document.title = document.title.toUpperCase();
</pre>
        </div>
      </div>

      <p>Array slice and splice:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

list = [1 2 3 4 5]
list[2, 4]    #=> [3,5]
list[1 to 3]  #=> [2,3,4]
list[1 til 3] #=> [2,3]
list[1 til 3] = [7 8]
list          #=> [1,7,8,4,5]
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var list, ref$;
list = [1, 2, 3, 4, 5];
[list[2], list[4]];
[list[1], list[2], list[3]];
[list[1], list[2]];
ref$ = [7, 8], list[1] = ref$[0], list[2] = ref$[1];
list;
</pre>
        </div>
      </div>

      <p>Object slice:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
obj = one: 1, two: 2
obj{first: one, two} #=> {first: 1, two: 2}
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var obj;
obj = {
  one: 1,
  two: 2
};
({
  first: obj.one,
  two: obj.two
});
</pre>
        </div>
      </div>

      <p>Length star <code>*</code>.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
list = [1 2 3 4 5]
list[*] = 6
list        #=> [1,2,3,4,5,6]
list[*-1]   #=> 6
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var list;
list = [1, 2, 3, 4, 5];
list[list.length] = 6;
list;
list[list.length - 1];
</pre>
        </div>
      </div>

      <p> Semiautovivification <code>.@</code>, <code>.@@</code> ensures that the property exists as an object or as an array.

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">
x = "hello world": [4 [5 boom: 6]]
x.@@'hello world'.1.@1.boom #=> 6
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x, ref$;
x = {
  "hello world": [
    4, [
      5, {
        boom: 6
      }
    ]
  ]
};
((ref$ = (x['hello world'] || (x['hello world'] = []))[1])[1] || (ref$[1] = {})).boom;
</pre>
        </div>
      </div>

      <p>Cascade - beautiful chaining:

      <div class="example">
        <div class="example-ls">
<pre class="prettyprint lang-ls">

a = [2 7 1 8]
  ..push 3
  ..shift!
  ..sort!
a #=> [1,3,7,8]

document.query-selector \h1
  ..style
    ..color    = \red
    ..font-size = \large
  ..inner-HTML = 'LIVESCRIPT!'
</pre>
        </div>
        <div class="example-js">
<pre class="prettyprint lang-js">
var x$, a, y$;
x$ = a = [2, 7, 1, 8];
x$.push(3);
x$.shift();
x$.sort();
a;

x$ = document.querySelector('h1');
y$ = x$.style;
y$.color = 'red';
y$.fontSize = 'large';
x$.innerHTML = 'LIVESCRIPT!';
</pre>
        </div>
      </div>

    </div>


    <div id="oop" class="section">
      <a name="oop"></a>
      <h2>Object Oriented Programming</h2>
      <div class="example">
        <div class="example-ls">
          <h5>LiveScript</h5>
<pre class="prettyprint lang-ls">
class Item
  # constructor
  ->
    @id = Math.random!
    @x = 10

  @static = 'static'
  # properties and methods
  type: \unknown
  bound-to-instance: ~> @x

Renameable =
  set-name: -> @name = it
  get-name: -> @name ? @id

class Box extends Item implements Renameable
  (@name) ->
    super ...

  type: \cube

  # any code
  priv    = \secret
  @static = -> priv

thing = new Box \boxy
thing.get-name! #=> \boxy
thing.id       #=> (some random number)
thing.type     #=> 'cube'
thing.priv     #=> (nothing)
Box.static!    #=> 'secret'
Box::type = \block
thing.type     #=> 'block'

thing.bound-to-instance! #=> 10

# infix with - "cloneport"
thing2 = thing with name: \boxahoy
thing2.name           #=> 'boxahoy'
thing2.type           #=> 'block'
thing2 instanceof Box #=> true
</pre>
        </div>
        <div class="example-js">
          <h5>JavaScript</h5>
<pre class="prettyprint lang-js">
var Item, Renameable, Box, thing, ref$, thing2;
Item = (function(){
  Item.displayName = 'Item';
  var prototype = Item.prototype, constructor = Item;
  function Item(){
    this.boundToInstance = bind$(this, 'boundToInstance', prototype);
    this.id = Math.random();
    this.x = 10;
  }
  Item['static'] = 'static';
  prototype.type = 'unknown';
  prototype.boundToInstance = function(){
    return this.x;
  };
  return Item;
}());
Renameable = {
  setName: function(it){
    return this.name = it;
  },
  getName: function(){
    var ref$;
    return (ref$ = this.name) != null
      ? ref$
      : this.id;
  }
};
Box = (function(superclass){
  var priv, prototype = extend$((import$(Box, superclass).displayName = 'Box', Box), superclass).prototype, constructor = Box;
  importAll$(prototype, arguments[1]);
  function Box(name){
    this.name = name;
    superclass.apply(this, arguments);
  }
  prototype.type = 'cube';
  priv = 'secret';
  Box['static'] = function(){
    return priv;
  };
  return Box;
}(Item, Renameable));
thing = new Box('boxy');
thing.getName();
thing.id;
thing.type;
thing.priv;
Box['static']();
Box.prototype.type = 'block';
thing.type;
thing.boundToInstance();
thing2 = (ref$ = clone$(thing), ref$.name = 'boxahoy', ref$);
thing2.name;
thing2.type;
thing2 instanceof Box;
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
</pre>
        </div>
      </div>
    </div>
    <hr>
    <div class="section" id="coffee-to-ls">
      <a name="coffee-to-ls"></a>
      <h2>CoffeeScript to LiveScript Conversion Guide</h2>
      <ul>
        <li>Change all your fat arrows <code>=></code> to wavy arrows <code>~></code>
        <li>Change all your block comments <code>### ###</code> to <code>/* */</code>
        <li>Change any range syntax creating lists from <code>[x..y]</code> to <code>[x to y]</code> and change <code>[x...y]</code> to <code>[x til y]</code>
        <li>Similarly, change any range syntax in for loops from <code>for i in [x..y]</code> to <code>for i from x to y</code> and change <code>for i in [x...y]</code> to <code>for i from x til y</code>
        <li>Change any list comprehensions from <code>(x for x in list)</code> to <code>[x for x in list]</code>. Any postfix loops which you do not want returning a list, change to not postfixed, eg. change <code>increase x for x in list</code> to <code>for x in list then increase x</code>. You can shave characters if you wish by using the alias to <code>then</code>, the fat arrow <code>=></code>
        <li>Change any number literals starting with a dot, eg. <code>.5</code> to start with a zero <code>0.5</code>
        <li>Change any regular expression literals from <code>/// ///</code> to <code>// //</code>
        <li>Change any splats you are using from <code>(args...) -></code> to be prefixed like <code>(...args) -></code>
        <li>Remove the parentheses from function definitions with no parameters, <code>() -></code> simply becomes <code>-></code> - this is because <code>()</code> is always a call.
        <li>Change your constructor functions in your classes from being defined as 
<pre>
class Item
  constructor: ->
</pre> to simply being functions at the top level of your class body, eg.
<pre>
class Item
  -> 
</pre>
        <li>Change any calls to super from <code>super</code> to <code>super ...</code> - this is because <code>super</code> is a direct reference to the parent function rather than a call itself.
        <li>Change any bitwise operators to themselves surrounded by dots. Eg. <code>&amp;</code> is now <code>.&amp;.</code> and <code>&gt;&gt;</code> is now <code>.&gt;&gt;.</code>
        <li>If you are modifying variables in upper scopes at any time, eg.
<pre>
x = 10
do ->
  x = 5
</pre> you must use <code>:=</code> instead of just <code>=</code> as that will declare a new (shadowing) variable in LiveScript. Thus, the above code would need to be
<pre>
x = 10
do ->
  x := 5
</pre> if you wanted to modify <code>x</code>
      <li>If you are using nested list comprehensions (eg. <code>(x + y for x in [1, 2] for y in [3, 4])</code>, you will need to change how you handle the result as instead of being a lists within a list as in CoffeScript (the result of the example would be <code>[[4,5],[5,6]]</code>), the result is flattened (the result of the example in LiveScript would be <code>[4,5,5,6]</code>) 
      <li>Change the name of any of your variables named <code>it</code>, <code>that</code>, <code>fallthrough</code>, or <code>otherwise</code>. Those are terrible names for variables so you should change them anyway. This technically isn't required in all cases, but will be less confusing if you do so in all cases. <code>it</code> is used as the implicit argument of functions defined with no parameters, eg. <code>reverse = -> it.reverse!</code>. <code>that</code> refers to the value of the condition, for instance <code>that + 2 if (x + 10)/(y - 18)</code>, <code>that == (x + 10)/(y-18)</code>. <code>fallthrough</code>, if used at the end of a case block makes that block fallthrough to the next case. <code>otherwise</code>, if used directly after case, turns that case into default.
      <li>If you have any multiline strings non triple quoted strings (using <code>"string"</code> or <code>'string'</code>), eg.
<pre>
text = "hi 
        there"
</pre> you will have to change them as in CoffeeScript this would be <code>"hi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;there"</code> while LiveScript ignores indentation after newlines so it would be <code>"hi there"</code>
      <li><code>and</code>, <code>or</code> and spaced <code>.</code> and <code>?.</code> close implicit calls, so you will have to change any code involving those where you have depended on CoffeeScript to not close the call. Eg. <code>f a .g b or h c</code> would be <code>f(a.g(b || h(c)))</code> in CoffeeScript and <code>f(a).g(b) || h(c)</code> in LiveScript.
      <li>Change any <code>do</code>s special casing function literals to using <code>let</code>. Eg. in CoffeScript <code>do ($ = jQuery) -> $</code> change to
<pre>
let $ = jQuery
  $
</pre>
      <li>Change any implicit calls against blocks starting with an implicit objects to use <code>do</code>. Eg. change 
<pre>
f
  a: b
</pre> into
<pre>
f do
  a: b
</pre>
      <li>Remove any JavaScript code literals, eg. <code>`js code here`</code>. That functionality is no longer availible in LiveScript. Rewrite the code to use LiveScript instead. 
      <li>Change any dually spaced property access, eg. <code>x . y</code> to be either spaced on only one side or not at all. A dually spaced dot is now used to compose functions.
      <li>Change any non spaced identifier subtraction, eg. <code>a-b</code> to spaced <code>a - b</code>. <code>a-1</code> and <code>1-b</code> are still fine. This is because <code>a-b</code> is a valid identifier in LiveScript, equivalent to its camel case, <code>aB</code>.
      </ul>
    </div>
    <div id="speed" class="section">
      <a name="speed"></a>
      <h2>Speed</h2>
      <p>Harder, better, <strong>faster</strong>, stronger.
      <h5>CoffeeScript (1.3.1)</h5>
<pre>
$ cake bench
Lex     1365 ms (24146 tokens)
Rewrite  120 ms (26886 tokens)
Parse    277 ms
Compile  189 ms (149436 chars)
total   1951 ms
</pre>
      <h5>LiveScript</h5>
<pre>
$ slake bench
Lex      241 ms (27289 tokens)
Rewrite   98 ms (32717 tokens)
Parse    266 ms (27910 nodes)
Compile  246 ms (181132 chars)
TOTAL    851 ms
</pre>
      <p>For more improvements see <a href="https://github.com/satyr/coco/wiki/improvements">Coco's list of improvements</a>.
    </div>
    <div class="section" id="changes">
      <a name="changes"></a>
      <h2>Changes from Coco: Detail and Rationale</h2>
      <ul>
      <li>Renamed everything from Coco and Coke to LiveScript and Slake, and file extension from .co to .ls. Rationale for names chosen: LiveScript was the name of JavaScript before it was named JavaScript - thus it seemed like an appropriate name, also few if any other projects are named LiveScript. Slake because lake was taken and lsake sounds bad. 
      <li>Switched so that <code>==</code> compiles into <code>===</code>, and also for the negatives. Rationale: Most people would want to use the JavaScript <code>===</code> more often than <code>==</code> and less typing is better, also this makes things more similar to CoffeeScript which compiles <code>==</code> to <code>===</code> so there is less code for people to change coming from CoffeeScript. The compilation of <code>is</code> to <code>===</code> stays the same.
      <li>Switched <code>in</code> and <code>of</code> so that they are like in CoffeeScript. In goes over values, of over keys. Rationale: People have to change less of their CoffeeScript code, they're used to it, and using <code>in</code> for checking if a value is in an array just seems right, using <code>of</code> just feels weird.
      <li>All bitwise operators except <code>~</code> have changed to be surrounded by dots, eg. <code>&amp;</code> is now <code>.&amp;.</code> and <code>&gt;&gt;</code> is <code>.&gt;&gt;.</code>. Bitwise assign equals (eg. <code>&amp;=</code>) have been removed. Rationale: People rarely use the bitwise operators all the time, and they take up valuable symbols that could be used for other purposes. They are still available, just in a longer form. <code>~</code> is still there as is. 
      <li><code>=></code>, the pipe operator using <code>_</code>, is removed. Free up => (for <code>then</code> alias), (<code>|</code> is used as an alias for case). Use other pipes (<code>|></code>) and partial application instead.
      <li><code>|</code> is an alias for <code>case</code> (used in switch) Rationale: less typing, looks good. Modelled after Haskell's guards.
      <li><code>=></code> is an alias for <code>then</code>. Rationale: will not be encouraged for use in if statements as it looks slightly odd - really for use in switch statements, when combined with <code>|</code>, to create a succinct and easy to understand structure. Based off of Haskell's use of -> in case expressions.  
      <li>Added <code>otherwise</code> and underscore <code>_</code> as a contextual keyword, when used after <code>case</code> or <code>|</code>, making that the default statement. Rationale: same as in Haskell (otherwise), underscore as in Scala - and shorter. It allows <code>| otherwise => 4 + 9</code>, which fits in with the rest of the structure.
      <li>Added implicit <code>switch</code> after <code>-></code>, <code>~></code>, <code>:</code>, or an assign when they are followed by case tokens (either <code>case</code> or <code>|</code>). Rationale: reduces typing and increases beauty in a common situation for using a switch, with no increase in ambiguity. 
      <li>Added list concat operator, <code>+++</code>. Eg. <code>xs +++ ys</code> is <code>xs.concat(ys)</code>. Rationale: less typing, more beautiful, inspired by the ++ function in Haskell (had to use 3 pluses in order to avoid ambiguity with increment operator.)
      <li><code>^</code> is now an alias to <code>**</code>, the power operator. Rationale: it was available, and is used in other languages. 
      <li>Power precedence is now proper, and the power operator has precedence over multiplication and division. It also has higher precedence than unary ops. Eg. 2*4^2 == 32, not 64 as in Coco. Also, -2^2 == -4. Rationale: math should work properly - this is how it's done in many languages including Haskell. 
      <li>Power operator is now right associative. eg. 2^2^3 == 2^(2^3) == 256. Rationale: follwing Haskell's and many other languages lead on this one.
      <li>Added magic auto curried functions, defined using <code>--></code> and <code>~~></code>. With this you can do <code>times = (x, y) --> x * y</code>, <code>timesTwo = times 2</code>, <code>timesTwo 4 #=> 8</code>. If you call a curried function with no arguments, it calls itself as is, instead of returning itself (you can just reference it if you want it itself). Rationale: more Haskell like, useful functionality. 
      <li>Added new function definition syntax, eg. <code>add(x, y) = x + y</code> == <code>add = (x, y) --> x + y</code>. You can also use it in object literals and class definitions eg. <code>add(x, y): x + y</code> == <code>add: (x, y) --> x + y</code>. You can also suppress return on both by starting with a bang, eg. <code>!nothingness(params) = true</code> will not return anything. As well you can have lexically bound this using <code>id@(param) = something</code> which is suger for <code>id = (param) ~~> something</code> (notice the wavy arrow). You can go crazy and do something like this if you wish: <code>@!func@! = something</code> which is a function assigned to this, which takes no parameters and returns nothing, while being lexically bound to this. All functions defined using this syntax are curried. Rationale: more beautiful, less typing, more Haskell like.
      <li>Added <code>obj ::= obj2</code> as alias to <code>obj::&lt;&lt;&lt;obj2</code>. Rationale: seems to be the intuitive behavior expected, looks cleaner.
      <li>Added <code>yes / on</code> as aliases to <code>true</code> and <code>no / off</code> as aliases to <code>false</code>. Added <code>undefined</code> as an alias to <code>void</code>, and aliased <code>isnt</code> to <code>is not</code>. Rationale: ease transition from CoffeeScript, which has all these features, to LiveScript. 
      <li>Added <code>when</code> as alias to <code>case</code> (and <code>|</code>). Rationale: ease transition from CoffeeScript. 
      <li>Allowed guards in loops using case statement, eg. <code>x for x from 1 to 10 when x % 2 is 0</code>. Rationale: ease transition from CoffeeScript and have guards in comprehensions like other languages (Haskell).
      <li>Added the use of <code>else</code> for default in switch. Rationale: ease transition from CoffeeScript.
      <li>Added <code>loop</code> as alias for <code>while true</code>. Rationale: ease transition from CoffeeScript. 
      <li>Added pipe operator <code>|></code> ala F#, <code>val |> func</code> is the same as <code>func(val)</code>. Very useful in combination with curried functions. Rationale: useful, as in F#.
      <li>Added backwards pipe operator <code><|</code> ala F#: <code>f <| x</code> is the same as <code>f x</code>. This is more useful than it looks, and can help you avoid parens. For instance for a definition of toCase that returns a function that either uppercases or lowercases a word, <code>toCase \up <| \hello</code> rather than <code>toCase(\up) \hello</code>. Rationale: useful as per above, as in F#.
      <li>Added function composition operators ala F#. <code>&gt;&gt;</code> and <code>&lt;&lt;</code>. <code>(f &gt;&gt; g) x</code> is <code>g(f(x))</code> and <code>(f &lt;&lt; g) x</code> is <code>f(g(x))</code>. Rationale: very useful, especially with curried functions. As in F# (and Haskell, there it's the dot operator).
      <li>Added <code>%%</code> operator (and corresponding <code>%%=</code> operator), <code>x %% y</code> is <code>(x % y + y) % y</code>. Eg. <code>-3 % 4 == -3; -3 %% 4 == 1</code>. Rationale: this is how the <code>%</code> op behaves in other languages such as Python and Ruby.
      <li>Changed number base format from <code>7r4</code> to <code>7~4</code>. This is because using <code>r</code> causes ambiguity with number comments. For instance, <code>36rpm</code> - is that the number <code>36</code> with the number comment <code>rpm</code> or is it <code>pm</code> base <code>36</code> (922). Also now accept any number as radix, so that a better error can be thrown when that radix is not 2-36. Rationale: fixes ambiguity.
      <li>Allowed expression in range syntax, eg. <code>[x to y/2]</code> instead of just number literals. This has the side effect of removing naked ranges, eg. <code>2 to 5</code> without enclosing brackets (for loops remain unchanged). Rationale: expressions in ranges are useful, much more than naked ranges which have really limited use. Also closer to CoffeeScript, easing transition again. 
      <li>Changed CLI to bare compilation so that defined variables are attached to global scope. Improved repl to continue when lines end with <code>-></code>, <code>~></code>, or <code>=</code>
      <li>Added list comprehensions (eg. <code>[x for x in list when x is \something]</code>) and removed postfix loops (eg. <code>something x for x in list</code>). Comprehensions always return a list. Nested list comprehensions behave properly, ie. the last for is the inner most loop. Rationale: following Haskell and Python. More consistent behavior. Easier to deal with in your head. More intuitive. 
      <li>Removed JS literals, eg. <code>`js code here`</code>. Rationale: it was unnecessary, and it freed up backticks.
      <li>Add infix function application, eg. <code>3 `add` 2</code>. Rationale: as in Haskell. This allows for partial application of their second argument, like operators eg. <code>(`times` 2)</code>.
      <li>Changed unary clone operator from <code>^</code> to <code>^^</code>. Rationale: disambiguate with partial application of power operator.
      <li>Added partial application of operators. Eg. <code>(+ 2)</code> returns a function which adds 2 to its argument. Also allowed is simply <code>(*)</code> which is a function which multiplies its two arguments. <code>(+x)</code> and <code>(-x)</code> still mean the application of those unary operators - the operator must be spaced to be the partial application of that operator. Using the length star <code>*</code> is no longer allowed within parens (sometimes used when setting dynamic keys), due to ambiguity with the partially applied multiplication operator. Rationale: awesome. As in Haskell.
      <li>Added unary operators as functions. Eg. you can use <code>(not)</code> as a function, compose it, etc. Rationale: very useful, as in Haskell.
      <li>Added <code>.</code> as alias to <code>&lt;&lt;</code> in composing functions. This disallows property access in the style of <code>x . y</code>. Rationale: as in Haskell. Dually spaced property access should never be used anyway. 
      <li>Added object comprehensions. Eg. <code>{[key, val * 2] for key, val of obj}</code> would return an object with all the values double of the original. The first part of the array literal gets translated into the key, the second part into the value. Rationale: very useful when dealing with objects. Can now map and filter objects back into objects.
      <li>Dashes are now supported in identifiers, they get converted into camel case. Eg. <code>get-room</code> is equivalent to <code>getRoom</code>, <code>encode-URI</code> is <code>encodeURI</code>. Rationale: enable different styles which other people may enjoy. As in the lisp family of languages. 
      <li>Added implicit call/lookup eg. <code>(.length)</code> is equivalent to <code>-> it.length</code> and <code>(.join \*)</code> is equivalent to <code>-> it.join \*</code>. <code>(obj.)</code> is <code>-> obj[it]</code>. Rationale: useful when mapping, filtering, etc. 
      <li>Added infix <code>with</code> operator ("cloneport"). Eg. <code>personA = personB with name: \alice</code> is equivalent to <code>personA = ^^personB &lt;&lt;&lt; name: \alice</code>. Ie. it clones the head and imports the tail into that new object. <code>personB</code> is unmodified. Rationale: really nice may to create new objects out of old ones.
      <li>Add partial application, <code>_</code> is the placeholder. Eg. <code>f = add-three-numbers 1, _, 3</code> then <code>f 2 #=> 6</code>. Can be multiple times, and like curried functions if called with no args will invoke, allowing use of default args. Rationale: really useful, for when function args aren't in a nice order so you can use a curried version.
      <li>Changed backcall <code>&lt;-</code> placeholder to underscore <code>_</code>. Rationale: fit in with partial application placeholder.
      <li>Changed <code>arguments</code> alias to <code>&</code>, removed <code>@@</code> as that alias. Eg. <code>-> &amp;0 + &amp;1</code>. Rationale: shorter - less typing.
      <li>Added <code>-d, --prelude</code> option for automatically adding prelude.ls. Rationale: make it easier to use prelude.ls.
      <li>Added <code>-k, --const</code> option for compiling as if all variables as constants. Rationale: some people coming from languages with all immutable values may find this nice.
      <li>Allowed arbitrary expressions in slicing syntax, eg. <code>list[1 to x]</code>. Rationale: useful.
      <li>Changed so that constructors are inherited. Rationale: useful, and more like in CoffeeScript.
      <li>Allowed empty class definitions, ie. with no block. Rationale: useful and more like CoffeeScript.
      <li>Bound methods are bound to the instance, not the class. Rationale: seems pretty useless to be bound to the class, so this is more useful. Also more like CoffeeScript.
      <li>Added function keyword arguments like in python. Rationale: useful.
      <li>Added a exclusive or <code>xor</code> operator. Rationale: logic completeness.
      <li>Binary logic is callable. Ratioanle: useful.
      <li>Allow splicing like in CoffeeScript. Rationale: easier transition, useful.
      <li>Overloaded equals when using regex to mean exec/test. Rationale: shorter.
      <li>Static functions are inherited. Rationale: as in CoffeeScript - ease transition.
      <li>Removed the constructor shorthand. Rationale: rarely useful, use it for cascade instead.
      <li>Changed cascade op from <code>&</code> to <code>..</code>. Rationale: like in other languages.
      <li>Added match statement and deep compare. Rationale: experimental, will see if good.
      </ul>
    </div>
    <div id="changelog" class="section">
      <a name="changelog"></a>
      <h2>Changelog</h2>
      <h3>1.0.0</h3>
      <ul>
        <li>Nicer compilation for the compose op
        <li>The <code>--prelude</code>/<code>-d</code> flags work for the repl
        <li>New func syntax eg. <code>f(x) = x</code> now uses <code>~</code> for bound funcs, liked named funcs, eg. <code>~f(x) = x</code>
        <li>Removed no return option for new func syntax
        <li>Added function keyword arguments ala python, eg. <code>f = ({x = 2, y = 3}) -> x + y</code>, and then application with <code>f y: 4</code>
        <li>Removed overloading of <code>+</code> for list concatination (just use <code>+++</code>)
        <li>Readded bitwise compound assign, eg. <code>.&.=</code>
        <li>Added <code>where</code>, like <code>let</code> but comes after instead of before - also allows for nested assignments
        <li>Changed fuzzy equals (<code>==</code> in JS) to <code>~=</code>, <code>!~=</code> for the negation
        <li>Added <code>xor</code> operator, exclusive or - true if only one side or the other is true
        <li>Doing equals on a regex literal will compile to an exec, eg. <code>x == /[ae]/g</code> is <code>/[ae]/g.exec(x)</code> - you can use <code>that</code> to get the results if used in an if statement. The negation simply uses test.
        <li>Binary logic is callable, eg. <code>(f or g) x</code> is <code>f(x) || g(x)</code>
        <li>Allow splicing like in CoffeeScript, eg. <code>list[1 to x] = [1 2 3]</code>
        <li>Static functions are now inherited and support calls to <code>super</code>
        <li>Generated reference variables are now named with a <code>$</code> after them instead of <code>__</code> preceding. eg. <code>ref$</code> instead of <code>__ref</code>
        <li>Removed constructor shorthand, just use <code>constructor</code>
        <li>Added cascade op from coco <code>..</code>
        <li>Added deep compare, allows the comparison of objects, arrays, and more. <code>===</code> - experimental
        <li>Added <code>match</code> statement - experimental
      </ul>
      <h3>0.9.12</h3>
      <ul>
        <li>Changed bitwise/shift operator syntax to be more clear. Now simply as in JS, but surrounded by dots. Eg. <code>&</code> is <code>.&.</code>, and <code>&gt;&gt;</code> is <code>.&gt;&gt;.</code>
        <li>Speed improvements
        <li>Allowed arbitrary expressions in slicing syntax, eg. <code>list[1 to x]</code>
        <li>Made classes work more like in CoffeeScript - details:
        <li>Constructors are now inherited
        <li>Allowed empty class definitions, eg. <code>class A extends B</code>
        <li>Bound methods (eg. <code>f: ~></code>) are bound to the instance, not to the class
      </ul>
      <h3>0.9.11</h3>
      <ul>
        <li>Bug fixes
        <li>Updated to work with node 0.8.x
        <li>Added partial application of funcs using <code>_</code> placeholder
        <li>Added infix <code>with</code> "cloneport", clones head and imports tail into that
        <li>Allow partial application of pipe <code>|&gt;</code> and backpipe <code>&lt;|</code> and use as function
        <li>Better compilation of various operators-as-functions
        <li>Added existential soak implicit call/lookup, eg. <code>(?length)</code>
        <li>Allow partially applied assign - <code>=</code>, <code>+=</code>, etc.
        <li>Removed <code>|&gt;&gt;</code> pipe operator - use normal pipes and partial application now
        <li>Changed backcall placeholder to underscore <code>_</code>
        <li>Added underscore <code>_</code> as alias to <code>otherwise</code> in switch statements
        <li>Added <code>--prelude</code> or <code>-d</code> option to automatically include <a href="http://gkz.github.com/prelude-ls/">prelude.ls</a> in compiled files
        <li>Added <code>--const</code> or <code>-k</code> option to compile as if all variables are constants
        <li>Added partial application of property accessor eg. <code>(obj.)</code>
        <li>Removed cons <code>&</code> operator
        <li>Added <code>&</code> as alias to <code>arguments</code>, allowing <code>-> &0 + &1</code> etc. 
        <li>Removed <code>@@</code> as alias to <code>arguments</code>
        <li>Increased precedence of the pipe <code>|&gt;</code> operator to allow assignment of the entire thing without parens, not just of the first section
        <li>Added mixin feature <code>implements</code> thanks to Coco, eg. <code>class Cow extends Animal implements Mooer</code>, which does <code>::<<< Mooer</code> in the class body.
      </ul>
      <h3>0.9.10</h3>
      <ul>
        <li>Now have `const` and `var` thanks to Coco
        <li>Implicit access and call functions, eg. <code>(.length)</code> and <code>(.join \|)</code> - useful for mapping/filtering, etc.
        <li>Bug fixes
        <li>Improved repl
      </ul>
      <h3>0.9.9</h3>
      <ul>
        <li>Various bug fixes
        <li>Calling a curried funciton with no args calls it as is rather than returning itself
        <li>Allow partial application of second arg for infix functions
      </ul>
      <h3>0.9.8</h3>
      <ul>
        <li>Object comprehensions added
        <li>Dashes in identifiers allowed (transformed to camel case)
      </ul>
      <h3>0.9.7</h3>
      <ul>
        <li>Bug fixes
        <li>Precedence change of <code>&</code> and <code>+++</code>
        <li>Nicer pipe <code>|></code> compilation
      </ul>
      <h3>0.9.6</h3>
      <ul>
        <li>Partially applied operators
        <li>Operators as functions
      </ul>
      <h3>0.9.5</h3>
      <ul>
        <li>Infix function calls added
        <li>JS literals removed
        <li>Improved CLI
      </ul>
      <h3>0.9.4</h3>
      <ul>
        <li>Added proper list comprehensions
        <li>Removed post-fix loops
      </ul>
      <h3>0.9.3</h3>
      <ul>
        <li>Changed node requirements
      </ul>
      <h3>0.9.2</h3>
      <ul>
        <li>Improved CLI
        <li>Enabled expressions in range syntax
      </ul>
      <h3>0.9.1</h3>
      <ul>
        <li>Changed number radix symbol to <code>~</code>
        <li>Added <code>%%=</code>
      </ul>
      <h3>0.9.0</h3>
      <ul>
        <li>Initial public release, many changes. See <a href="#changes">Changes from Coco</a> for more details.
      </ul>
      <p>For more details see <a href="#changes">Changes from Coco</a>.
    </div>
    <hr>
    <div id="inspiration" class="section">
      <a name="inspiration"></a>
      <h2>Inspiration</h2>
        <ul>
          <li>Functional languages in general
          <li>Haskell
          <li>F#
        </ul>
    </div>
    <div id="name" class="section">
      <a name="name"></a>
      <h2>Name</h2>
        <p>LiveScript was one of the original names for JavaScript, so it seemed fitting. It's an inside joke for those who know JavaScript well.
    </div>
    <div id="thanks" class="section">
      <a name="thanks"></a>
      <h2>Thanks</h2>
      <p>You can find the full list of contributors <a href="https://github.com/gkz/LiveScript/graphs/contributors">here</a>. That list includes contributors to LiveScript and its predecessors. 
      <p>People who have contributed directly to LiveScript include <a href="https://github.com/gkz">George Zahariev</a>, <a href="https://github.com/satyr">Satoshi Murakami</a>, <a href="https://github.com/josher19">Joshua Weinstein</a>, <a href="https://github.com/goatslacker">Josh Perez</a>, and <a href="https://github.com/paulmillr">Paul Miller</a>.
      <p>An extra special thanks to Satoshi, as this project is a fork of his project <a href="https://github.com/satyr/coco">Coco</a> and would not be possible without it. It has been a pleasure to work off of his beautiful Coco compiler. 
    </div>
    <div id="contributing" class="section">
      <a name="contributing"></a>
      <h2>Contributing Guide</h2>
      <p>Fork <a href="https://github.com/gkz/LiveScript">LiveScript</a> and make your changes. Always write tests first (in the <code>/test</code> directory).
      <p>Run <code>bin/slake</code> to see available commands. Always make sure you can <code>bin/slake build:full</code> - ie. build the compiler itself. Useful: <code>git checkout -- lib && bin/slake build:full</code>: cleans out your <code>lib</code> and compiles twice and tests. Only send a pull requests if all tests pass. If you are hacking on the grammar, you will need to <code>git checkout -- lib && bin/slake build && bin/slake build:parser && bin/slake test</code>. Once all tests pass, rewrite any of the compiler that needs rewriting, and then <code>bin/slake build:full</code>.
      <p>Don't submit patches with a built browser file (<code>extras/livescript.js</code>) created by <code>bin/slake build:browser</code>. This file is only built before releasing a new version. 
    </div>
  </div>
</div>

<script type="text/ls">
  console?.log 'LiveScript up'
</script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>


<script src="bootstrap/js/bootstrap.js"></script>
<script src="bootstrap/js/bootstrap-scrollspy.js"></script>

<script src="google-code-prettify/prettify.js"></script>
<script src="lang-ls-1.0.0.js"></script>

<script src="underscore-min.js"></script>
<script src="prelude-browser-min-0.6.0.js"></script>
<script src="site.js"></script>

<script src="livescript-1.0.0.js"></script>
<script>
  document.getElementById("email").href = "mailto:z" + "@" + "georgezahariev.com";
</script>
</body>
</html>
