# REQUIRES ########################

require! {
  bach
  fs
  optionator
  'prelude-ls': { each, map }
}

# VARS ############################

options =
  * option: \browser
    alias: \b
    type: \Boolean
    description: 'Compile livescript.js and livescript.min.js'
  * option: \clean
    alias: \c
    type: \Boolean
    description: 'Remove lib, coverage and browser directories'
  * option: \coverage
    alias: \i
    type: \Boolean
    description: 'Run the coverage (with istanbul)'
  * option: \lib
    alias: \l
    type: \Boolean
    description: 'Compile the lib'
  * option: \package
    alias: \p
    type: \Boolean
    description: 'Generate the package.json'

# FUNCTIONS #######################

create-dir = (dir, cb) !-->
  console.log "creating the directory [ #dir ]"
  er <-! fs.mkdir dir
  if er? and er.code isnt \EEXIST then cb e, void
  else
    if er? and er.code is \EEXIST
      console.log "Directory [ #dir ] already exists"
    else console.log "Directory [ #dir ] CREATED"
    cb void 2

generic-cb = (err, ok) !-> if err? then console.log err

preroll = ->
  require! './package': {version}
  """// Generated by LiveScript #version\n
     // LiveScript #version
     // Copyright (c) Jeremy Ashkenas, Satoshi Murakami, George Zahariev
     // Released under the MIT License
     // https://raw.githubusercontent.com/gkz/LiveScript/master/LICENSE\n
  """

# CORE ############################

try
  op = optionator {options}
  opts = op.parseArgv process.argv
  switch
    # compiling into browser directory #########################################
    | opts.browser
      require! {browserify, 'uglify-js':{minify}}
      # function to compile into livescript.js
      compile-ls = (cb) !->
        console.log 'Compiling for livescript.js ...'
        b = browserify \./lib/browser.js, {require: \./lib/browser.js}
        (err, buf) <- b.bundle!
        if err? then cb e, void
        else
          try
            fs.writeFileSync \./browser/livescript.js, (preroll! ++ buf)
            console.log '==> livescript.js COMPILED'
            cb void 3
          catch
            cb e, void
      # uglifying livescript.js into livescript.min.js
      uglifying = (cb) !->
        console.log 'Uglifying into livescript-min.js...'
        try
          code = fs.readFileSync \./browser/livescript.js, \utf-8
          res = minify code, output: {comments: yes}
          if res.error? then cb e, void
          else
            if res.warnings?
              console.log '====> UGLIFY WARNINGS <====='
              JSON.stringify res.warnings |> console.log
            fs.writeFileSync \./browser/livescript-min.js, res.code
            console.log '==> livescript-min.js UGLIFIED'
            cb void 4
        catch
          cb e, void
      # list of all actions done to compile into browser
      actions =
        create-dir \browser
        compile-ls
        uglifying
      # compiling and uglifying
      (bach.series actions) generic-cb
    # cleaning the repository (removing coverage, lib and browser) #############
    | opts.clean
      rmd = (dir) -> (cb) !->
        console.log "removing `#dir`"
        fs.rm dir, {force: yes, recursive: yes}, cb
      args = <[browser lib coverage]> |> map rmd
      (bach.series args) (err, ok) !->
        console.log if err? then err else 'dirs removed'
    # Executing istanbul #######################################################
    | opts.coverage
      require! { child_process: {spawn} }
      istanbul =
        if process.platform is \win32 then 'node_modules\\.bin\\istanbul.cmd'
        else 'node_modules/.bin/istanbul'
      opts = stdio: [process.stdin, process.stdout, process.stderr]
      spawn istanbul, ['cover', './scripts/test'], opts
    # compiling the lib ########################################################
    | opts.lib
      # generating the parser
      generate-grammar = (cb) !->
        console.log 'Generating parser...'
        require! { path: {resolve, dirname}, '.': {compile}, './lib/grammar' }
        target = resolve dirname(module.filename), \./lib/parser.js
        try
          parser = grammar.generate!
          fs.writeFileSync target, parser ++ '\n'
          console.log '==> parser GENERATED'
          cb void 2
        catch
          cb e, void
      # compiling files from src to lib
      compile-lib = (cb) !->
        require! '.': {compile}
        try
          mapper = (file) !->
            console.log "compiling '#file'..."
            code = fs.readFileSync "./src/#file", \utf-8
            res = compile code, {bare: yes}
            fs.writeFileSync "./lib/#{file.split \. .0}.js", res
          fs.readdirSync \./src |> each mapper
        catch
          cb e, void
      # doing all actions relative to lib
      actions =
        create-dir \lib
        generate-grammar
        compile-lib
      (bach.series actions) generic-cb
    # generating the package.json ##############################################
    | opts.package
      require! '.': {compile}
      pkg = fs.readFileSync \./package.json.ls, \utf-8
      res = compile pkg, json: yes
      fs.writeFileSync \./package.json, res
      console.log 'package.json (re)generated'
    # Help #####################################################################
    | otherwise => console.log op.generateHelp!
catch
  console.log e
