require! {
  '..': LiveScript
  path
  fs
  util
  'prelude-ls': {each, break-list}:prelude
  './options': {parse: parse-options, generate-help}
}

version = LiveScript.VERSION

say = console.log
warn = console.error
die = (message) !->
  console.error message
  process.exit 1
p = (...args) !->
  each console.dir, args
pp = (x, show-hidden, depth) !->
  say util.inspect x, show-hidden, depth, !process.env.NODE_DISABLE_COLORS
ppp = !-> pp it, true, null

try
  o = parse-options process.argv
  positional = o._
catch
  console.error e.message
  process.exit 1

switch
| o.nodejs  => fork-node!
| o.version => say "LiveScript version #version"
| o.help    => say generate-help interpolate: {version}
| otherwise =>
  o.run = not o.compile ||= o.output

  switch
  | o.eval =>
    compile-script '' o.eval
  | o.stdin =>
    compile-stdin!
  | positional.length =>
    compile-scripts!
  | require 'tty' .isatty 0 =>
    say "LiveScript #version - use 'lsc --help' for more information"
    repl!
  | otherwise =>
    compile-stdin!

# Calls a `fs` method, exiting on error.
!function fshoot name, arg, callback
  e, result <-! fs[name] arg
  die e.stack || e if e
  callback result

# Asynchronously read in each LiveScript script in a list of source files and
# compile them. If a directory is passed, recursively compile all
# _.ls_ files in it and all subdirectories.
!function compile-scripts
  positional.for-each !-> walk it, (path.normalize it), true
  !function walk source, base, top
    !function work
      fshoot 'readFile' source, !-> compile-script source, "#it", base
    e, stats <-! fs.stat source
    if e
      die "Can't find: #source" if not top or /(?:\.ls|\/)$/test source
      walk "#source.ls" base
      return
    if stats.is-directory!
      unless o.run
        fshoot 'readdir' source, !-> it.for-each !-> walk "#source/#it" base
        return
      source += '/index.ls'
    if top or '.ls' is source.slice -3
      if o.watch then watch source, work else work!

# Compile a single source script, containing the given code, according to the
# requested options.
!function compile-script filename, input, base
  options = {filename, o.bare, o.const}
  t       = {input, options}
  try
    LiveScript.emit 'lex' t
    t.tokens = LiveScript.tokens t.input, raw: o.lex
    if o.lex or o.tokens
      print-tokens t.tokens
      throw
    LiveScript.emit 'parse' t
    t.ast = LiveScript.ast t.tokens
    json = o.json or /\.json\.ls$/.test filename
    if o.ast
      say if json then t.ast.stringify 2 else ''.trim.call t.ast
      throw
    LiveScript.emit 'compile' t
    options.bare ||= json or o.run
    t.ast.make-return! if json or o.run and o.print
    t.output = t.ast.compile-root options
    t.output = "// Generated by LiveScript #version\n#{t.output}" if o.compile and o.header
    if json or o.run
      LiveScript.emit 'run' t
      t.result = LiveScript.run t.output, options, true
    if json
      t.output = JSON.stringify(t.result, null, 2) + '\n'
    if o.run
      switch
      | json  => process.stdout.write t.output
      | o.print => console.log t.result
      throw
    LiveScript.emit 'write' t
    if o.print or not filename
    then say t.output.trim-right!
    else write-JS filename, t.output, base, json
  catch then if e?
    if LiveScript.listeners 'failure' .length
      LiveScript.emit 'failure' e, t
    else
      warn "Failed at: #filename" if filename
      unless e instanceof SyntaxError or /^Parse error /test e.message
        e = e.stack or e
      if o.watch then warn e + '\7'
                 else die  e
    return
  LiveScript.emit 'success' t

# Attach the appropriate listeners to compile scripts incoming over **stdin**.
!function compile-stdin
  process.open-stdin!
    code = ''
    ..on 'data' !-> code += it
    ..on 'end'  !-> compile-script '' code
    ..on 'data' !->
      # Detect trailing __^D__ or __^Z__ for Windows.
      if (code.slice -3) in <[ \4\r\n \x1a\r\n ]>
        compile-script '' code.slice 0 -3
        ..destroy!

# Watch a source LiveScript file using `setTimeout`, taking an `action` every
# time the file is updated.
!function watch source, action
  :repeat let ptime = 0
    {mtime} <-! fshoot 'stat' source
    do action if ptime .^. mtime
    set-timeout repeat, 500ms, mtime

# Write out a JavaScript source file with the compiled code. By default, files
# are written out in `cwd` as `.js` files with the same name, but the output
# directory can be customized with `--output`.
!function write-JS source, js, base, json
  #     foo.ls     => foo.js
  #     foo.jsm.ls => foo.jsm
  filename = path.basename(source)replace do
    /(?:(\.\w+)?\.\w+)?$/ -> &1 or if json then '.json' else '.js'
  dir = path.dirname source
  if o.output
    dir = path.join that, dir.slice if base is '.' then 0 else base.length
  js-path = path.join dir, filename
  !function compile
    e <-! fs.write-file js-path, js || '\n'
    return warn e if e
    util.log "#source => #js-path" if o.watch
  e <-! fs.stat dir
  return compile! unless e
  require 'child_process' .exec do
    "mkdir #{['-p' unless /^win/test process.platform]} #dir" compile

# Pretty-print a stream of tokens.
!function print-tokens tokens
  lines = []
  for [tag, val, lno] in tokens
    (lines[lno] ?= []).push if tag.to-lower-case! is val then tag else "#tag:#val"
  for l in lines
    say (if l then l.join ' ' .replace /\n/g '\\n' else '')

# A Read-Eval-Print-Loop.
# Good for simple tests or poking around the
# [**node.js** API](http://nodejs.org/api/).
#
# - __^M__: Compile input, and prints (if _--compile_) or evaluates it.
# - __^J__: Insert linefeed.
# - __^C__: Cancel input if any. Quit otherwise.
# - __??__: <https://github.com/joyent/node/blob/master/lib/readline.js>
!function repl
  code   = if repl.infunc then '  ' else ''
  cont   = 0
  rl     = require 'readline' .create-interface process.stdin, process.stdout
  reset  = !->
    rl.line = code := ''
    rl.prompt!
    repl.inheredoc = false
  ({_tty-write} = rl)._tty-write = (char) ->
    if char in ['\n' '>']
    then cont += 1
    else cont := 0
    _tty-write ...
  prompt = 'ls'
  prompt += " -#that" if 'b' * !!o.bare + 'c' * !!o.compile
  LiveScript.history = rl.history if LiveScript?
  unless o.compile
    module.paths = module.constructor._node-module-paths \
      module.filename = process.cwd! + '/repl'
    vm = require 'vm'
    global <<< prelude if o.prelude
    repl-ctx = {}
    repl-ctx <<< global
    repl-ctx <<< {module, exports, require}
    repl-ctx <<< {LiveScript, path, fs, util, say, warn, die, p, pp, ppp}
    server = require 'repl' .REPLServer:: with
      context: repl-ctx
      commands: []
      use-global: false
      use-colors: process.env.NODE_DISABLE_COLORS
      eval: !(code,ctx,, cb) ->
        try res = vm.run-in-new-context code, ctx, 'repl' catch
        cb e, res
    rl.completer = server~complete
  rl.on 'SIGCONT' rl.prompt
  rl.on 'SIGINT' !->
    if @line or code
      say ''
      reset!
    else @close!
  rl.on 'close' ->
    say ''
    process.exit!
  rl.on 'line' !->
    repl.infunc = false if it.match /^$/ # close with a blank line without spaces
    repl.infunc = true if it.match(/(\=|\~>|->|do|import|switch)\s*$/) or (it.match(/^!?(function|class|if|unless) /) and not it.match(/ then /))
    if (0 < cont < 3 or repl.infunc) and not repl.inheredoc
      code += it + '\n'
      @output.write '.' * prompt.length + '. '
      return
    else
      isheredoc = it.match /(\'\'\'|\"\"\")/g
      if isheredoc and isheredoc.length % 2 is 1 # odd number of matches
        repl.inheredoc = not repl.inheredoc
      if repl.inheredoc
        code += it + '\n'
        rl.output.write '.' * prompt.length + '" '
        return
    repl.inheredoc = false
    return reset! unless code += it
    try
      if o.compile
        say LiveScript.compile code, {o.bare}
      else
        ops = {'eval', +bare, save-scope:LiveScript}
        ops = {+bare} if code.match /^\s*!?function/
        x  = vm.run-in-new-context LiveScript.compile(code, ops), repl-ctx, 'repl'
        repl-ctx <<< {_:x} if x?
        pp  x
        say x if typeof x is 'function'
    catch then say e
    reset!
  process.on 'uncaughtException' !-> say "\n#{ it?stack or it }"
  process.on 'exit'              !-> rl._tty-write '\r' if code and rl.output.is-TTY
  rl.set-prompt "#prompt> "
  rl.prompt!

# Start up a new __node.js__ instance with the arguments in `--nodejs` passed
# to it, preserving the other options.
!function fork-node
  [, ...args] = process.argv

  [ls-args, [, ...node-args]] = break-list (in <[ --nodejs -n ]>), args

  require 'child_process' .spawn do
    process.exec-path
    node-args ++ ls-args
    cwd: process.cwd!, custom-fds: [0 1 2]
