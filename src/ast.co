# Contains all of the node classes for the AST (abstract syntax tree).
# Most nodes are created as the result of actions in the [grammar](#grammar),
# but some are created by other nodes as a method of code generation. To convert
# the syntax tree into a string of JavaScript code, call `compileRoot`.

### Node
# The abstract base class for all nodes in the syntax tree.
# Each subclass implements the `compileNode` method, which performs the
# code generation for that node. To compile a node to JavaScript,
# call `compile` on it, which wraps `compileNode` in some generic extra smarts.
# An options hash is passed and cloned throughout, containing information about
# the environment from higher in the tree (such as if a returned value is
# being requested by the surrounding function), information about the current
# scope, and indentation level.
(Node = -> ...):: =
  compile: (options, level) ->
    o = {}; continue for key, o[key] in options
    o <<< {level} if level?
    node = @unfoldSoak o or this
    # If a statement appears within an expression, wrap it in a closure.
    return node.compileClosure o if o.level and node.isStatement()
    code = (node import tab: o.indent)compileNode o
    o.scope.free tmp for tmp of that if node.temps
    code

  compileClosure: (o) ->
    # A statement that _jumps_ out of current context (like `return`) can't be
    # an expression via closure-wrapping, as its meaning will change.
    that.carp 'inconvertible statement' if @jumps()
    fun = Fun [] Block this; call = Call(); hasThis = hasArgs = false
    @traverseChildren ->
      switch it.value
      case \this      then hasThis := true
      case \arguments then hasArgs := it.value = \_args
      void
    if hasThis
      call.args.push Literal \this
      call.method = \.call
    if hasArgs
      call.args.push Literal \arguments
      fun.params.push Var \_args
    # Flag the function as `wrapper` so that it shares a scope
    # with its parent to preserve the expected lexical scope.
    Parens(Chain fun<<<{+wrapper, @void} [call]; true)compile o

  # Compiles a child node as a block statement.
  compileBlock: (o, node) ->
    if node?compile o, LEVEL_TOP then "{\n#that\n#{@tab}}" else '{}'

  # If the code generation wishes to use the result of a complex expression
  # in multiple places, ensure that the expression is only ever evaluated once,
  # by assigning it to a temporary variable.
  cache: (o, once, level) ->
    unless @isComplex()
      return [ref = if level? then @compile o, level else this, ref]
    sub = Assign ref = Var(o.scope.temporary \ref), this
    # Pass a `level` to precompile.
    if level?
      sub.=compile o, level
      o.scope.free ref.value if once
      return [sub, ref.value]
    # If flagged as `once`, the tempvar will be auto-freed.
    if once then [sub, ref <<< {+temp}] else [sub, ref, [ref.value]]

  # Compiles to a variable/source pair suitable for looping.
  compileLoopReference: (o, name, ret) ->
    if this instanceof Var and o.scope.check @value
    or this instanceof Literal or @op is \- and -1/0 < +@first.value < 1/0
      return [@compile o] * 2
    asn = Assign Var(tmp = o.scope.temporary name), this
    ret or asn.void = true
    [tmp; asn.compile o, if ret then LEVEL_CALL else LEVEL_PAREN]

  # Passes each child to a function, returning its return value if exists.
  eachChild: (fn) ->
    for name of @children then if child = @[name]
      if \length in child
      then return that if fn(node )? for node of child
      else return that if fn(child)?
    void

  # Performs `eachChild` on every descendant.
  # Overridden by __Fun__ not to cross scope by default.
  traverseChildren: (fn, xscope) ->
    @eachChild -> if fn(it)? then that else it.traverseChildren fn, xscope

  # Performs anaphoric conversion if a `that` is found within `@aTargets`.
  anaphorize: ->
    @children = @aTargets
    if @eachChild hasThat
      if (base = this)[name = @aSource] instanceof Existence
        base.=[name]; name = \it
      unless base[name]value is \that
        base[name] = Assign Var(\that), base[name]
    function hasThat
      it.value is \that or if it.aSource
      then hasThat that if it[that]
      else it.eachChild hasThat
    delete @children
    @[@aSource]

  # Throws a syntax error, appending `@line` number to the message.
  carp: ->
    throw SyntaxError "#it on line #{ @line or @traverseChildren -> it.line }"

  # Defines delegaters.
  delegate: (names, fn) ->
    for name of names then let
      @[name] = -> fn.call this, name, it
    void

  # Default implementations of the common node properties and methods. Nodes
  # will override these with custom logic, if needed.
  children: []

  terminator: \;

  isComplex: YES

  isStatement  : NO
  isAssignable : NO
  isCallable   : NO
  isEmpty      : NO
  isArray      : NO
  isString     : NO
  isRegex      : NO

  isMatcher: -> @isString() or @isRegex()

  # Do I contain a statement that jumps out of me?
  jumps: NO
  # Do I assign a certain variable?
  assigns: NO
  # Do I hold a default value in an assignment context?
  hasDefault: NO

  # Picks up name(s) from LHS.
  ripName: VOID

  unfoldSoak   : VOID
  unfoldAssign : VOID
  unwrap       : THIS
  maybeKey     : THIS
  varName      : String
  selections   : VOID
  getCall      : VOID

  invert: -> Op \! this

  # Constructs a node that returns the current node's result.
  makeReturn: (arref) ->
    if arref then Call.make JS(arref + \.push), [this] else Return this

  # Extra info for `toString`.
  show: String

  # String representation of the node for inspecting the parse tree.
  # This is what `coco --ast` prints out.
  toString: (idt or '') ->
    tree  = \\n + idt + @..displayName
    tree += ' ' + that if @show()
    @eachChild -> tree += it.toString idt + TAB; void
    tree

  # JSON serialization
  stringify : (space) -> JSON.stringify this, null space
  toJSON    : -> {type: @..displayName, ...this}

# JSON deserialization
exports.parse    = (json) -> exports.fromJSON JSON.parse json
exports.fromJSON = function
  return it unless it and typeof it is \object
  if it.type
    node = ^exports[that]::
    node[key] = fromJSON val for key, val in it
    return node
  if it.length? then fromJSON v for v of it else it

#### Modules

Negatable =
  show   : -> @negated and \!
  invert : -> @negated ^= 1; this

#### Block
# A list of expressions that forms the body of an indented block of code.
class exports.Block extends Node
  (node) ~>
    return node if node instanceof Block
    @lines = []
    @add node if node

  children: [\lines]

  add: ->
    if @back
      that.add it
    else if it.lines
      @lines.push ...that
    else
      @lines.push it
      @back = that if it.back
    this

  unwrap: -> if @lines.length is 1 then @lines.0 else this

  # Removes trailing comment nodes.
  chomp: ->
    {lines} = this; i = lines.length
    break unless that.comment while lines[--i]
    lines.length = i + 1
    this

  isComplex: -> @lines.length > 1 or @lines.0?isComplex()

  ::delegate <[ isCallable isArray isString isRegex ]> -> @lines[*-1]?[it]()

  jumps: -> return that if node.jumps it for node of @lines

  # **Block** does not return its entire body, rather it
  # ensures that the final line is returned.
  makeReturn: ->
    if @lines[*-1]?=makeReturn it
      --@lines.length if that instanceof Return and not that.it
    this

  compile: (o, level ? o.level) ->
    unless level then o.block = this; tab = o.indent
    codes = for node, i of @lines
      if level
        continue if node.comment
        node.void = true if i < lasti ||= @lines.length - 1
        code or node <<< {@front}
        code = node.compile o, LEVEL_LIST
      else
        node = node.unfoldSoak o or node
        code = tab + (node <<< {+front})compile o, level
        code += node.terminator unless node.isStatement()
      code
    return codes.join \\n unless level
    code = codes.join ', ' or 'void 8'
    if codes.length > 1 and level >= LEVEL_LIST then "(#code)" else code

  # **Block** is the only node that can serve as the root.
  compileRoot: (options) ->
    o = {level: LEVEL_TOP, scope: @scope = Scope.root = new Scope, ...options}
    delete o.filename
    o.indent = if bare = delete o.bare then '' else TAB
    @chomp()
    if /^\s*(?:[/#]|javascript:)/test @lines.0?code
      prefix = @lines.shift()code + \\n
    if delete o.repl
      if bare
        @lines[i] = Parens that if @lines[i = *-1]
      else
        @makeReturn()
    code = @compileWithDeclarations o
    # Wrap everything in a safety closure unless requested not to.
    bare or code = "(function(){\n#code\n}).call(this);\n"
    ([prefix]) + code

  # Compile the expressions body for the contents of a function, with
  # declarations of all inner variables pushed up to the top.
  compileWithDeclarations: (o) ->
    o.level = LEVEL_TOP
    code = ''
    break unless node.comment or node instanceof Literal for node, i of @lines
    if i
      rest   = @lines.splice i, 9e9
      code   = @compile o
      @lines = rest
    code &&+= \\n if post = @compile o
    code += o.indent + that + \;\n if @scope?vars o
    code + post

#### Atom
# An abstract node for simple values.
class Atom extends Node
  show      : -> @value
  isComplex : NO

#### Literal
# `this`, `debugger`, and primitives.
class exports.Literal extends Atom
  (@value) ~> return JS "#value" true if value.js

  isEmpty    : -> switch @value case \void \null then true
  isCallable : -> switch @value case \this \eval then true
  isString   : -> 0 <= '\'"'indexOf "#{@value}"charAt()

  varName: -> if /^\w+$/test @value then \$ + @value else ''

  compile: (o, level ? o.level) ->
    switch val = "#{@value}"
    case \this     then return o.scope.fun?bound or val
    case \void     then val += ' 8'; fallthrough
    case \null     then @carp 'invalid use of ' + @value if level is LEVEL_CALL
    case \debugger then if level
      return "(function(){\n#{ o.indent + TAB }debugger;\n#{o.indent}}())"
    case \* then @carp 'stray star'
    val

#### Var
# Variables.
class exports.Var extends Atom
  (@value) ~>

  ::isAssignable = ::isCallable = YES

  assigns: -> it is @value

  maybeKey: -> Key(@value) <<< {@line}

  varName: ::show

  compile: (o) -> if @temp then o.scope.free @value else @value

#### Key
# The name of a property, in the form of `{key: _}` or `_.key`.
class exports.Key extends Atom
  (name, @reserved or name.reserved) ~> @name = '' + name

  isAssignable: -> not @reserved

  assigns: -> it is @name

  varName: ->
    {name} = this
    (if @reserved or name of <[ arguments eval ]> then \$ else '') + name

  compile: ::show = -> if @reserved then "'#{@name}'" else @name

#### Index
# Dots and brackets to access an object's property.
class exports.Index extends Node
  (key, symbol or \., init) ~>
    if init and key instanceof Arr
      switch key.items.length
      case 0 then key = Key \__proto__
      case 1 then key = Parens key.items.0
    if \? is symbol.charAt 0
      @soak = \?
      symbol.=slice 1
    switch symbol.slice -1
    case \= then @assign = symbol.slice 1
    case \@ then @vivify = (if symbol.length > 2 then Arr else Obj)
    import {key, symbol}

  children: [\key]

  show: -> (@soak or '') + @symbol

  isComplex: -> @key.isComplex()

  varName: -> @key instanceof [Key, Literal] and @key.varName()

  compile: (o) ->
    code = @key.compile o, LEVEL_PAREN
    if @key instanceof Key and \' is not code.charAt 0
    then ".#code" else "[#code]"

#### Chain
# Acts as a container for property-access/function-call chains, by holding
# __Index__ or __Call__ instances as `@tails`.
class exports.Chain extends Node
  (head, tails) ~>
    return head if not tails and head instanceof Chain
    import {head, tails or []}

  children: <[ head tails ]>

  add: ->
    if @tails.push(it) is 1 and it instanceof Call
      if @head instanceof Existence
        {@head, @tails} = Chain @head.it
        @tails.push it <<< {+soak}
      if not it.method and @head instanceof Super
        it.method = \.call; it.args.unshift Literal \this
    else if delete it.vivify
      @head = Assign Chain(@head, @tails.splice 0, 9e9), that(), \= \||
    this

  # __Chain__ can be unwrapped as its inner node, if there are no subnodes.
  unwrap: -> if @tails.length then this else @head

  ::delegate <[ jumps assigns isStatement isString ]>
           , (it, arg) -> not @tails.length and @head[it] arg

  isComplex  : -> @tails.length or @head.isComplex()
  isCallable : ->
    if @tails[*-1] then not that.key?items else @head.isCallable()
  isArray    : ->
    if @tails[*-1] then that.key instanceof Arr else @head.isArray()
  isRegex    : ->
    @head.value is \RegExp and not @tails.1 and @tails.0 instanceof Call

  isAssignable: ->
    return @head.isAssignable() unless tail = @tails[*-1]
    return false if tail not instanceof Index or tail.key instanceof List
    return false if tail.assign for tail of @tails
    true

  # `@$` `o.0`
  isSimpleAccess: ->
    @tails.length is 1 and not @head.isComplex() and not @tails.0.isComplex()

  makeReturn: -> if @tails.length then super ... else @head.makeReturn it

  getCall: -> (tail = @tails[*-1]) instanceof Call and tail

  varName: -> @tails[*-1]?varName()

  # A reference has base part (`this` value) and name part.
  # We cache them separately for compiling complex expressions, so that e.g.
  #
  #     a()[b()] ||= c
  #
  # compiles to
  #
  #     (_ref = a())[_key = b()] || (_ref[_key] = c);
  #
  cacheReference: (o) ->
    name = @tails[*-1]
    # `a.b()`
    return @cache o, true if name instanceof Call
    # `a` `a.b`
    if @tails.length < 2 and not @head.isComplex() and not name?isComplex()
      return [this] * 2
    base = Chain @head, @tails.slice 0 -1
    # `a().b`
    if base.isComplex()
      ref  = o.scope.temporary \ref
      base = Chain Assign Var(ref), base
      bref = Var(ref) <<< {+temp}
    # `a{}`
    return [base, bref] unless name
    # `a[b()]`
    if name.isComplex()
      ref  = o.scope.temporary \key
      name = Index Assign Var(ref), name.key
      nref = Index Var(ref) <<< {+temp}
    [base.add name; Chain bref || base.head, [nref or name]]

  compileNode: (o) ->
    {head} = this; head <<< {@front, @newed}
    return head.compile o unless @tails.length
    return that.compile o if @unfoldAssign o
    @carp 'invalid callee' if @tails.0 instanceof Call and !head.isCallable()
    @expandSlice o; @expandBind o; @expandSplat o; @expandStar o
    base = @head.compile o, LEVEL_CALL; news = rest = ''
    for t of @tails
      news += 'new ' if t.new
      rest += t.compile o
    base += ' ' if \. is rest.charAt 0 and SIMPLENUM.test base
    news + base + rest

  # Unfolds a soak into an __If__: `a?.b` => `a.b if a?`
  unfoldSoak: (o) ->
    if @head.unfoldSoak o
      that.then.tails.push ...@tails
      return that
    for node, i of @tails then if delete node.soak
      bust = Chain @head, @tails.splice 0 i
      test = if node instanceof Call
        [test, @head] = bust.cacheReference o
        JS "typeof #{ test.compile o, LEVEL_OP } == 'function'"
      else
        if i and node.assign
          [test, bust] = bust.cacheReference o
          @head = bust.head; @tails.unshift ...bust.tails
        else
          [test, @head] = bust.unwrap()cache o, true
        Existence test
      return If(test, this) <<< {+soak, @void}
    void

  unfoldAssign: (o) ->
    if @head.unfoldAssign o
      that.right.tails.push ...@tails
      return that
    for index, i of @tails then if index.assign
      index.assign = ''
      [left, @head] = Chain(@head, @tails.splice 0 i)cacheReference o
      return Assign(left, this, that) <<< {+access}
    void

  expandSplat: (o) ->
    {tails} = this; i = -1; while call = tails[++i]
      continue unless args = call.args
      ctx = call.method is \.call and (args.=concat())shift()
      continue unless args = Splat.compileArray o, args, true
      @carp 'splatting "new"' if call.new
      if not ctx and tails[i-1] instanceof Index
        [@head, ctx] = Chain(@head, tails.splice 0 i-1)cache o, true
        i = 0
      call <<< method: \.apply, args: [ctx or Literal \null; JS args]
    void

  expandBind: (o) ->
    {tails} = this; i = -1; while tails[++i]
      continue unless that.symbol is \.~
      that.symbol = ''
      args   = Chain(@head, tails.splice 0 i)unwrap()cache o, true
      args.1 = Chain args.1, [tails.shift()]
      call   = Call.make Util(\bind), args
      @head  = if @newed then Parens call, true else call
      i = -1
    void

  expandStar: (o) ->
    {tails} = this; i = -1; while tails[++i]
      continue if that.args or that.stars or that.key instanceof Key
      stars = that.stars = []
      that.eachChild seek
      continue unless stars.length
      [sub, ref, temps] = Chain(@head, tails.splice 0 i)unwrap()cache o
      ref += ' ' if SIMPLENUM.test ref.=compile o
      star.value = ref + \.length for star of stars
      @head = JS sub.compile(o, LEVEL_CALL) + tails.shift()compile o
      o.scope.free temps.0 if temps
      i = -1
    function seek
      if it.value is \*               then stars.push it
      else unless it instanceof Index then it.eachChild seek
      void
    void

  expandSlice: (o) ->
    {tails} = this; i = -1; while tail = tails[++i] then if tail.key?items
      tail.carp 'calling a slice' if tails[i+1] instanceof Call
      tailz = tails.splice 0 i+1
      @head = tailz.pop!key.toSlice(o, Chain(@head, tailz)unwrap!) <<< {@front}
      i = -1
    void

#### Call
# `x(y)`
class exports.Call extends Node
  (args || []) ~>
    if args.length is 1 and args.0.filler
      @method = \.call; args <<< [Literal \this; Splat Literal \arguments]
    import {args}

  children: [\args]

  show: -> ([@new]) + ([@method]) + ([\? if @soak])

  compile: (o) ->
    code  = (@method or '') + \(
    code += (if i then ', ' else '')+ a.compile o, LEVEL_LIST for a, i of @args
    code + \)

  @make = (callee, args) -> Chain(callee)add Call args

  @block = (fun, args, method) ->
    Parens(Chain fun, [Call(args) <<< {method}]; true) <<< {+calling}

  @back = (params, arrow, node) ->
    (call = node.getCall()) or node = Chain(node)add call = Call()
    {args} = call
    break if arg.filler for arg, idx of args
    node import back: (args[idx] = Fun params, null, arrow.charAt(1) + \>)body

  @let = (args, body) ->
    params = for a, i of args
      if a.op is \= and not a.logic
      then args[i] = a.right; a.left
      else Var a.varName() || a.carp 'invalid "let" argument'
    args.unshift Literal \this
    @block Fun(params, body), args, \.call

#### List
# An abstract node for a list of comma-separated items.
class List extends Node
  children: [\items]

  show  : -> @name
  named : (@name) -> this

  isEmpty : -> not @items.length
  assigns : -> return true if node.assigns it for node of @items

  @compile = (o, items) ->
    switch items.length
    case 0 then return ''
    case 1 then return items.0.compile o, LEVEL_LIST
    {indent, level} = o
    o <<< indent: indent + TAB, level: LEVEL_LIST
    code  = items[i = 0]compile o
    code += ', ' + that.compile o while items[++i]
    code  = "\n#{o.indent}#code\n#indent" if ~code.indexOf \\n
    o <<< {indent, level}
    code

#### Obj
# `{x: y}`
class exports.Obj extends List
  (@items or []) ~>

  asObj: THIS

  # `base{x: y}` => `{x: base.y}`
  toSlice: (o, base, assign) ->
    {items} = this
    if items.length > 1 then [base, ref, temps] = base.cache o else ref = base
    for node, i of items
      continue if node.comment
      if node instanceof [Prop, Splat]
        node[name = node.children[*-1]] =
          chain = Chain base, [Index node[name]maybeKey()]
      else
        # `o{k or v}` => `{k: a.k or v}`
        node.=first if logic = node.hasDefault()
        if node instanceof Parens
          # `a{(++i)}` => `{(_ref = ++i): a[_ref]}`
          [key, node] = node.cache o, true
          # `a{(++i)} = b` => `{(_ref): a[_ref = ++i]} = b`
          #                => `a[_ref = ++i] = b[_ref]`
          [key, node] = [node, key] if assign
          key = Parens key
        else key = node
        val = chain = Chain base, [Index node.maybeKey()]
        val = logic <<< {first: val} if logic
        items[i] = Prop key, val
      base = ref
    chain or @carp 'empty slice'
    (chain.head = Var temps.0)temp = true if temps
    this

  compileNode: (o) ->
    {items} = this
    return (if @front then '({})' else '{}') unless items.length
    code = ''; idt = \\n + o.indent += TAB; dic = {}
    for node, i of items
      if node.comment
        code += idt + node.compile o
        continue
      node.=first if logic = node.hasDefault()
      if node instanceof Splat or (node.key or node) instanceof Parens
        rest = items.slice i
        break
      if logic
        # `{@a or b}` => `{a: @a or b}`
        if node instanceof Prop
        then node.val = logic <<< first: node.val
        else node = Prop node, logic <<< first: node
      if multi then code += \, else multi = true
      code += idt + if node instanceof Prop
        {key, val} = node
        if val.accessor
          key = "#{ if val.params.length then val.void = true; \set else \get }
               \ #{ key.compile o }"
          key + val.compile(o, LEVEL_LIST)slice 8
        else
          val.ripName key
          "#{ key.=compile o }: #{ val.compile o, LEVEL_LIST }"
      else
        "#{ key = node.compile o }: #key"
      node.carp "duplicate property name \"#key\"" unless dic[0 + key] ^= 1
    code = "{#{ code and code + \\n + @tab }}"
    code = "(#code)" if @front
    if rest then Import(JS code; Obj rest)compile o <<< indent: @tab else code

#### Prop
# `x: y`
class exports.Prop extends Node
  (@key, val) ~>
    val.=first <<< {\accessor} if val.op is \~ and val.first instanceof Fun
    import {val}

  children: <[ key val ]>

  show: -> @val.accessor

  assigns: -> @val.assigns it

#### Arr
# `[x, y]`
class exports.Arr extends List
  (@items or []) ~>

  isArray: YES

  selections: -> @items.length > 1 and @items

  asObj: -> Obj(Prop Literal(i), item for item, i of @items)

  # `base[x, ...y]` => `[base[x], ...base[y]]`
  toSlice: (o, base) ->
    {items} = this
    if items.length > 1 then [base, ref, temps] = base.cache o else ref = base
    for item, i of items
      item.=it if splat = item instanceof Splat
      continue if item.isEmpty()
      chain = Chain base, [Index item]
      items[i] = if splat then Splat chain else chain
      base = ref
    chain or @carp 'empty slice'
    (chain.head = Var temps.0)temp = true if temps
    this

  compile: (o) ->
    {items} = this
    return '[]' unless items.length
    if code = Splat.compileArray o, items
      return if @newed then "(#code)" else code
    "[#{ List.compile o, items }]"

  @maybe = (nodes) ->
    return nodes.0 if nodes.length is 1 and nodes.0 not instanceof Splat
    Arr nodes

  @wrap = -> Arr [Splat it <<< isArray: YES]

#### Op
# Simple arithmetic and logical operations, with some special conversions.
class exports.Op extends Node
  (op, first, second, post) ~>
    switch op
    case \of then return new Of first, second
    case \do
      return Call.block first if first instanceof Fun
      return Parens do
        # `do f?` => `f?()`
        if first instanceof Existence and not first.negated
        then Chain(first)add Call!
        else Call.make first
    case \new
      # `new C?` => `new C?()`
      if first instanceof Existence and not first.negated
        first = Chain(first)add Call!
      first.newed = true
      for node of first.tails or ''
        if node instanceof Call and not node.new
          node.args.shift() if node.method is \.call
          node <<< {\new, method: ''}
          return first
    case \+
      break unless second
      if first instanceof Arr
        first.items.push Splat second
        return first
      if second instanceof Arr
      or second instanceof While and second = Arr [Splat second]
        second.items.unshift Splat first
        return second
    case \~ then if first instanceof Fun and first.statement and !first.bound
      return first <<< bound: \_this
    import {op, first, second, post}

  children: <[ first second ]>

  show: -> @op

  isCallable: ->
    switch @op
    case <[ new delete ]> then @first.isCallable()
    case <[ && || ? !? ]> then @first.isCallable() and @second.isCallable()

  isArray: ->
    switch @op
    case \* then @first instanceof Arr
    case \/ then @second.isMatcher()

  isString: ->
    switch @op
    case \+ then break unless @second; fallthrough
    case \* then @first.isString() or @second.isString()
    case \- then @second?isMatcher()
    case \typeof \classof then true

  EQUALITY = /^[!=]==?$/
  COMPARER = /^(?:[!=]=|[<>])=?$/

  invert: ->
    if EQUALITY.test op = @op and not COMPARER.test @second.op
      @op = '!='charAt(op.indexOf \=) + op.slice 1
      return this
    return Op \! Parens this if @second
    return @first if op is \! and @first.op of <[ ! in instanceof < > <= >= ]>
    Op \! this

  unfoldSoak: (o) ->
    @op of <[ ++ -- delete ]> and If.unfoldSoak o, this, \first

  hasDefault: -> switch @op case \? \|| \&& \!? then this

  compileNode: (o) ->
    return @compileUnary o unless @second
    switch @op
    case \? \!?      then return @compileExistence o, @op is \!?
    case \instanceof then return @compileIOS o, that if @second.selections()
    case \*
      return @compileJoin   o if @second.isString()
      return @compileRepeat o if @first.isString() or @first instanceof Arr
    case \-  then return @compileRemove o if @second.isMatcher()
    case \/  then return @compileSplit  o if @second.isMatcher()
    case \** then return @compilePow o
    case \<? \>? then return @compileMinMax o
    case \&& \|| then @second.void = true if @void or not o.level
    default
      return @compileChain o if COMPARER.test @op and COMPARER.test @second.op
    @first <<< {@front}
    code = "#{ @first .compile o, level = LEVEL_OP + PREC[@op] } #{@op} \
            #{ @second.compile o, level }"
    if o.level <= level then code else "(#code)"

  # Mimic Python's chained comparisons when multiple comparison operators are
  # used sequentially. e.g.:
  #
  #     $ coco -e '50 < 65 === 9r72 > 10'
  #     true
  #
  # See <http://docs.python.org/reference/expressions.html#notin>.
  compileChain: (o) ->
    code = @first.compile o, level = LEVEL_OP + PREC[@op]
    [sub, @second.first] = @second.first.cache o, true
    code += " #{@op} #{ sub    .compile o, level    } && \
                     #{ @second.compile o, LEVEL_OP }"
    if o.level <= LEVEL_OP then code else "(#code)"

  compileExistence: (o, inv) ->
    if @void or not o.level
      morph = Op \&& Existence(@first, not inv), @second
      return (morph <<< {+\void})compileNode o
    fs = @first.cache o, true
    If(Existence fs.0, inv; fs.1)addElse(@second)compileExpression o

  function crement then {'++':\in '--':\de}[it] + \crement

  compileUnary: (o) ->
    {op, first} = this
    switch op
    case \new then first.isCallable() or first.carp 'invalid constructor'
    case \delete
      @carp 'invalid delete' if first instanceof Var or !first.isAssignable()
      return @compileDelete o if o.level and not @void
    case \++ \--
      first.isAssignable() or @carp 'invalid ' + crement op
      if first instanceof Var and not o.scope.check first.value, true
        @carp "#{ crement op } of undeclared variable \"#{first.value}\""
      first{front} = this if @post
    case \^
      return "#{ utility \clone }(#{ first.compile o, LEVEL_LIST })"
    case \classof
      return "#{ utility \toString }.call(
              #{ first.compile o, LEVEL_LIST }).slice(8, -1)"
    code = first.compile o, LEVEL_OP + PREC.unary
    if @post then code += op else
      op += ' ' if op of <[ new typeof delete ]>
                or op of <[ + - ]> and first.op is op
      code = op + code
    if o.level < LEVEL_CALL then code else "(#code)"

  # `x instanceof [A, B]`
  compileIOS: (o, items) ->
    code = ''; [sub, ref] = @first.cache o, false level = LEVEL_OP + PREC\<
    for item, i of items
      code += "#{ if i then ' || ' + ref else sub } instanceof \
               #{ item.compile o, level }"
    sub is ref or o.scope.free ref
    if o.level <= LEVEL_OP then code else "(#code)"

  # `v = delete o.k`
  compileDelete: (o) ->
    [get, del] = Chain(@first)cacheReference o
    code = if @assigned then '' else "#{ ref = o.scope.temporary \ref } = "
    code += "#{ get.compile o, LEVEL_LIST }
    , delete #{ del.compile o, LEVEL_LIST }"
    return code if @assigned
    code += ", #{ o.scope.free ref }"
    if o.level < LEVEL_LIST then code else "(#code)"

  compileMinMax: (o) ->
    lefts = @first .cache o, true
    rites = @second.cache o, true
    test  = Op @op.charAt(0), lefts.0, rites.0
    If test, lefts.1 .addElse Block rites.1 .compile o

  compileMethod: (o, klass, method, arg) ->
    args = [@second]concat arg || []
    if @first"is#klass"()
      Chain(@first, [Index Key method; Call args])compile o
    else
      args.unshift @first
      Call.make(JS utility(method) + \.call; args)compile o

  compileJoin   : -> @compileMethod it, \Array  \join
  compileRemove : -> @compileMethod it, \String \replace JS "''"
  compileSplit  : -> @compileMethod it, \String \split

  compileRepeat: (o) ->
    {first: x, second: n} = this; {items} = x
    if (x = JS that if items and Splat.compileArray o, items)
    or not (n instanceof Literal and n.value < 0x20)
      x = Call.make Util(\repeat + if items then \Array else \String), [x, n]
      return x.compile o
    n = +n.value
    return x.compile o if 1 <= n < 2
    # `[x] * 2` => `[x, x]`
    if items
      if n < 1 then return (^Block::<<< lines: items)add(JS '[]')compile o
      refs = []
      [items[i], refs.*] = item.cache o, 1x for item, i of items
      items.push JS() <<<
        compile: -> (", #{ List.compile o, refs }" * (n-1))slice 2
      x.compile o
    # `'x' * 2` => `'xx'`
    else if x instanceof Literal
      (q = (x.=compile o)charAt()) + "#{ x.slice 1 -1 }" * n + q
    # `"#{x}" * 2` => `(_ref = "" + x) + _ref`
    else
      if n < 1 then return Block(x.it)add(JS "''")compile o
      x = (refs = x.cache o, 1, LEVEL_OP)0 + " + #{refs.1}" * (n-1)
      if o.level < LEVEL_OP + PREC\+ then x else "(#x)"

  compilePow: (o) -> Call.make(JS \Math.pow; [@first, @second])compile o

#### Assign
# Assignment to a variable/property.
class exports.Assign extends Node
  (@left, @right, @op or \=, @logic or @op.logic) ~> @op += ''

  children: <[ left right ]>

  show: -> (@logic or '') + @op

  assigns: -> @left.assigns it

  ::delegate <[ isCallable isRegex ]> ->
    switch @op case \= \:= then @right[it]()

  isArray: ->
    switch @op
    case \= \:= \+= then do @right.isArray
    case \/=        then do @right.isMatcher

  isString: ->
    switch @op
    case \= \:= \+= \*= then do @right.isString
    case \-=            then do @right.isMatcher

  unfoldSoak: (o) ->
    if @left instanceof Existence
      # `[a, b]? = c` => `[a, b] = c if c?`
      if delete (@left.=it)name
      then rite = @right; rite = Assign @right = Var(that), rite
      else [rite, @right, temps] = @right.cache o
      return If(Existence rite; this) <<< {temps}
    If.unfoldSoak o, this, \left

  unfoldAssign: -> @access and this

  compileNode: (o) ->
    {op, right} = this; left = @transleft o
    return (Parens(right) <<< {@front, @newed})compile o if left.isEmpty()
    return @compileDestructuring o, left if left.items
    return @compileConditional   o, left if @logic
    if left.hasDefault()
      right = Op left.op, right, left.second
      left.=first
    left.isAssignable() or left.carp 'invalid assign'
    return @compileMinMax o, left, right if op of <[ <?= >?= ]>
    if op is \**=
    or op is \+= and right instanceof [Arr, While]
    or op is \*= and right.isString()
    or op of <[ -= /= ]> and right.isMatcher()
      [left, reft] = Chain(left)cacheReference o
      right = Op op.slice(0 -1), reft, right
      op    = \:=
    right.=it while right instanceof Parens and not right.keep
    right.ripName left.=unwrap()
    lvar = left instanceof Var
    sign = op.replace \: ''
    name = (left <<< {+front})compile o, LEVEL_LIST
    code = if not o.level and right instanceof While and not right.else and
              (lvar or left.isSimpleAccess())
      # Optimize `a = while ...`.
      """#{ res = o.scope.temporary \res } = [];
         #{@tab}#{ right.makeReturn(res)compile o }
         #{@tab}#name #sign #{ o.scope.free res }"""
    else
      "#name #sign " + (right <<< {+assigned})compile o, LEVEL_LIST
    if lvar
      del = right.op is \delete
      if op is \=
        o.scope.declare name
      else unless o.scope.check name, true
        left.carp "assignment to undeclared variable \"#name\""
    if o.level
      code += ", #name" if del
      code  = "(#code)" if that > (if del then LEVEL_PAREN else LEVEL_LIST)
    code

  compileConditional: (o, left) ->
    if left instanceof Var and @logic of <[ ? !? ]> and @op is \=
      o.scope.declare left.value
    lefts = Chain(left)cacheReference o
    morph = Op @logic, lefts.0, @<<<{-logic, left: lefts.1}
    (morph <<< {@void})compileNode o

  compileMinMax: (o, left, right) ->
    lefts = Chain(left)cacheReference o
    rites = right.cache o, true
    test  = Op @op.replace(\? ''), lefts.0, rites.0
    put   = Assign lefts.1, rites.1, \:=
    # `a <?= b` => `a <= b || a = b `
    return Parens(Op \|| test, put)compile o if @void or not o.level
    # `r = a <?= b` => `r = if a <= b then a else a = b`
    [test.second, left] = test.second.cache o, true
    If test, left .addElse put .compileNode o

  # Implementation of recursive destructuring,
  # when assigning to an array or object literal.
  # See <http://wiki.ecmascript.org/doku.php?id=harmony:destructuring>.
  compileDestructuring: (o, left) ->
    {items} = left; len = items.length; ret = o.level and not @void
    rite = @right.compile o, if len is 1 then LEVEL_CALL else LEVEL_LIST
    if left.name
      cache = "#that = #rite"
      o.scope.declare rite = that
    else if (ret or len > 1) and (not ID.test rite or left.assigns rite)
      cache = "#{ rref = o.scope.temporary \ref } = #rite"
      rite  = rref
    list = @"rend#{ left..displayName }" o, items, rite
    o.scope.free rref  if rref
    list.unshift cache if cache
    list.push rite     if ret or not list.length
    code = list.join ', '
    if list.length < 2 or o.level < LEVEL_LIST then code else "(#code)"

  rendArr: (o, nodes, rite) ->
    for node, i of nodes
      continue if node.isEmpty()
      if node instanceof Splat
        len and node.carp 'multiple splat in an assignment'
        skip = (node.=it)isEmpty()
        if i+1 is len = nodes.length
          break if skip
          val = Arr.wrap JS \
            utility(\slice) + \.call( + rite + if i then ", #i)" else \)
        else
          val = ivar = "#rite.length - #{ len - i - 1 }"
          # Optimize `[..., a] = b`.
          continue if skip and i+2 is len
          start = i+1; @temps = [ivar = o.scope.temporary \i]
          val = if skip then node = Var ivar; Var val else
            Arr.wrap JS "#i < (#ivar = #val)
                       \ ? #{ utility \slice }.call(#rite, #i, #ivar)
                       \ : (#ivar = #i, [])"
      else
        (inc = ivar) and start < i and inc += " + #{ i - start }"
        val = Chain rcache||=Literal(rite), [Index JS inc || i]
      (^@<<<{left: node, right: val, +\void})compile o, LEVEL_PAREN

  rendObj: (o, nodes, rite) ->
    for node of nodes
      node.=it if splat = node instanceof Splat
      # `{a or b} = c` => `a = c.a or b`
      node.=first if logic = node.hasDefault()
      if node instanceof Parens
        [node, key] = Chain(node.it)cacheReference o
      else if node instanceof Prop
      then node = ({key} = node)val
      else key  = node
      node = Var node.name if node instanceof Key
      node = logic <<< {first: node} if logic
      val  = Chain rcache||=Var(rite), [Index key.maybeKey()]
      val  = Import Obj(), val if splat
      (^@<<<{left: node, right: val, +\void})compile o, LEVEL_PAREN

  # Resolves subdestructuring.
  transleft: (o) ->
    left = @left.=unwrap()
    if left instanceof Chain and left.tails[*-1]?key?items
      # `a[x, y] = b{z} = c` => `[a[x], a[y]] = {z: b.z} = c`
      return left.tails.pop()key.toSlice o, left.unwrap(), true
    left

#### Import
# Copies properties from right to left.
class exports.Import extends Node
  (@left, @right, @all and \All) ~>
    if not all and left instanceof Obj and right.items
      return Obj left.items.concat right.asObj()items

  children: <[ left right ]>

  show: -> @all

  ::delegate <[ isCallable isArray ]> -> @left[it]()

  unfoldSoak: (o) ->
    If.unfoldSoak o, this, \left
    or (@void or not o.level) and
    If.unfoldSoak o, this, \right

  compileNode: (o) ->
    {right} = this
    unless @all
      if right instanceof Chain
        right = right.unfoldSoak o or right.unfoldAssign o or
                (right.expandSlice o; right.unwrap())
      return @compileAssign o, right.asObj()items if right instanceof List
    Call.make Util("import#{ @all or '' }"), [@left, right] .compileNode o

  # If the right operand of `<<<` is an object or array literal,
  # expand it to a series of assignments.
  compileAssign: (o, items) ->
    return @left.compile o unless items.length
    top = not o.level
    if items.length < 2 and (top or items.0 instanceof Splat)
    then left = lref = Parens @left
    else [left, lref, @temps] = @left.cache o
    [delim, space] = if top then [\; \\n + @tab] else [\, ' ']
    delim += space
    code = if left is lref then '' else left.compile(o, LEVEL_PAREN) + delim
    for node, i of items
      i and code += if com then space else delim
      if com = node.comment
        code += node.compile o
        continue
      if node instanceof Splat
        code += Import(lref, node.it)compile o
        continue
      node.=first if logic = node.hasDefault()
      if dyna = node instanceof Parens
        [key, val] = node.it.cache o, true
      else if node instanceof Prop
        {key, val} = node
        if val.accessor
          key = if key instanceof Key
          then val.meth = Index key; "'#{key.name}'"
          else key.compile o, LEVEL_LIST
          code += "#{ lref.compile o }.__define#{
            if val.params.length then val.void = true; \S else \G
          }etter__(#key, #{ val.compile o, LEVEL_LIST })"
          continue
      else key = val = node
      dyna or key.=maybeKey()
      val = logic <<< {first: val} if logic
      code += Assign(Chain lref, [Index key]; val)compile o, LEVEL_PAREN
    return code if top
    node instanceof Splat or
      code += (if com then ' ' else ', ') + lref.compile o, LEVEL_LIST
    if o.level < LEVEL_LIST then code else "(#code)"

#### Of
# Handles `of` operation that tests if the left operand is included within
# the right operand, arraywise.
class exports.Of extends Node
  (@item, @array) ->

  children: <[ item array ]>

  ::<<<< Negatable

  compileNode: (o) ->
    [sub, ref] = @item.cache o, false, level = LEVEL_LIST
    if items = @array.selections()
      code = ''; level = LEVEL_OP + PREC\==
      [cmp, cnj] = if @negated then [' !== ' ' && '] else [' === ' ' || ']
      for item, i of items
        code &&+= cnj
        if item instanceof Splat
          code += (new Of(Var ref; item.it) <<< {@negated})compile o, level
          code  = "(#sub, #code)" unless i or sub is ref
        else
          code += (if i or sub is ref then ref else "(#sub)") +
                  cmp + item.compile o, level
      level = LEVEL_OP + PREC\||
    else
      code = "#{ utility \indexOf }.call(#{ @array.compile o, level }, #ref
            ) #{ if @negated then \< else \>= } 0"
      if sub is ref
      then level = LEVEL_OP + PREC\<
      else code  = "#sub, #code"
    sub is ref or o.scope.free ref
    if o.level < level then code else "(#code)"

#### Existence
# Checks a value for existence--not `undefined` nor `null`.
class exports.Existence extends Node
  (@it, @negated) ~>

  children: [\it]

  ::<<<< Negatable

  compileNode: (o) ->
    node = @it.unwrap() <<< {@front}
    code = node.compile o, LEVEL_OP + PREC\==
    if node instanceof Var and not o.scope.check code, true
      [op, eq] = if @negated then <[ || = ]> else <[ && ! ]>
      code = "typeof #code #eq= 'undefined' #op #code #eq== null"
    else
      code += " #{ op = if @negated then \== else \!= } null"
    if o.level < LEVEL_OP + PREC[op] then code else "(#code)"

#### Fun
# A function definition. This is the only node that creates a `new Scope`.
class exports.Fun extends Node
  (@params or [], @body or Block(), arrow) ~> @bound = \_this if arrow is \~>

  children: <[ params body ]>

  show: -> @bound

  named: -> import {name: it, +statement}

  isCallable: YES

  isStatement: -> !!@statement

  # Short-circuit `traverseChildren` method to prevent it
  # from crossing scope boundaries by default.
  traverseChildren: (, xscope) -> super ... if xscope

  makeReturn: -> if @statement then import {+returns} else super ...

  ripName: ->
    # `name = ->`
    @name ||= it.varName()
    @declared = it instanceof Var
    # `clas::meth = ->`
    if it.tails?length
      @clas ||= it.head instanceof Var and it.tails.0.key?name is \prototype
            and it.head.value
      @meth ||= not (tail = it.tails[*-1])isComplex() and tail
    void

  compileNode: (o) ->
    pscope = o.scope
    sscope = pscope.shared or pscope
    scope  = o.scope = @body.scope =
      new Scope (if @wrapper then pscope else sscope), @wrapper && sscope
    scope.fun = this
    scope.assign \prototype "#{ that.compile o }.prototype" if @proto
    o.indent = @tab = '' if @plucked
    o.indent += TAB
    {body, name, tab} = this
    code = \function
    if @bound is \_this
      if @ctor
        scope.assign \_this 'new _ctor'
        code += " _ctor(){} _ctor.prototype = prototype;\n#{tab}function"
        body.add Return Literal \_this
      else if sscope.fun?bound
      then @bound = that
      else sscope.assign \_this \this
    if @statement
      name                    or @carp  'nameless function declaration'
      pscope is o.block.scope or @carp 'misplaced function declaration'
      @accessor              and @carp 'named accessor'
      scope .add name, \function
      pscope.add name, \function unless @returns
      code += ' ' + name
    empty = not body.lines.length
    code += "(#{ @compileParams scope }){"
    body.makeReturn() unless empty or @ctor or @void or @newed
    code += "\n#that\n#tab" if body.compileWithDeclarations o
    code += \}
    return sscope.assign sscope.temporary(\fn), code if @plucked
    code += "\n#{tab}return #name;" if @returns
    if @front and not @statement then "(#code)" else code

  compileParams: (scope) ->
    {params, body} = this; names = []; assigns = []
    for p, i of params
      if p instanceof Splat then splace = i
      # `(a = x) ->` => `(a ? x) ->`
      else if p.op is \= and not p.logic
        params[i] = Op \? p.left, p.right
    # `(a, ...b, c) ->` => `(a) -> [[] ...b, c] = @@`
    if splace?
      rest = params.splice splace, 9e9
      rest = 0 if not rest.1 and rest.0.it.isEmpty()  # ignore trailing `...`
    else if @accessor
      that.carp 'excess accessor parameter' if params.1
    else unless params.length or @wrapper
      params.0 = Var \it if body.traverseChildren -> it.value is \it or null
    if params.length
      dic = {}
      for p of params
        vr = p
        vr.=first if df = vr.hasDefault()
        if vr.isEmpty()
          vr = Var scope.temporary \arg
        else if vr not instanceof Var
          v = Var delete (vr.it || vr)name || vr.varName() ||
                  scope.temporary \arg
          assigns.push Assign vr, if df then Op p.op, v, p.second else v
          vr = v
        else if df
          assigns.push Assign vr, p.second, \=, p.op
        names.push name = scope.add vr.value, \arg
        p.carp "duplicate parameter \"#name\"" unless dic[0 + name] ^= 1
    if rest
      rest.unshift Arr() while splace--
      assigns.push Assign Arr(rest), Literal \arguments
    @body.lines.unshift ...assigns if assigns.length
    names.join ', '

#### Class
class exports.Class extends Node
  (@title, @sup, body) -> @fun = Fun [] body

  children: <[ title sup fun ]>

  isCallable: YES

  ripName: -> @name = it.varName(); void

  compile: (o, level) ->
    {fun, title} = this; {lines} = fun.body
    decl  = title?varName()
    name  = decl or @name
    name  = tmp = \_Class unless name and ID.test name
    proto = Var \prototype
    fun.body.traverseChildren -> it.clas = name if it instanceof Fun; void
    for node, i of lines
      if node instanceof Obj
        lines[i] = Import proto, node
      else if node instanceof Fun and not node.statement
        ctor and node.carp 'redundant constructor'
        ctor = node
    ctor or lines.push ctor = Fun()
    ctor <<< {name, +ctor, +statement, -clas}
    lines.push vname = proto = Var fun.bound = name
    if @sup
      args  = [that]
      proto = Util.Extends vname, fun.params.* = Var \_super
    unless tmp
      break unless node.comment or node instanceof Literal for node, i of lines
      lines.splice i,0 Literal "#name.displayName = '#name'"
    clas = Parens Call.make(fun<<<{proto} args), true
    clas = Assign vname, clas if decl and title.isComplex()
    clas = Assign title, clas if title
    clas.compile o, level

#### Super
# Reference to the parent method or constructor.
class exports.Super extends Node
  ::isAssignable = ::isCallable = YES

  compile: (o) ->
    {fun or @carp 'stray "super"'} = o.scope.shared or o.scope
    if fun.clas and /^(?:\.|\[[\'\"\d.])/test key = fun.meth?compile o
      return fun.clas + \.superclass.prototype + key
    if fun.name and (fun.ctor or fun.statement or fun.declared)
      return fun.name + \.superclass
    o.scope.check \_super or @carp '"super" in a nameless function'
    \_super

#### Parens
# An extra set of parentheses,
# specifying evaluation order and/or forcing expression.
class exports.Parens extends Node
  (@it, @keep, @string) ~>

  children: [\it]

  show: -> @string and '""'

  ::delegate <[ isComplex isCallable isArray isRegex ]> -> @it[it]()

  isString: -> @string or @it.isString()

  compile: (o, level ? o.level) ->
    {it} = this
    it.head.void = true if @calling and (not level or @void)
    unless @keep or @newed or
           it instanceof Op and level >= LEVEL_OP + (PREC[it.op] or PREC.unary)
      return (it <<< {@front})compile o, level || LEVEL_PAREN
    if it.isStatement()
    then it.compileClosure o
    else "(#{ it.compile o, LEVEL_PAREN })"

#### Splat
# A splat, either as an argument to a call
# or as part of a destructuring assignment.
class exports.Splat extends Node
  (@it, @filler) ~>

  ::{children, isComplex} = Parens::

  isAssignable: YES

  assigns: -> @it.assigns it

  compile: -> @carp 'invalid splat'

  # Compiles a list of nodes mixed with splats to a proper array.
  @compileArray = (o, list, apply) ->
    index = -1
    while node = list[++index] then if node instanceof Splat
      return '' if apply and node.filler
      break unless node.it.isEmpty()
      list.splice index-- 1
    return '' if index >= list.length
    unless list.1
      return (if apply then Object else ensureArray) list.0.it
             .compile o, LEVEL_LIST
    args = []; atoms = []
    for node of list.splice index, 9e9
      if node instanceof Splat
        atoms.length &&= !args.push Arr atoms
        args.push ensureArray node.it
      else atoms.push node
    args.push Arr atoms if atoms.length
    (if index then Arr list else args.shift())compile(o, LEVEL_CALL) +
    ".concat(#{ List.compile o, args })"

  function ensureArray node
    return node if node.isArray()
    Call.make JS(utility(\slice) + \.call), [node]

#### Jump
# `break` `continue`
class exports.Jump extends Node
  (@verb, @label) ->

  show: -> (@verb or '') + if @label then ' ' + that else ''

  isStatement : YES
  makeReturn  : THIS

  jumps: ->
    not (it and (it.loop or it.block and @verb is not \continue)) and this

  compileNode: -> @show() + \;

#### Throw
class exports.Throw extends Jump
  (@it) ~>

  children: [\it]

  jumps: NO

  compileNode: (o) ->
    "throw #{ (@it or Literal \null)compile o, LEVEL_PAREN };"

  Jump.throw = this

#### Return
class exports.Return extends Throw
  ~> import {it} if it and it.value is not \void

  jumps: THIS

  compileNode: (o) ->
    "return#{ if @it then ' ' + @it.compile o, LEVEL_PAREN else '' };"

  Jump.return = this

#### While
# The traditional `while`/`for`/`do` loop.
# Returns an array of values collected from the last expression when requested.
class exports.While extends Node
  (test, @un, mode) ->
    mode and if mode instanceof Node then @update = mode else @post = true
    # `while true` `until false` => `for (;;)`
    import {test} if @post or test.value is not ''+!un

  children: <[ test body update else ]>

  aSource: \test, aTargets: <[ body update ]>

  show: -> [\! if @un; \do if @post] * ''

  ::isStatement = ::isArray = YES

  jumps: -> return node if node.jumps context||={+loop} for node of @body.lines

  addBody: (@body) ->
    [top] = body.lines
    body.lines.length = 0 if top?verb is \continue and not top.label
    this

  addElse: (@else) -> this

  makeReturn: ->
    if it
    then @body.makeReturn it
    else @jumps() or @returns = true
    this

  compileNode: (o) ->
    @pluckDirectCalls o
    @test and if @un then @test.=invert() else @anaphorize()
    return 'do {' + @compileBody (o.indent += TAB; o), @test if @post
    test = @test?compile o, LEVEL_PAREN or ''
    head = if @update
    then "for (;#{ test and ' ' + test }; #{ that.compile o, LEVEL_PAREN }"
    else if test then "while (#test" else 'for (;;'
    head + ') {' + @compileBody (o.indent += TAB; o)

  compileBody: (o, potest) ->
    {lines} = @body; code = ret = ''
    if @returns
      if (last = lines[*-1]) and last not instanceof Throw
        lines[*-1] = last.makeReturn res = o.scope.assign \_results '[]'
      ret = "\n#{@tab}return #{ res or '[]' };"
    lines.unshift JS "#{ run = o.scope.temporary \run } = true;" if @else
    code += "\n#that\n#{@tab}" if @body.compile o, LEVEL_TOP
    code += \}
    code += " while (#{ potest.compile o<<<{@tab} LEVEL_PAREN });" if potest
    if run
      @else.makeReturn() if @returns
      code += " if (!#run) #{ @compileBlock o, @else }"
    code + ret

  pluckDirectCalls: (o) ->
    @body.eachChild dig = ~>
      unless it.calling or it.op is \new and (fun = it.first) instanceof Fun
        return if it instanceof [Fun, While] then null else it.eachChild dig
      fun or {head: fun, tails: [call]} = it.it
      return if fun.statement
      if this instanceof For
        call ||= (it.first = Call.make fun)tails.0  # `new ->`
        return if fun.params.length ^ call.args.length - !!call.method
        @index and fun.params.push call.args.* = Var @index
        if name = @name
          call.args.push if name.isComplex()
          then Var @nref ||= @temps.* = o.scope.temporary \ref
          else name
          fun.params.push name
      fun.plucked = true
      void

#### For
# Coco's replacements for the `for` loop are array, object or range iterators.
class exports.For extends While
  -> import all it

  children: <[ name source from to step body ]>

  aSource: null

  show: -> @index

  compileNode: (o) ->
    temps = @temps = []
    if idx = @index
    then o.scope.declare idx
    else temps.push idx = o.scope.temporary \i
    unless @object
      [pvar, step] = (@step or Literal 1)compileLoopReference o, \step
      pvar is step or temps.push pvar
    if @from
      [tvar, tail] = @to.compileLoopReference o, \to
      vars = idx + ' = ' + @from.compile o
      unless tail is tvar
        vars += ', ' + tail
        temps.push tvar
      eq   = if @op is \til then '' else \=
      cond = if +pvar
      then "#idx #{ if pvar < 0 then \> else \< }#eq #tvar"
      else "#pvar < 0 ? #idx >#eq #tvar : #idx <#eq #tvar"
    else
      if @name or @object and @own
        [svar, srcPart] = @source.compileLoopReference o, \ref, not @object
        svar is srcPart or temps.push svar
      else
        svar = srcPart = @source.compile o, LEVEL_PAREN
      unless @object
        if 0 > pvar and ~~pvar is +pvar  # negative int
          vars = "#idx = #srcPart.length - 1"
          cond = "#idx >= 0"
        else
          temps.push lvar = o.scope.temporary \len
          vars = "#idx = 0, #lvar = #srcPart.length"
          cond = "#idx < #lvar"
    head = 'for (' + if @object then "#idx in #srcPart" else
      step is pvar or vars += ', ' + step
      "#vars; #cond; " + if 1 == Math.abs pvar
      then (if pvar < 0 then \-- else \++) + idx
      else idx + if pvar < 0 then ' -= ' + pvar.slice 1 else ' += ' + pvar
    @own and head += ") if (#{ o.scope.assign \_own '{}.hasOwnProperty' }
                            .call(#svar, #idx)"
    head += ') {'
    @pluckDirectCalls o
    o.indent += TAB
    if @name
      head += \\n + o.indent
      item  = svar + "[#idx]"
      if @nref
        head += that + ' = ' + item + ', '
        item  = that
      head += Assign(@name, Literal item)compile(o, LEVEL_TOP) + \;
    body  = @compileBody o
    head += \\n + @tab if @name and \} is body.charAt 0
    head + body

#### Try
# Classic `try`-`catch`-`finally` block with optional `catch`.
class exports.Try extends Node
  (@attempt, @thrown ? \_e, @recovery, @ensure) ->

  children: <[ attempt recovery ensure ]>

  show: -> @thrown

  isStatement: YES

  isCallable: -> @attempt.isCallable() or @recovery?isCallable()

  jumps: -> @attempt.jumps it or @recovery?jumps it

  makeReturn: ->
    @attempt .=makeReturn it
    @recovery?=makeReturn it
    this

  compileNode: (o) ->
    o.indent += TAB
    code = "try #{@compileBlock o, @attempt}"
    if @recovery or not @ensure
      o.scope.check(v = @thrown or \e) or o.scope.add v, \catch
      code += " catch (#v) #{ @compileBlock o, @recovery }"
    if @ensure
      code += " finally #{ @compileBlock o, @ensure }"
    code

#### Switch
# Compiles to the regular JS `switch`-`case`-`default`,
# but with forced `break` after each cases.
class exports.Switch extends Node
  (@topic, @cases, @default) ->

  children: <[ topic cases default ]>

  aSource: \topic, aTargets: [\cases]

  isStatement: YES

  isCallable: ->
    return true if c.isCallable() for c of @cases
    @default?isCallable()

  jumps: (x or {+block}) ->
    return that if c.body.jumps x for c of @cases
    @default?jumps x

  makeReturn: ->
    c.makeReturn it for c of @cases
    @default?makeReturn it
    this

  compileNode: (o) ->
    {tab} = this
    topic = !!@topic and @anaphorize()compile o, LEVEL_PAREN
    code  = "switch (#topic) {\n"
    stop  = @default or @cases.length - 1
    code += c.compileCase o, tab, i is stop, !topic for c, i of @cases
    if @default
      o.indent = tab + TAB
      code += tab + "default:\n#that\n" if @default.compile o, LEVEL_TOP
    code + tab + \}

#### Case
class exports.Case extends Node
  (@tests, @body) ->

  children: <[ tests body ]>

  isCallable: -> @body.isCallable()

  makeReturn: ->
    @body.makeReturn it unless @body.lines[*-1]?value is \fallthrough
    this

  compileCase: (o, tab, nobr, bool) ->
    tests = []
    for test of @tests
      if test instanceof Arr then tests.push ...test.items else tests.push test
    tests.length or tests.push Literal \void
    if bool
      [t] = tests; i = 0; t = Op \|| t, that while tests[++i]
      tests = [(@<<<{t, aSource: \t, aTargets: [\body]})anaphorize()invert()]
    code = ''
    code += tab + "case #{ t.compile o, LEVEL_PAREN }:\n" for t of tests
    {lines} = @body; last = lines[*-1]
    lines[*-1] = JS '// fallthrough' if ft = last?value is \fallthrough
    o.indent = tab += TAB
    code += that + \\n        if @body.compile o, LEVEL_TOP
    code += tab  + 'break;\n' unless nobr or ft or last instanceof Jump
    code

#### If
# The `if`/`else` structure that acts as both statement and expression.
class exports.If extends Node
  (@if, @then, @un) ~>

  children: <[ if then else ]>

  aSource: \if, aTargets: [\then]

  show: -> @un and \!

  terminator: ''

  # Rewrites a chain of **If**s to add a default case as the final `else`.
  addElse: ->
    if @chain
    then @else.addElse it
    else @chain = (@else = it) instanceof If
    this

  ::delegate <[ isCallable isArray isString isRegex ]> ->
    @else?[it]() and @then[it]()

  jumps: -> @then.jumps it or @else?jumps it

  makeReturn: ->
    @then.=makeReturn it
    @else?=makeReturn it
    this

  compileNode: (o) ->
    if @un then @if.=invert() else @anaphorize()
    if o.level then @compileExpression o else @compileStatement o

  compileStatement: (o) ->
    code = 'if (' + @if.compile o, LEVEL_PAREN
    o.indent += TAB
    code += ') ' + @compileBlock o, Block @then
    return code unless @else
    code + ' else ' + if @chain
    then @else.compile o <<< indent: @tab, LEVEL_TOP
    else @compileBlock o, @else

  compileExpression: (o) ->
    if @void
      @then.void = true
      return Parens(Op \&& @if, @then)compile o unless @else?void = true
    code = @if.compile o, LEVEL_COND
    pad  = if @else?isComplex() then \\n + o.indent += TAB else ' '
    code += "#pad? #{ @then.compile o, LEVEL_LIST              }
             #pad: #{ @else?compile o, LEVEL_LIST  or 'void 8' }"
    if o.level < LEVEL_COND then code else "(#code)"

  unfoldSoak: -> @soak and this

  # Unfolds a node's child if soak, then tuck the node under the created **If**.
  @unfoldSoak = (o, parent, name) ->
    if parent[name]unfoldSoak o
      parent[name] = that.then
      that import then: Chain parent

#### Label
# A labeled block or statement.
class exports.Label extends Node
  (@label, @it) ->

  ::{children, isCallable, isArray} = Parens::

  show: -> @label

  isStatement : YES
  jumps       : -> @it.jumps it
  makeReturn  : -> @it.=makeReturn it; this

  compileNode: (o) ->
    {it} = this
    it.isStatement() or it = Block it
    "#{ @label or \$ }: " + if it instanceof Block
    then o.indent += TAB; @compileBlock o, it
    else it.compile o

#### JS
# Embedded JavaScript snippets.
class exports.JS extends Node
  (@code, @literal, @comment) ~>

  show: -> if @comment then @code else "`#{@code}`"

  terminator : ''

  isCallable : -> not @comment
  isRegex    : -> not @comment and \/ is @code.charAt 0

  compile: -> if @literal then entab @code, it.indent else @code

#### Util
# A wrapper node for utility functions.
class exports.Util extends Node
  (@verb) ~>

  {::show} = Jump::

  isCallable: YES

  compile: -> utility @verb

  ##### Util.Extends
  # An operator that sets up class-ical inheritance between two constructors,
  # returning the left one.
  @Extends = -> Call.make Util(\extends), @@[0 1]

#### Parser Utils
# Helpers for modifying nodes in [parser](../lib/parser.js).

exports.L = (yylineno, node) -> node import line: yylineno + 1

##### Scope
# Regulates lexical scoping within Coco. As you
# generate code, you create a tree of scopes in the same shape as the nested
# functions. Each scope knows about the function parameters and the variables
# declared within it, and has references to its parent/shared enclosing scopes.
function Scope @parent, @shared
  @variables = []
  @positions = {}
  void
Scope::<<<
  # Adds a new variable or overrides an existing one.
  add: (name, type) ->
    if @variables[@positions[name]]
    then that <<< {type}
    else @positions[name] = ~-@variables.push {name, type}
    name

  # Declares a variable unless declared already.
  declare: (name) ->
    if @shared
      return if @check name
      scope = that
    else
      scope = this
    unless (type = scope.type name) and (type of <[ var arg ]> or type.value)
      scope.add name, \var

  # Ensures that an assignment is made at the top of this scope.
  assign: (name, value) -> @add name, {value}

  # If we need to store an intermediate result, find an available name for a
  # compiler-generated variable. `_var`, `_var2`, and so on...
  temporary: (name) ->
    i = 0
    do
      temp = \_ + if name.length > 1
      then name + (if i++ then i else '')
      else (i++ + parseInt name, 36)toString 36
    until @type(temp) of [\reuse void]
    @add temp, \var

  # Allows a variable to be reused.
  free: -> @add it, \reuse

  # Checks to see if a variable has already been declared.
  # Walks up the scope if `above` flag is specified.
  check: (name, above) ->
    return found if (found = @positions[name] in @variables) or not above
    @parent?check name, above

  # Gets the type of a variable from name.
  type: -> @variables[@positions[it]]?type

  # Returns the list of variables declared in this scope.
  vars: (o) ->
    usr = []; tmp = []; asn = []
    for {name, type} of @variables
      if type of <[ var reuse ]>
        (if \_ is name.charAt 0 then tmp else usr)push name
      else if type.value
        asn.push entab name + ' = ' + type.value, o.indent
    'var ' + that if usr.concat(tmp, asn)join ', '

##### Constants

function YES  then true
function NO   then false
function THIS then this
function VOID then void

UTILITIES =
  # Creates an object's prototypal child, ensuring `__proto__`.
  clone: '''function(it){
    function fn(){ if (this.__proto__ !== it) this.__proto__ = it }
    return fn.prototype = it, new fn;
  }'''
  # Sets up `.prototype` between a pair of constructors
  # as well as `.constructor` and `.superclass` references.
  extends: '''function(sub, sup){
    function ctor(){} ctor.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new ctor).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }'''

  # Wraps a function to fixate its `this` value.
  bind: '''
    function(me, fn){ return function(){ return fn.apply(me, arguments) } }
  '''

  # Copies properties from right to left.
  import: '''function(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }'''
  importAll: '''
    function(obj, src){ for (var key in src) obj[key] = src[key]; return obj }
  '''

  repeatString: '''function(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }'''
  repeatArray: '''function(arr, n){
    for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
      if (n & 1) r.push.apply(r, arr);
    return r;
  }'''

  # Shortcuts to speed up the lookup time for native methods.
  split    : "''.split"
  replace  : "''.replace"
  toString : '{}.toString'
  join     : '[].join'
  slice    : '[].slice'
  indexOf  : '''[].indexOf || function(x){
    var i = -1, l = this.length;
    while (++i < l) if (this.hasOwnProperty(i) && this[i] === x) return i;
    return -1;
  }'''

# Each level indicates a node's position in the AST.
LEVEL_TOP    = 0  # ...;
LEVEL_PAREN  = 1  # (...)
LEVEL_LIST   = 2  # [...]
LEVEL_COND   = 3  # ... ? x : y
LEVEL_OP     = 4  # !...
LEVEL_CALL   = 5  # ...()

# Operator precedances.
PREC = \? : 0.1, unary : 0.9
PREC\&& = PREC\||                                                  = 0.2
PREC\&  = PREC\^  = PREC\|                                         = 0.3
PREC\== = PREC\!= = PREC\=== = PREC\!==                            = 0.4
PREC\<  = PREC\>  = PREC\<=  = PREC\>= = PREC\in = PREC\instanceof = 0.5
PREC\<< = PREC\>> = PREC\>>>                                       = 0.6
PREC\+  = PREC\-                                                   = 0.7
PREC\*  = PREC\/  = PREC\%                                         = 0.8

TAB = ' ' * 2

ID = /^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*$/

SIMPLENUM = /^\d+$/

##### Helpers

# Declares a utility function at the top level.
function utility then Scope.root.assign \__ + it, UTILITIES[it]

function entab code, tab then code.replace /\n/g \\n + tab
