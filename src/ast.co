# Contains all of the node classes for the AST (abstract syntax tree).
# Most nodes are created as the result of actions in the [grammar](#grammar),
# but some are created by other nodes as a method of code generation. To convert
# the syntax tree into a string of JavaScript code, call `compileRoot`.

### Node
# The abstract base class for all nodes in the syntax tree.
# Each subclass implements the `compileNode` method, which performs the
# code generation for that node. To compile a node to JavaScript,
# call `compile` on it, which wraps `compileNode` in some generic extra smarts.
# An options hash is passed and cloned throughout, containing information about
# the environment from higher in the tree (such as if a returned value is
# being requested by the surrounding function), information about the current
# scope, and indentation level.
(Node = -> ...):: =
  compile: (options, level) ->
    o = {}; continue for key, o[key] in options
    o <<< {level} if level?
    node = @unfoldSoak o or this
    # If a statement appears within an expression, wrap it in a closure.
    return node.compileClosure o if o.level and node.isStatement()
    code = (node import tab: o.indent)compileNode o
    o.scope.free tmp for tmp of that if node.temps
    code

  compileClosure: (o) ->
    # A statement that _jumps_ out of current context (like `return`) can't be
    # an expression via closure-wrapping, as its meaning will change.
    that.carp 'inconvertible statement' if @getJump!
    fun = Fun [] Block this; call = Call(); hasThis = hasArgs = false
    @traverseChildren ->
      switch it.value
      case \this      then hasThis := true
      case \arguments then hasArgs := it.value = \_args
      void
    if hasThis
      call.args.push Literal \this
      call.method = \.call
    if hasArgs
      call.args.push Literal \arguments
      fun.params.push Var \_args
    # Flag the function as `wrapper` so that it shares a scope
    # with its parent to preserve the expected lexical scope.
    Parens(Chain fun<<<{+wrapper, @void} [call]; true)compile o

  # Compiles a child node as a block statement.
  compileBlock: (o, node) ->
    if node?compile o, LEVEL_TOP then "{\n#that\n#{@tab}}" else '{}'

  # If the code generation wishes to use the result of a complex expression
  # in multiple places, ensure that the expression is only ever evaluated once,
  # by assigning it to a temporary variable.
  cache: (o, once, level) ->
    unless @isComplex()
      return [ref = if level? then @compile o, level else this, ref]
    sub = Assign ref = Var(o.scope.temporary \ref), this
    # Pass a `level` to precompile.
    if level?
      sub.=compile o, level
      o.scope.free ref.value if once
      return [sub, ref.value]
    # If flagged as `once`, the tempvar will be auto-freed.
    if once then [sub, ref <<< {+temp}] else [sub, ref, [ref.value]]

  # Compiles to a variable/source pair suitable for looping.
  compileLoopReference: (o, name, ret) ->
    if this instanceof Var   and o.scope.check @value
    or this instanceof Unary and @op of <[ + - ]> and -1/0 < +@it.value < 1/0
    or this instanceof Literal
      return [@compile o] * 2
    asn = Assign Var(tmp = o.scope.temporary name), this
    ret or asn.void = true
    [tmp; asn.compile o, if ret then LEVEL_CALL else LEVEL_PAREN]

  # Passes each child to a function, returning its return value if exists.
  eachChild: (fn) ->
    for name of @children then if child = @[name]
      if \length in child
      then return that if fn(node )? for node of child
      else return that if fn(child)?
    void

  # Performs `eachChild` on every descendant.
  # Overridden by __Fun__ not to cross scope by default.
  traverseChildren: (fn, xscope) ->
    @eachChild -> if fn(it)? then that else it.traverseChildren fn, xscope

  # Performs anaphoric conversion if a `that` is found within `@aTargets`.
  anaphorize: ->
    @children = @aTargets
    if @eachChild hasThat
      if (base = this)[name = @aSource] instanceof Existence
        base.=[name]; name = \it
      unless base[name]value is \that
        base[name] = Assign Var(\that), base[name]
    function hasThat
      it.value is \that or if it.aSource
      then hasThat that if it[that]
      else it.eachChild hasThat
    delete @children
    @[@aSource] <<< {+cond}

  # Throws a syntax error, appending `@line` number to the message.
  carp: ->
    throw SyntaxError "#it on line #{ @line or @traverseChildren -> it.line }"

  # Defines delegaters.
  delegate: (names, fn) ->
    for name of names then let
      @[name] = -> fn.call this, name, it
    void

  # Default implementations of the common node properties and methods. Nodes
  # will override these with custom logic, if needed.
  children: []

  terminator: \;

  isComplex: YES

  isStatement  : NO
  isAssignable : NO
  isCallable   : NO
  isEmpty      : NO
  isArray      : NO
  isString     : NO
  isRegex      : NO

  isMatcher: -> @isString() or @isRegex()

  # Do I assign a certain variable?
  assigns: NO

  # Picks up name(s) from LHS.
  ripName: VOID

  unfoldSoak   : VOID
  unfoldAssign : VOID
  unwrap       : THIS
  maybeKey     : THIS
  expandSlice  : THIS
  varName      : String
  getCall      : VOID
  getDefault   : VOID
  # Digs up a statement that jumps out of this node.
  getJump      : VOID

  invert: -> Unary \! this, true

  # Constructs a node that returns the current node's result.
  makeReturn: (arref) ->
    if arref then Call.make JS(arref + \.push), [this] else Return this

  # Extra info for `toString`.
  show: String

  # String representation of the node for inspecting the parse tree.
  # This is what `coco --ast` prints out.
  toString: (idt or '') ->
    tree  = \\n + idt + @..displayName
    tree += ' ' + that if @show()
    @eachChild -> tree += it.toString idt + TAB; void
    tree

  # JSON serialization
  stringify : (space) -> JSON.stringify this, null space
  toJSON    : -> {type: @..displayName, ...this}

# JSON deserialization
exports.parse    = (json) -> exports.fromJSON JSON.parse json
exports.fromJSON = function
  return it unless it and typeof it is \object
  if it.type
    node = ^exports[that]::
    node[key] = fromJSON val for key, val in it
    return node
  if it.length? then fromJSON v for v of it else it

#### Modules

Negatable =
  show   : -> @negated and \!
  invert : -> @negated ^= 1; this

#### Block
# A list of expressions that forms the body of an indented block of code.
class exports.Block extends Node
  (node) ~>
    return node if node instanceof Block
    @lines = []
    @add node if node

  children: [\lines]

  toJSON: -> delete @back; super!

  add: ->
    switch
    case @back    then that.add it
    case it.lines then @lines.push ...that
    default
      @lines.push it
      @back = that if delete it.back
    this

  prepend: ->
    {lines} = this; i = -1
    break unless that.comment or that instanceof Literal while lines[++i]
    lines.splice i, 0, ...arguments
    this

  pipe: -> @lines.push Assign(Var \_; @lines.pop!), it; this

  unwrap: -> if @lines.length is 1 then @lines.0 else this

  # Removes trailing comment nodes.
  chomp: ->
    {lines} = this; i = lines.length
    break unless that.comment while lines[--i]
    lines.length = i + 1
    this

  isComplex: -> @lines.length > 1 or @lines.0?isComplex()

  ::delegate <[ isCallable isArray isString isRegex ]> -> @lines[*-1]?[it]()

  getJump: -> return that if node.getJump it for node of @lines

  # **Block** does not return its entire body, rather it
  # ensures that the final line is returned.
  makeReturn: ->
    if @lines[*-1]?=makeReturn it
      --@lines.length if that instanceof Return and not that.it
    this

  compile: (o, level ? o.level) ->
    return @compileExpressions o, level if level
    o.block = this; tab = o.indent
    codes = for node of @lines
      node = node.unfoldSoak o or node
      code = tab + (node <<< {+front})compile o, level
      if node.isStatement! then code else code + node.terminator
    codes.join \\n

  # **Block** is the only node that can serve as the root.
  compileRoot: (options) ->
    o = {level: LEVEL_TOP, scope: @scope = Scope.root = new Scope, ...options}
    delete o.filename
    o.indent = if bare = delete o.bare then '' else TAB
    if /^\s*(?:[/#]|javascript:)/test @lines.0?code
      prefix = @lines.shift()code + \\n
    if delete o.repl and @chomp!lines.length
      if bare then @lines.push Parens @lines.pop! else @makeReturn!
    code = @compileWithDeclarations o
    # Wrap everything in a safety closure unless requested not to.
    bare or code = "(function(){\n#code\n}).call(this);\n"
    ([prefix]) + code

  # Compile to a function body.
  compileWithDeclarations: (o) ->
    o.level = LEVEL_TOP
    pre = ''
    break unless node.comment or node instanceof Literal for node, i of @lines
    if i
      rest   = @lines.splice i, 9e9
      pre    = @compile o
      @lines = rest
    return pre unless post = @compile o
    (pre and "#pre\n") + if @scope then that.emit post, o.indent else post

  # Compile to a comma-separated list of expressions.
  compileExpressions: (o, level) ->
    {lines} = this; i = -1
    lines.splice i-- 1 if that.comment while lines[++i]
    lines.push Literal \void unless lines.length
    lines.0 <<< {@front}; lines[*-1] <<< {@void}
    return lines.0.compile o, level unless lines.1
    code = ''; last = lines.pop!
    code += (node <<< {+\void})compile(o, LEVEL_PAREN) + ', ' for node of lines
    code += last.compile o, LEVEL_PAREN
    if level < LEVEL_LIST then code else "(#code)"

#### Atom
# An abstract node for simple values.
class Atom extends Node
  show      : -> @value
  isComplex : NO

#### Literal
# `this`, `debugger`, and primitives.
class exports.Literal extends Atom
  (@value) ~>
    return JS "#value" true if value.js
    return new Super        if value is \super

  isEmpty    : -> switch @value case \void \null then true
  isCallable : -> switch @value case \this \eval then true
  isString   : -> 0 <= '\'"'indexOf "#{@value}"charAt()

  varName: -> if /^\w+$/test @value then \$ + @value else ''

  compile: (o, level ? o.level) ->
    switch val = "#{@value}"
    case \this then return o.scope.fun?bound or val
    case \void then val += ' 8'; fallthrough
    case \null then @carp 'invalid use of ' + @value if level is LEVEL_CALL
    case \debugger then if level
      return "(function(){\n#{ o.indent + TAB }debugger;\n#{o.indent}}())"
    case \* then @carp 'stray star'
    val

#### Var
# Variables.
class exports.Var extends Atom
  (@value) ~>

  ::isAssignable = ::isCallable = YES

  assigns: -> it is @value

  maybeKey: -> Key(@value) <<< {@line}

  varName: ::show

  compile: (o) -> if @temp then o.scope.free @value else @value

#### Key
# The name of a property, in the form of `{key: _}` or `_.key`.
class exports.Key extends Atom
  (name, @reserved or name.reserved) ~> @name = '' + name

  isAssignable: -> not @reserved

  assigns: -> it is @name

  varName: ->
    {name} = this
    (if @reserved or name of <[ arguments eval ]> then \$ else '') + name

  compile: ::show = -> if @reserved then "'#{@name}'" else @name

#### Index
# Dots and brackets to access an object's property.
class exports.Index extends Node
  (key, symbol or \., init) ~>
    if init and key instanceof Arr
      switch key.items.length
      case 0 then key = Key \__proto__
      case 1 then key = Parens k unless (k = key.items.0) instanceof Splat
    switch symbol.slice -1
    case \= then @assign = symbol.slice 1
    case \@ then @vivify = (if symbol.length > 2 then Arr else Obj)
    import {key, symbol}

  children: [\key]

  show: -> (@soak or '') + @symbol

  isComplex: -> @key.isComplex()

  varName: -> @key instanceof [Key, Literal] and @key.varName()

  compile: (o) ->
    code = @key.compile o, LEVEL_PAREN
    if @key instanceof Key and \' is not code.charAt 0
    then ".#code" else "[#code]"

#### Chain
# Acts as a container for property-access/function-call chains, by holding
# __Index__ or __Call__ instances as `@tails`.
class exports.Chain extends Node
  (head, tails) ~>
    return head if not tails and head instanceof Chain
    import {head, tails or []}

  children: <[ head tails ]>

  add: ->
    if @head instanceof Existence
      {@head, @tails} = Chain @head.it
      it.soak = true
    @tails.push it
    if it instanceof Call and not it.method and @head instanceof Super
      it.method = \.call; it.args.unshift Literal \this
    else if delete it.vivify
      @head = Assign Chain(@head, @tails.splice 0, 9e9), that(), \= \||
    this

  # __Chain__ can be unwrapped as its inner node, if there are no subnodes.
  unwrap: -> if @tails.length then this else @head

  ::delegate <[ getJump assigns isStatement isString ]>
           , (it, arg) -> not @tails.length and @head[it] arg

  isComplex  : -> @tails.length or @head.isComplex()
  isCallable : ->
    if @tails[*-1] then not that.key?items else @head.isCallable()
  isArray    : ->
    if @tails[*-1] then that.key instanceof Arr else @head.isArray()
  isRegex    : ->
    @head.value is \RegExp and not @tails.1 and @tails.0 instanceof Call

  isAssignable: ->
    return @head.isAssignable() unless tail = @tails[*-1]
    return false if tail not instanceof Index or tail.key instanceof List
    return false if tail.assign for tail of @tails
    true

  # `@$` `o.0`
  isSimpleAccess: ->
    @tails.length is 1 and not @head.isComplex() and not @tails.0.isComplex()

  makeReturn: -> if @tails.length then super ... else @head.makeReturn it

  getCall: -> (tail = @tails[*-1]) instanceof Call and tail

  varName: -> @tails[*-1]?varName()

  # A reference has base part (`this` value) and name part.
  # We cache them separately for compiling complex expressions, so that e.g.
  #
  #     a()[b()] ||= c
  #
  # compiles to
  #
  #     (_ref = a())[_key = b()] || (_ref[_key] = c);
  #
  cacheReference: (o) ->
    name = @tails[*-1]
    # `a.b()`
    return @cache o, true if name instanceof Call
    # `a` `a.b`
    if @tails.length < 2 and not @head.isComplex() and not name?isComplex()
      return [this] * 2
    base = Chain @head, @tails.slice 0 -1
    # `a().b`
    if base.isComplex()
      ref  = o.scope.temporary \ref
      base = Chain Assign Var(ref), base
      bref = Var(ref) <<< {+temp}
    # `a{}`
    return [base, bref] unless name
    # `a[b()]`
    if name.isComplex()
      ref  = o.scope.temporary \key
      name = Index Assign Var(ref), name.key
      nref = Index Var(ref) <<< {+temp}
    [base.add name; Chain bref || base.head, [nref or name]]

  compileNode: (o) ->
    {head, tails} = this; head <<< {@front, @newed}
    return head.compile o unless tails.length
    return that.compile o if @unfoldAssign o
    @carp 'invalid callee' if tails.0 instanceof Call and not head.isCallable!
    @expandSlice o; @expandBind o; @expandSplat o; @expandStar o
    return @head.compile o unless @tails.length
    base = @head.compile o, LEVEL_CALL; news = rest = ''
    for t of @tails
      news += 'new ' if t.new
      rest += t.compile o
    base += ' ' if \. is rest.charAt 0 and SIMPLENUM.test base
    news + base + rest

  # Unfolds a soak into an __If__: `a?.b` => `a.b if a?`
  unfoldSoak: (o) ->
    if @head.unfoldSoak o
      that.then.tails.push ...@tails
      return that
    for node, i of @tails then if delete node.soak
      bust = Chain @head, @tails.splice 0 i
      test = if node instanceof Call
        [test, @head] = bust.cacheReference o
        JS "typeof #{ test.compile o, LEVEL_OP } == 'function'"
      else
        if i and node.assign
          [test, bust] = bust.cacheReference o
          @head = bust.head; @tails.unshift ...bust.tails
        else
          [test, @head] = bust.unwrap()cache o, true
        Existence test
      return If(test, this) <<< {+soak, @cond, @void}
    void

  unfoldAssign: (o) ->
    if @head.unfoldAssign o
      that.right.tails.push ...@tails
      return that
    for index, i of @tails then if index.assign
      index.assign = ''
      [left, @head] = Chain(@head, @tails.splice 0 i)cacheReference o
      return Assign(left, this, that) <<< {+access}
    void

  expandSplat: (o) ->
    {tails} = this; i = -1; while call = tails[++i]
      continue unless args = call.args
      ctx = call.method is \.call and (args.=concat())shift()
      continue unless args = Splat.compileArray o, args, true
      @carp 'splatting "new"' if call.new
      if not ctx and tails[i-1] instanceof Index
        [@head, ctx] = Chain(@head, tails.splice 0 i-1)cache o, true
        i = 0
      call <<< method: \.apply, args: [ctx or Literal \null; JS args]
    void

  expandBind: (o) ->
    {tails} = this; i = -1; while tails[++i]
      continue unless that.symbol is \.~
      that.symbol = ''
      args   = Chain(@head, tails.splice 0 i)unwrap()cache o, true
      args.1 = Chain args.1, [tails.shift()]
      call   = Call.make Util(\bind), args
      @head  = if @newed then Parens call, true else call
      i = -1
    void

  expandStar: (o) ->
    {tails} = this; i = -1; while tails[++i]
      continue if that.args or that.stars or that.key instanceof Key
      stars = that.stars = []
      that.eachChild seek
      continue unless stars.length
      [sub, ref, temps] = Chain(@head, tails.splice 0 i)unwrap!cache o
      value = Chain(ref, [Index Key \length])compile o
      star <<< {value, isAssignable: YES} for star of stars
      @head = JS sub.compile(o, LEVEL_CALL) + tails.shift!compile o
      o.scope.free temps.0 if temps
      i = -1
    function seek
      if it.value is \*               then stars.push it
      else unless it instanceof Index then it.eachChild seek
      void
    void

  # `a[x, y] = b{z} = c` => `[a[x], a[y]] = {z: b.z} = c`
  expandSlice: (o, assign) ->
    {tails} = this; i = -1; while tail = tails[++i] then if tail.key?items
      tail.carp 'calling a slice' if tails[i+1] instanceof Call
      tails.splice 0 i+1 => _.pop!key.toSlice o, Chain(@head, _)unwrap!, assign
      => @head = _ <<< {@front}
      i = -1
    this

#### Call
# `x(y)`
class exports.Call extends Node
  (args || []) ~>
    if args.length is 1 and args.0.filler
      @method = \.call; args <<< [Literal \this; Splat Literal \arguments]
    import {args}

  children: [\args]

  show: -> ([@new]) + ([@method]) + ([\? if @soak])

  compile: (o) ->
    code  = (@method or '') + \(
    code += (if i then ', ' else '')+ a.compile o, LEVEL_LIST for a, i of @args
    code + \)

  @make = (callee, args) -> Chain(callee)add Call args

  @block = (fun, args, method) ->
    Parens(Chain fun, [Call(args) <<< {method}]; true) <<< {+calling}

  @back = (params, node, bound) ->
    {args} = node.getCall! or (node = Chain node .add Call!)getCall!
    break if arg.filler for arg, idx of args
    node <<< back: (args[idx] = Fun params, null, bound)body

  @let = (args, body) ->
    params = for a, i of args
      if a.op is \= and not a.logic
      then args[i] = a.right; a.left
      else Var a.varName() || a.carp 'invalid "let" argument'
    args.unshift Literal \this
    @block Fun(params, body), args, \.call

#### List
# An abstract node for a list of comma-separated items.
class List extends Node
  children: [\items]

  show  : -> @name
  named : (@name) -> this

  isEmpty : -> not @items.length
  assigns : -> return true if node.assigns it for node of @items

  @compile = (o, items) ->
    switch items.length
    case 0 then return ''
    case 1 then return items.0.compile o, LEVEL_LIST
    {indent, level} = o
    o <<< indent: indent + TAB, level: LEVEL_LIST
    code  = items[i = 0]compile o
    code += ', ' + that.compile o while items[++i]
    code  = "\n#{o.indent}#code\n#indent" if ~code.indexOf \\n
    o <<< {indent, level}
    code

#### Obj
# `{x: y}`
class exports.Obj extends List
  (@items or []) ~>

  asObj: THIS

  # `base{x: y}` => `{x: base.y}`
  toSlice: (o, base, assign) ->
    {items} = this
    if items.length > 1 then [base, ref, temps] = base.cache o else ref = base
    for node, i of items
      continue if node.comment
      if node instanceof [Prop, Splat]
        node[name = node.children[*-1]] =
          chain = Chain base, [Index node[name]maybeKey()]
      else
        # `o{k or v}` => `{k: a.k or v}`
        node.=first if logic = node.getDefault!
        if node instanceof Parens
          # `a{(++i)}` => `{(_ref = ++i): a[_ref]}`
          [key, node] = node.cache o, true
          # `a{(++i)} = b` => `{(_ref): a[_ref = ++i]} = b`
          #                => `a[_ref = ++i] = b[_ref]`
          [key, node] = [node, key] if assign
          key = Parens key
        else key = node
        val = chain = Chain base, [Index node.maybeKey()]
        val = logic <<< {first: val} if logic
        items[i] = Prop key, val
      base = ref
    chain or @carp 'empty slice'
    (chain.head = Var temps.0)temp = true if temps
    this

  compileNode: (o) ->
    {items} = this
    return (if @front then '({})' else '{}') unless items.length
    code = ''; idt = \\n + o.indent += TAB; dic = {}
    for node, i of items
      if node.comment
        code += idt + node.compile o
        continue
      node.=first if logic = node.getDefault!
      if node instanceof Splat or (node.key or node) instanceof Parens
        rest = items.slice i
        break
      if logic
        # `{@a or b}` => `{a: @a or b}`
        if node instanceof Prop
        then node.val = logic <<< first: node.val
        else node = Prop node, logic <<< first: node
      if multi then code += \, else multi = true
      code += idt + if node instanceof Prop
        {key, val} = node
        if val.accessor
          key = "#{ if val.params.length then val.void = \set else \get }
               \ #{ key.compile o }"
          key + val.compile(o, LEVEL_LIST)slice 8
        else
          val.ripName key
          "#{ key.=compile o }: #{ val.compile o, LEVEL_LIST }"
      else
        "#{ key = node.compile o }: #key"
      node.carp "duplicate property name \"#key\"" unless dic[0 + key] ^= 1
    code = "{#{ code and code + \\n + @tab }}"
    rest and code = Import(JS code; Obj rest)compile o <<< indent: @tab
    if @front and \{ is code.charAt! then "(#code)" else code

#### Prop
# `x: y`
class exports.Prop extends Node
  (@key, val) ~>
    val.=it <<< {\accessor} if val.op is \~ and val.it instanceof Fun
    import {val}

  children: <[ key val ]>

  show: -> @val.accessor

  assigns: -> @val.assigns it

#### Arr
# `[x, y]`
class exports.Arr extends List
  (@items or []) ~>

  isArray: YES

  asObj: -> Obj(Prop Literal(i), item for item, i of @items)

  # `base[x, ...y]` => `[base[x], ...base[y]]`
  toSlice: (o, base) ->
    {items} = this
    if items.length > 1 then [base, ref, temps] = base.cache o else ref = base
    for item, i of items
      item.=it if splat = item instanceof Splat
      continue if item.isEmpty()
      chain = Chain base, [Index item]
      items[i] = if splat then Splat chain else chain
      base = ref
    chain or @carp 'empty slice'
    (chain.head = Var temps.0)temp = true if temps
    this

  compile: (o) ->
    {items} = this
    return '[]' unless items.length
    if code = Splat.compileArray o, items
      return if @newed then "(#code)" else code
    "[#{ List.compile o, items }]"

  @maybe = (nodes) ->
    return nodes.0 if nodes.length is 1 and nodes.0 not instanceof Splat
    .. nodes

  @wrap = -> .. [Splat it <<< isArray: YES]

#### Unary operators
class exports.Unary extends Node
  # `flag` denotes inversion or postcrement.
  (op, it, flag) ~>
    if not flag and it.unaries
      that.push op
      return it
    switch op
    case \!      then return it.invert! unless flag
    case \++ \-- then @post = true if flag
    case \new
      # `new C?` => `new C?()`
      if it instanceof Existence and not it.negated
        it = Chain(it)add Call!
      it.newed = true
      for node of it.tails or ''
        if node instanceof Call and not node.new
          node.args.shift() if node.method is \.call
          node <<< {\new, method: ''}
          return it
    case \~ then if it instanceof Fun and it.statement and not it.bound
      return it <<< bound: \_this
    import {op, it}

  children: [\it]

  show: -> ([\@ if @post]) + @op

  isCallable: -> @op of <[ do new delete ]>

  isArray: -> @it instanceof Arr   and @it.items.length
           or @it instanceof Chain and @it.isArray!

  isString: -> @op of <[ typeof classof ]>

  invert: ->
    return @it if @op is \! and @it.op of <[ ! < > <= >= in instanceof ]>
    .. \! this, true

  unfoldSoak: (o) ->
    @op of <[ ++ -- delete ]> and If.unfoldSoak o, this, \it

  function crement then {'++':\in '--':\de}[it] + \crement

  compileNode: (o) ->
    return that if @compileSpread o
    {op, it} = this
    switch op
    case \!   then it.cond = true
    case \new then it.isCallable() or it.carp 'invalid constructor'
    case \do
      # `do f?` => `f?()`
      Parens if it instanceof Existence and not it.negated
        then Chain(it)add Call! else Call.make it
      => return (_ <<< {@front, @newed})compile o
    case \delete
      @carp 'invalid delete' if it instanceof Var or not it.isAssignable!
      return @compilePluck o if o.level and not @void
    case \++ \--
      it.isAssignable! or @carp 'invalid ' + crement op
      if it instanceof Var and not o.scope.check it.value, true
        @carp "#{ crement op } of undeclared variable \"#{it.value}\""
      it{front} = this if @post
    case \^ then return "#{ utility \clone }(#{ it.compile o, LEVEL_LIST })"
    case \classof
      return "#{ utility \toString }.call(
              #{ it.compile o, LEVEL_LIST }).slice(8, -1)"
    code = it.compile o, LEVEL_OP + PREC.unary
    if @post then code += op else
      op += ' ' if op of <[ new typeof delete ]>
                or op of <[ + - ]> and op is code.charAt!
      code = op + code
    if o.level < LEVEL_CALL then code else "(#code)"

  # `^delete o[p, ...q]` => `[^delete o[p], ...^delete o[q]]`
  compileSpread: (o) ->
    {it} = this; ops = [this]
    ops.push it while it instanceof .., it.=it
    return '' unless it.=expandSlice(o)unwrap! instanceof Arr
                 and (them = it.items)length
    for node, i of them
      node.=it if sp = node instanceof Splat
      node = .. op.op, node, op.post for op of ops by -1
      them[i] = if sp then lat = Splat node else node
    if not lat and (@void or not o.level)
      it = ^Block::<<< {lines: them, @front, +\void}
    it.compile o, LEVEL_PAREN

  # `v = delete o.k`
  compilePluck: (o) ->
    [get, del] = Chain @it .cacheReference o
    code = if @assigned then '' else "#{ ref = o.scope.temporary \ref } = "
    code +=   "#{ get.compile o, LEVEL_LIST }
      , delete #{ del.compile o, LEVEL_LIST }"
    return code if @assigned
    code += ", #{ o.scope.free ref }"
    if o.level < LEVEL_LIST then code else "(#code)"

#### Binary operators
class exports.Binary extends Node
  (op, first, second) ~>
    switch op
    case \of then return new Of first, second
    case \+
      if first instanceof Arr
        first.items.push Splat second
        return first
      if second instanceof Arr
      or second instanceof While and second = Arr [Splat second]
        second.items.unshift Splat first
        return second
    import {op, first, second}

  children: <[ first second ]>

  show: -> @op

  isCallable: ->
    @op of <[ && || ? !? ]> and @first.isCallable! and @second.isCallable!

  isArray: -> switch @op
    case \* then return @first instanceof Arr
    case \/ then return @second.isMatcher!

  isString: -> switch @op
    case \+ \* then @first.isString! or @second.isString!
    case \-    then @second.isMatcher!

  EQUALITY = /^[!=]==?$/
  COMPARER = /^(?:[!=]=|[<>])=?$/

  invert: ->
    if EQUALITY.test op = @op and not COMPARER.test @second.op
      @op = '!='charAt(op.indexOf \=) + op.slice 1
      return this
    Unary \! Parens(this), true

  getDefault: -> switch @op case \? \|| \&& \!? then this

  compileNode: (o) ->
    switch @op
    case \? \!? then return @compileExistence o
    case \*
      return @compileJoin   o if @second.isString()
      return @compileRepeat o if @first.isString() or @first instanceof Arr
    case \-  then return @compileRemove o if @second.isMatcher()
    case \/  then return @compileSplit  o if @second.isMatcher()
    case \** then return @compilePow o
    case \<? \>? then return @compileMinMax o
    case \&& \||
      @second.void = true if top = @void or not o.level
      if top or @cond
        @first .cond = true
        @second.cond = true
    case \instanceof
      {items}:rite = @second.expandSlice(o)unwrap!
      if rite instanceof Arr
        return @compileAnyInstanceOf o, items if items.1
        @second = items.0 or rite
      @second.isCallable! or @second.carp 'invalid instanceof operand'
    default
      return @compileChain o if COMPARER.test @op and COMPARER.test @second.op
    @first <<< {@front}
    code = "#{ @first .compile o, level = LEVEL_OP + PREC[@op] } #{@op} \
            #{ @second.compile o, level }"
    if o.level <= level then code else "(#code)"

  # Mimic Python's chained comparisons when multiple comparison operators are
  # used sequentially. e.g.:
  #
  #     $ coco -e '50 < 65 === 9r72 > 10'
  #     true
  #
  # See <http://docs.python.org/reference/expressions.html#notin>.
  compileChain: (o) ->
    code = @first.compile o, level = LEVEL_OP + PREC[@op]
    [sub, @second.first] = @second.first.cache o, true
    code += " #{@op} #{ sub    .compile o, level    } && \
                     #{ @second.compile o, LEVEL_OP }"
    if o.level <= LEVEL_OP then code else "(#code)"

  compileExistence: (o) ->
    if @op is \!?
      If(Existence @first; @second) <<< {@cond, @void or not o.level}
      => return _.compileExpression o
    if @void or not o.level
      Binary \&& Existence(@first, true), @second
      => return (_ <<< {+\void})compileNode o
    @first.cache o, true
    => If(Existence _.0; _.1)addElse(@second)compileExpression o

  # `x instanceof [A, B]` => `x instanceof A || x instanceof B`
  compileAnyInstanceOf: (o, items) ->
    [sub, ref, @temps] = @first.cache o
    test = Binary \instanceof sub, items.shift!
    test = Binary \|| test, Binary \instanceof ref, item for item of items
    Parens test .compile o

  compileMinMax: (o) ->
    lefts = @first .cache o, true
    rites = @second.cache o, true
    Binary @op.charAt!, lefts.0, rites.0
    => If _, lefts.1 .addElse rites.1 .compileExpression o

  compileMethod: (o, klass, method, arg) ->
    args = [@second]concat arg || []
    if @first"is#klass"()
      Chain(@first, [Index Key method; Call args])compile o
    else
      args.unshift @first
      Call.make(JS utility(method) + \.call; args)compile o

  compileJoin   : -> @compileMethod it, \Array  \join
  compileRemove : -> @compileMethod it, \String \replace JS "''"
  compileSplit  : -> @compileMethod it, \String \split

  compileRepeat: (o) ->
    {first: x, second: n} = this; {items} = x
    if (x = JS that if items and Splat.compileArray o, items)
    or not (n instanceof Literal and n.value < 0x20)
      x = Call.make Util(\repeat + if items then \Array else \String), [x, n]
      return x.compile o
    n = +n.value
    return x.compile o if 1 <= n < 2
    # `[x] * 2` => `[x, x]`
    if items
      if n < 1 then return (^Block::<<< lines: items)add(JS '[]')compile o
      refs = []
      [items[i], refs.*] = item.cache o, 1x for item, i of items
      items.push JS() <<<
        compile: -> (", #{ List.compile o, refs }" * (n-1))slice 2
      x.compile o
    # `'x' * 2` => `'xx'`
    else if x instanceof Literal
      (q = (x.=compile o)charAt()) + "#{ x.slice 1 -1 }" * n + q
    # `"#{x}" * 2` => `(_ref = "" + x) + _ref`
    else
      if n < 1 then return Block(x.it)add(JS "''")compile o
      x = (refs = x.cache o, 1, LEVEL_OP)0 + " + #{refs.1}" * (n-1)
      if o.level < LEVEL_OP + PREC\+ then x else "(#x)"

  compilePow: (o) -> Call.make(JS \Math.pow; [@first, @second])compile o

#### Assign
# Assignment to a variable/property.
class exports.Assign extends Node
  (@left, rite, @op or \=, @logic or @op.logic) ~>
    @op += ''
    @[if rite instanceof Node then \right else \unaries] = rite

  children: <[ left right ]>

  show: -> (@logic or '') + @op

  assigns: -> @left.assigns it

  ::delegate <[ isCallable isRegex ]> -> @op of <[ = := ]> and @right[it]!

  isArray: -> switch @op
    case \= \:= \+= then do @right.isArray
    case \/=        then do @right.isMatcher

  isString: -> switch @op
    case \= \:= \+= \*= then do @right.isString
    case \-=            then do @right.isMatcher

  unfoldSoak: (o) ->
    if @left instanceof Existence
      # `[a, b]? = c` => `[a, b] = c if c?`
      if delete (@left.=it)name
      then rite = @right; rite = Assign @right = Var(that), rite
      else [rite, @right, temps] = @right.cache o
      return If(Existence rite; this) <<< {temps, @cond, @void}
    If.unfoldSoak o, this, \left

  unfoldAssign: -> @access and this

  compileNode: (o) ->
    left = @left.expandSlice(o, true)unwrap!
    unless @right
      left.isAssignable! or left.carp 'invalid unary assign'
      [left, @right] = Chain left .cacheReference o
      @right = Unary op, @right for op of @unaries
    return (Parens(@right) <<< {@front, @newed})compile o if left.isEmpty!
    return @compileDestructuring o, left if left.items
    return @compileConditional   o, left if @logic
    {op, right} = this
    if left.getDefault!
      right = Binary left.op, right, left.second
      left.=first
    left.isAssignable() or left.carp 'invalid assign'
    return @compileMinMax o, left, right if op of <[ <?= >?= ]>
    if op is \**=
    or op is \+= and right instanceof [Arr, While]
    or op is \*= and right.isString()
    or op of <[ -= /= ]> and right.isMatcher()
      [left, reft] = Chain(left)cacheReference o
      right = Binary op.slice(0 -1), reft, right
      op    = \:=
    right.=it while right instanceof Parens and not right.keep
    right.ripName left.=unwrap()
    lvar = left instanceof Var
    sign = op.replace \: ''
    name = (left <<< {+front})compile o, LEVEL_LIST
    code = if not o.level and right instanceof While and not right.else and
              (lvar or left.isSimpleAccess())
      # Optimize `a = while ...`.
      """#{ res = o.scope.temporary \res } = [];
         #{@tab}#{ right.makeReturn(res)compile o }
         #{@tab}#name #sign #{ o.scope.free res }"""
    else
      "#name #sign " + (right <<< {+assigned})compile o, LEVEL_LIST
    if lvar
      del = right.op is \delete
      if op is \=
        o.scope.declare name
      else unless o.scope.check name, true
        left.carp "assignment to undeclared variable \"#name\""
    if o.level
      code += ", #name" if del
      code  = "(#code)" if that > (if del then LEVEL_PAREN else LEVEL_LIST)
    code

  compileConditional: (o, left) ->
    if left instanceof Var and @logic of <[ ? !? ]> and @op is \=
      o.scope.declare left.value
    lefts = Chain(left)cacheReference o
    morph = Binary @logic, lefts.0, @<<<{-logic, left: lefts.1}
    (morph <<< {@void})compileNode o

  compileMinMax: (o, left, right) ->
    lefts = Chain(left)cacheReference o
    rites = right.cache o, true
    test  = Binary @op.replace(\? ''), lefts.0, rites.0
    put   = Assign lefts.1, rites.1, \:=
    # `a <?= b` => `a <= b || a = b `
    return Parens(Binary \|| test, put)compile o if @void or not o.level
    # `r = a <?= b` => `r = if a <= b then a else a = b`
    [test.second, left] = test.second.cache o, true
    If test, left .addElse put .compileExpression o

  # Implementation of recursive destructuring,
  # when assigning to an array or object literal.
  # See <http://wiki.ecmascript.org/doku.php?id=harmony:destructuring>.
  compileDestructuring: (o, left) ->
    {items} = left; len = items.length; ret = o.level and not @void
    rite = @right.compile o, if len is 1 then LEVEL_CALL else LEVEL_LIST
    if left.name
      cache = "#that = #rite"
      o.scope.declare rite = that
    else if (ret or len > 1) and (not ID.test rite or left.assigns rite)
      cache = "#{ rref = o.scope.temporary \ref } = #rite"
      rite  = rref
    list = @"rend#{ left..displayName }" o, items, rite
    o.scope.free rref  if rref
    list.unshift cache if cache
    list.push rite     if ret or not list.length
    code = list.join ', '
    if list.length < 2 or o.level < LEVEL_LIST then code else "(#code)"

  rendArr: (o, nodes, rite) ->
    for node, i of nodes
      continue if node.isEmpty()
      if node instanceof Splat
        len and node.carp 'multiple splat in an assignment'
        skip = (node.=it)isEmpty()
        if i+1 is len = nodes.length
          break if skip
          val = Arr.wrap JS \
            utility(\slice) + \.call( + rite + if i then ", #i)" else \)
        else
          val = ivar = "#rite.length - #{ len - i - 1 }"
          # Optimize `[..., a] = b`.
          continue if skip and i+2 is len
          start = i+1; @temps = [ivar = o.scope.temporary \i]
          val = if skip then node = Var ivar; Var val else
            Arr.wrap JS "#i < (#ivar = #val)
                       \ ? #{ utility \slice }.call(#rite, #i, #ivar)
                       \ : (#ivar = #i, [])"
      else
        (inc = ivar) and start < i and inc += " + #{ i - start }"
        val = Chain rcache||=Literal(rite), [Index JS inc || i]
      (^@<<<{left: node, right: val, +\void})compile o, LEVEL_PAREN

  rendObj: (o, nodes, rite) ->
    for node of nodes
      node.=it if splat = node instanceof Splat
      # `{a or b} = c` => `a = c.a or b`
      node.=first if logic = node.getDefault!
      if node instanceof Parens
        [node, key] = Chain(node.it)cacheReference o
      else if node instanceof Prop
      then node = ({key} = node)val
      else key  = node
      node = Var node.name if node instanceof Key
      node = logic <<< {first: node} if logic
      val  = Chain rcache||=Var(rite), [Index key.maybeKey()]
      val  = Import Obj(), val if splat
      (^@<<<{left: node, right: val, +\void})compile o, LEVEL_PAREN

#### Import
# Copies properties from right to left.
class exports.Import extends Node
  (@left, @right, @all and \All) ~>
    if not all and left instanceof Obj and right.items
      return Obj left.items.concat right.asObj()items

  children: <[ left right ]>

  show: -> @all

  ::delegate <[ isCallable isArray ]> -> @left[it]()

  unfoldSoak: (o) ->
    {left} = this
    if left instanceof Existence and not left.negated
      [left.it, @left, temps] = left.it.cache o
      # Optimize non-var cases.
      left.=it if temps
      return If(left, this) <<< {temps, +soak, @cond, @void}
    If.unfoldSoak o, this, \left
    or (@void or not o.level) and
    If.unfoldSoak o, this, \right

  compileNode: (o) ->
    {right} = this
    unless @all
      if right instanceof Chain
        right = right.unfoldSoak o or right.unfoldAssign o or
                right.expandSlice(o)unwrap!
      return @compileAssign o, right.asObj!items if right instanceof List
    Call.make Util("import#{ @all or '' }"), [@left, right] .compileNode o

  # If the right operand of `<<<` is an object or array literal,
  # expand it to a series of assignments.
  compileAssign: (o, items) ->
    return @left.compile o unless items.length
    top = not o.level
    if items.length < 2 and (top or @void or items.0 instanceof Splat)
    then reft = Parens @left
    else [left, reft, @temps] = @left.cache o
    [delim, space] = if top then [\; \\n + @tab] else [\, ' ']
    delim += space
    code = if @temps then left.compile(o, LEVEL_PAREN) + delim else ''
    for node, i of items
      i and code += if com then space else delim
      if com = node.comment
        code += node.compile o
        continue
      if node instanceof Splat
        code += Import(reft, node.it)compile o
        continue
      node.=first if logic = node.getDefault!
      if dyna = node instanceof Parens
        [key, val] = node.it.cache o, true
      else if node instanceof Prop
        {key, val} = node
        if val.accessor
          key = val.meth = JS "'#{key.name}'" if key instanceof Key
          code += "#{ reft.compile o, LEVEL_CALL }
            .__define#{ if val.params.0 then val.void = \S else \G }etter__
            (#{ key.compile o, LEVEL_LIST }, #{ val.compile o, LEVEL_LIST })"
          continue
      else key = val = node
      dyna  or  key.=maybeKey!
      logic and val = logic <<< first: val
      code += Assign(Chain reft, [Index key]; val)compile o, LEVEL_PAREN
    return code if top
    @void or node instanceof Splat or
      code += (if com then ' ' else ', ') + reft.compile o, LEVEL_PAREN
    if o.level < LEVEL_LIST then code else "(#code)"

#### Of
# Handles `of` operation that tests if the left operand is included within
# the right operand, arraywise.
class exports.Of extends Node
  (@item, @array) ->

  children: <[ item array ]>

  ::<<<< Negatable

  compileNode: (o) ->
    [sub, ref] = @item.cache o, false, level = LEVEL_LIST
    if  (arr = @array.expandSlice(o)unwrap!) instanceof Arr
    and (tests = arr.items)length > 1
      code = ''; level = LEVEL_OP + PREC\==
      [cmp, cnj] = if @negated then [' !== ' ' && '] else [' === ' ' || ']
      for test, i of tests
        code &&+= cnj
        if test instanceof Splat
          code += (new Of(Var ref; test.it) <<< {@negated})compile o, level
          code  = "(#sub, #code)" unless i or sub is ref
        else
          code += (if i or sub is ref then ref else "(#sub)") +
                  cmp + test.compile o, level
      level = LEVEL_OP + PREC\||
    else
      code = "#{ utility \indexOf }.call(#{ arr.compile o, level }, #ref
            ) #{ if @negated then \< else \>= } 0"
      if sub is ref
      then level = LEVEL_OP + PREC\<
      else code  = "#sub, #code"
    sub is ref or o.scope.free ref
    if o.level < level then code else "(#code)"

#### Existence
# Checks a value for existence--not `undefined` nor `null`.
class exports.Existence extends Node
  (@it, @negated) ~>

  children: [\it]

  ::<<<< Negatable

  compileNode: (o) ->
    node = @it.unwrap() <<< {@front}
    code = node.compile o, LEVEL_OP + PREC\==
    if node instanceof Var and not o.scope.check code, true
      [op, eq] = if @negated then <[ || = ]> else <[ && ! ]>
      code = "typeof #code #eq= 'undefined' #op #code #eq== null"
    else
      code += " #{ op = if @negated then \== else \!= } null"
    if o.level < LEVEL_OP + PREC[op] then code else "(#code)"

#### Fun
# A function definition. This is the only node that creates a `new Scope`.
class exports.Fun extends Node
  (@params or [], @body or Block(), @bound and \_this) ~>

  children: <[ params body ]>

  show: -> @bound

  named: -> import {name: it, +statement}

  isCallable: YES

  isStatement: -> !!@statement

  # Short-circuit `traverseChildren` method to prevent it
  # from crossing scope boundaries by default.
  traverseChildren: (, xscope) -> super ... if xscope

  makeReturn: -> if @statement then import {+returns} else super ...

  ripName: ->
    # `name = ->`
    @name ||= it.varName()
    @declared = it instanceof Var
    # `clas::meth = ->`
    if it.tails?length
      @clas ||= it.head instanceof Var and it.tails.0.key?name is \prototype
            and it.head.value
      @meth ||= not (tail = it.tails[*-1])isComplex() and tail
    void

  compileNode: (o) ->
    pscope = o.scope
    sscope = pscope.shared or pscope
    scope  = o.scope = @body.scope =
      new Scope (if @wrapper then pscope else sscope), @wrapper && sscope
    scope.fun = this
    scope.assign \prototype "#{ that.compile o }.prototype" if @proto
    scope.assign \constructor that                          if @cname
    o.indent = @tab = '' if loop = delete o.loop
    o.indent += TAB
    {body, name, tab} = this
    code = \function
    if @bound is \_this
      if @ctor
        scope.assign \_this 'new _ctor'
        code += " _ctor(){} _ctor.prototype = prototype;\n#{tab}function"
        body.add Return Literal \_this
      else if sscope.fun?bound
      then @bound = that
      else sscope.assign \_this \this
    if @statement
      name                    or @carp  'nameless function declaration'
      pscope is o.block.scope or @carp 'misplaced function declaration'
      @accessor              and @carp 'named accessor'
      scope .add name, \function
      pscope.add name, \function unless @returns
      code += ' ' + name
    @void or @ctor or @newed or body.makeReturn!
    code += "(#{ @compileParams scope }){"
    code += "\n#that\n#tab" if body.compileWithDeclarations o
    code += \}
    return pscope.assign pscope.temporary(\fn), code if loop
    code += "\n#{tab}return #name;" if @returns
    if @front and not @statement then "(#code)" else code

  compileParams: (scope) ->
    {params, body} = this; names = []; assigns = []
    for p, i of params
      if p instanceof Splat then splace = i
      # `(a = x) ->` => `(a ? x) ->`
      else if p.op is \= and not p.logic
        params[i] = Binary \? p.left, p.right
    # `(a, ...b, c) ->` => `(a) -> [[] ...b, c] = @@`
    if splace?
      rest = params.splice splace, 9e9
      rest = 0 if not rest.1 and rest.0.it.isEmpty()  # ignore trailing `...`
    else if @accessor
      that.carp 'excess accessor parameter' if params.1
    else unless params.length or @wrapper
      params.0 = Var \it if body.traverseChildren -> it.value is \it or null
    if params.length
      dic = {}
      for p of params
        vr = p
        vr.=first if df = vr.getDefault!
        if vr.isEmpty()
          vr = Var scope.temporary \arg
        else if vr not instanceof Var
          v = Var delete (vr.it || vr)name || vr.varName() ||
                  scope.temporary \arg
          assigns.push Assign vr, if df then Binary p.op, v, p.second else v
          vr = v
        else if df
          assigns.push Assign vr, p.second, \=, p.op
        names.push name = scope.add vr.value, \arg
        p.carp "duplicate parameter \"#name\"" unless dic[0 + name] ^= 1
    if rest
      rest.unshift Arr() while splace--
      assigns.push Assign Arr(rest), Literal \arguments
    @body.prepend ...assigns if assigns.length
    names.join ', '

#### Class
class exports.Class extends Node
  (@title, @sup, body) -> @fun = Fun [] body

  children: <[ title sup fun ]>

  isCallable: YES

  ripName: -> @name = it.varName(); void

  compile: (o, level) ->
    {fun, title} = this; {lines} = fun.body
    decl  = title?varName()
    name  = decl or @name
    if ID.test name || '' then fun.cname = name else name = \constructor
    fun.body.traverseChildren -> it.clas = name if it instanceof Fun; void
    for node, i of lines
      if node instanceof Obj
        lines[i] = Import (proto ||= Var \prototype), node
      else if node instanceof Fun and not node.statement
        ctor and node.carp 'redundant constructor'
        ctor = node
    ctor or lines.push ctor = Fun()
    ctor <<< {name, +ctor, +statement, -clas}
    lines.push vname = fun.proto = Var fun.bound = name
    if @sup
      args = [that]
      fun.proto = Util.Extends vname, fun.params.* = Var \superclass
    fun.cname and fun.body.prepend Literal "#name.displayName = '#name'"
    clas = Parens Call.make(fun, args), true
    clas = Assign vname, clas if decl and title.isComplex()
    clas = Assign title, clas if title
    clas.compile o, level

#### Super
# Reference to the parent method or constructor.
class exports.Super extends Node
  ::isAssignable = ::isCallable = YES

  compile: (o) ->
    {fun or @carp 'stray "super"'} = o.scope.shared or o.scope
    if fun.clas and /^(?:\.|\[[\'\"\d.])/test key = fun.meth?compile o
      return fun.clas + \.superclass.prototype + key
    if fun.name and (fun.ctor or fun.statement or fun.declared)
      return fun.name + \.superclass
    o.scope.check \superclass or @carp '"super" in a nameless function'
    \superclass

#### Parens
# An extra set of parentheses,
# specifying evaluation order and/or forcing expression.
class exports.Parens extends Node
  (@it, @keep, @string) ~>

  children: [\it]

  show: -> @string and '""'

  ::delegate <[ isComplex isCallable isArray isRegex ]> -> @it[it]()

  isString: -> @string or @it.isString()

  compile: (o, level ? o.level) ->
    {it} = this
    it <<< {@cond, @void}
    it.head.void = true if @calling and (not level or @void)
    unless @keep or @newed or level >= LEVEL_OP + PREC[it.op]
      return (it <<< {@front})compile o, level || LEVEL_PAREN
    if it.isStatement()
    then it.compileClosure o
    else "(#{ it.compile o, LEVEL_PAREN })"

#### Splat
# A splat, either as an argument to a call
# or as part of a destructuring assignment.
class exports.Splat extends Node
  (@it, @filler) ~>

  ::{children, isComplex} = Parens::

  isAssignable: YES

  assigns: -> @it.assigns it

  compile: -> @carp 'invalid splat'

  # Compiles a list of nodes mixed with splats to a proper array.
  @compileArray = (o, list, apply) ->
    index = -1
    while node = list[++index] then if node instanceof Splat
      return '' if apply and node.filler
      break unless node.it.isEmpty()
      list.splice index-- 1
    return '' if index >= list.length
    unless list.1
      return (if apply then Object else ensureArray) list.0.it
             .compile o, LEVEL_LIST
    args = []; atoms = []
    for node of list.splice index, 9e9
      if node instanceof Splat
        args.push Arr atoms.splice 0, 9e9 if atoms.length
        args.push ensureArray node.it
      else atoms.push node
    args.push Arr atoms if atoms.length
    (if index then Arr list else args.shift())compile(o, LEVEL_CALL) +
    ".concat(#{ List.compile o, args })"

  function ensureArray node
    return node if node.isArray()
    Call.make JS(utility(\slice) + \.call), [node]

#### Jump
# `break` `continue`
class exports.Jump extends Node
  (@verb, @label) ->

  show: -> (@verb or '') + if @label then ' ' + that else ''

  isStatement : YES
  makeReturn  : THIS

  getJump: (ctx or {}) ->
    return this unless ctx[@verb]
    return that not of (ctx.labels or []) and this if @label

  compileNode: (o) ->
    if @label
    then that of (o.labels or []) or @carp "undefined label \"#that\""
    else o[@verb] or @carp "stray #{@verb}"
    @show! + \;

#### Throw
class exports.Throw extends Jump
  (@it) ~>

  children: [\it]

  getJump: VOID

  compileNode: (o) -> "throw #{ @it?compile o, LEVEL_PAREN or \null };"

  Jump.throw = this

#### Return
class exports.Return extends Throw
  ~> import {it} if it and it.value is not \void

  getJump: THIS

  compileNode: (o) ->
    "return#{ if @it then ' ' + that.compile o, LEVEL_PAREN else '' };"

  Jump.return = this

#### While
# The traditional `while`/`for`/`do` loop.
# Returns an array of values collected from the last expression when requested.
class exports.While extends Node
  (test, @un, mode) ->
    mode and if mode instanceof Node then @update = mode else @post = true
    # `while true` `until false` => `for (;;)`
    import {test} if @post or test.value is not ''+!un

  children: <[ test body update else ]>

  aSource: \test, aTargets: <[ body update ]>

  show: -> [\! if @un; \do if @post] * ''

  ::isStatement = ::isArray = YES

  getJump: (ctx or {}) ->
    ctx <<< {+\continue, +\break}
    return node if node.getJump ctx for node of @body.lines

  addBody: (@body) ->
    [top] = body.lines
    body.lines.length = 0 if top?verb is \continue and not top.label
    this

  addElse: (@else) -> this

  makeReturn: ->
    if it
    then @body.makeReturn it
    else @getJump! or @returns = true
    this

  compileNode: (o) ->
    o.loop = true
    @test and if @un then @test.=invert() else @anaphorize()
    return 'do {' + @compileBody (o.indent += TAB; o), @test if @post
    test = @test?compile o, LEVEL_PAREN or ''
    head = if @update
    then "for (;#{ test and ' ' + test }; #{ that.compile o, LEVEL_PAREN }"
    else if test then "while (#test" else 'for (;;'
    head + ') {' + @compileBody (o.indent += TAB; o)

  compileBody: (o, potest) ->
    o <<< {+\break, +\continue}
    {lines} = @body; code = ret = ''
    if @returns
      if (last = lines[*-1]) and last not instanceof Throw
        lines[*-1] = last.makeReturn res = o.scope.assign \_results '[]'
      ret = "\n#{@tab}return #{ res or '[]' };"
    lines.unshift JS "#{ run = o.scope.temporary \run } = true;" if @else
    code += "\n#that\n#{@tab}" if @body.compile o, LEVEL_TOP
    code += \}
    code += " while (#{ potest.compile o<<<{@tab} LEVEL_PAREN });" if potest
    if run
      @else.makeReturn() if @returns
      code += " if (!#run) #{ @compileBlock o, @else }"
    code + ret

#### For
# Coco's replacements for the `for` loop are array, object or range iterators.
class exports.For extends While
  -> import all it

  children: <[ name source from to step body ]>

  aSource: null

  show: -> @index

  compileNode: (o) ->
    o.loop = true
    temps = @temps = []
    if idx = @index
    then o.scope.declare idx
    else temps.push idx = o.scope.temporary \i
    unless @object
      [pvar, step] = (@step or Literal 1)compileLoopReference o, \step
      pvar is step or temps.push pvar
    if @from
      [tvar, tail] = @to.compileLoopReference o, \to
      vars = "#idx = #{ @from.compile o, LEVEL_LIST }"
      unless tail is tvar
        vars += ", #tail"
        temps.push tvar
      eq   = if @op is \til then '' else \=
      cond = if +pvar
      then "#idx #{ if pvar < 0 then \> else \< }#eq #tvar"
      else "#pvar < 0 ? #idx >#eq #tvar : #idx <#eq #tvar"
    else
      if @name or @object and @own
        [svar, srcPart] = @source.compileLoopReference o, \ref, not @object
        svar is srcPart or temps.push svar
      else
        svar = srcPart = @source.compile o, LEVEL_PAREN
      unless @object
        if 0 > pvar and ~~pvar is +pvar  # negative int
          vars = "#idx = #srcPart.length - 1"
          cond = "#idx >= 0"
        else
          temps.push lvar = o.scope.temporary \len
          vars = "#idx = 0, #lvar = #srcPart.length"
          cond = "#idx < #lvar"
    head = 'for (' + if @object then "#idx in #srcPart" else
      step is pvar or vars += ', ' + step
      "#vars; #cond; " + if 1 == Math.abs pvar
      then (if pvar < 0 then \-- else \++) + idx
      else idx + if pvar < 0 then ' -= ' + pvar.slice 1 else ' += ' + pvar
    @own and head += ") if (#{ o.scope.assign \_own '{}.hasOwnProperty' }
                            .call(#svar, #idx)"
    head += ') {'
    @infuseIIFE o
    o.indent += TAB
    if @name
      head += \\n + o.indent
      item  = "#svar[#idx]"
      if @nref
        head += "#that = #item, "
        item  = that
      head += Assign(@name, Literal item)compile(o, LEVEL_TOP) + \;
    body  = @compileBody o
    head += \\n + @tab if @name and \} is body.charAt 0
    head + body

  # Makes IIFE constructions (such as `let`) capture the loop variables.
  infuseIIFE: (o) ->
    <~ @body.traverseChildren
    return unless it.calling or it.op is \new and (fun = it.it)params
    if fun
    then {tails: [call]} = it.it = Call.make fun <<< {+\void}
    else {tails: [call], head: fun} = it.it
    return if fun.params.length ^ call.args.length - !!call.method
    @index and fun.params.push call.args.* = Var @index
    if name = @name
      call.args.push if name.isComplex!
        then Var @nref ||= @temps.* = o.scope.temporary \ref else name
      fun.params.push name
    void

#### Try
# Classic `try`-`catch`-`finally` block with optional `catch`.
class exports.Try extends Node
  (@attempt, @thrown ? \_e, @recovery, @ensure) ->

  children: <[ attempt recovery ensure ]>

  show: -> @thrown

  isStatement: YES

  isCallable: -> @recovery?isCallable! and @attempt.isCallable!

  getJump: -> @attempt.getJump it or @recovery?getJump it

  makeReturn: ->
    @attempt .=makeReturn it
    @recovery?=makeReturn it
    this

  compileNode: (o) ->
    o.indent += TAB
    code = "try #{@compileBlock o, @attempt}"
    if @recovery or not @ensure
      o.scope.check(v = @thrown or \e) or o.scope.add v, \catch
      code += " catch (#v) #{ @compileBlock o, @recovery }"
    if @ensure
      code += " finally #{ @compileBlock o, @ensure }"
    code

#### Switch
# Compiles to the regular JS `switch`-`case`-`default`,
# but with forced `break` after each cases.
class exports.Switch extends Node
  (@topic, @cases, @default) ->

  children: <[ topic cases default ]>

  aSource: \topic, aTargets: [\cases]

  isStatement: YES

  isCallable: ->
    return false unless c.isCallable! for c of @cases
    @default?isCallable!

  getJump: (ctx or {}) ->
    ctx.break = true
    return that if c.body.getJump ctx for c of @cases
    @default?getJump ctx

  makeReturn: ->
    c.makeReturn it for c of @cases
    @default?makeReturn it
    this

  compileNode: (o) ->
    {tab} = this
    topic = !!@topic and @anaphorize()compile o, LEVEL_PAREN
    code  = "switch (#topic) {\n"
    stop  = @default or @cases.length - 1
    o.break = true
    code += c.compileCase o, tab, i is stop, !topic for c, i of @cases
    if @default
      o.indent = tab + TAB
      code += tab + "default:\n#that\n" if @default.compile o, LEVEL_TOP
    code + tab + \}

#### Case
class exports.Case extends Node
  (@tests, @body) ->

  children: <[ tests body ]>

  isCallable: -> @body.isCallable()

  makeReturn: ->
    @body.makeReturn it unless @body.lines[*-1]?value is \fallthrough
    this

  compileCase: (o, tab, nobr, bool) ->
    tests = for test of @tests
      test.=expandSlice(o)unwrap!
      if test instanceof Arr then t for t of test.items else test
    tests.length or tests.push Literal \void
    if bool
      [t] = tests; i = 0; t = Binary \|| t, that while tests[++i]
      tests = [(@<<<{t, aSource: \t, aTargets: [\body]})anaphorize()invert()]
    code = ''
    code += tab + "case #{ t.compile o, LEVEL_PAREN }:\n" for t of tests
    {lines} = @body; last = lines[*-1]
    lines[*-1] = JS '// fallthrough' if ft = last?value is \fallthrough
    o.indent = tab += TAB
    code += that + \\n        if @body.compile o, LEVEL_TOP
    code += tab  + 'break;\n' unless nobr or ft or last instanceof Jump
    code

#### If
# The `if`/`else` structure that acts as both statement and expression.
class exports.If extends Node
  (@if, @then, @un) ~>

  children: <[ if then else ]>

  aSource: \if, aTargets: [\then]

  show: -> @un and \!

  terminator: ''

  # Rewrites a chain of **If**s to add a default case as the final `else`.
  addElse: ->
    if @else instanceof .. then @else.addElse it
                           else @else    =    it
    this

  ::delegate <[ isCallable isArray isString isRegex ]> ->
    @else?[it]() and @then[it]()

  getJump: -> @then.getJump it or @else?getJump it

  makeReturn: ->
    @then.=makeReturn it
    @else?=makeReturn it
    this

  compileNode: (o) ->
    if @un then @if.=invert! else @soak or @anaphorize!
    if o.level then @compileExpression o else @compileStatement o

  compileStatement: (o) ->
    code = "if (#{ @if.compile o, LEVEL_PAREN }) "
    o.indent += TAB
    code += @compileBlock o, Block @then
    return code unless els = @else
    code + ' else ' + if els instanceof ..
      then els.compile o <<< indent: @tab, LEVEL_TOP
      else @compileBlock o, els

  compileExpression: (o) ->
    {then: thn, else: els} = this
    @void and thn.void = (els or 0)void = true
    return Parens(Binary \&& @if, thn)compile o if not els and (@cond or @void)
    code = @if.compile o, LEVEL_COND
    pad  = if els?isComplex! then \\n + o.indent += TAB else ' '
    code += "#pad? #{ thn.compile o, LEVEL_LIST              }
             #pad: #{ els?compile o, LEVEL_LIST  or 'void 8' }"
    if o.level < LEVEL_COND then code else "(#code)"

  # Unfolds a node's child if soak, then tuck the node under the created **If**.
  @unfoldSoak = (o, parent, name) ->
    if parent[name]unfoldSoak o
      parent[name] = that.then
      that <<< {parent.cond, parent.void, then: Chain parent}

#### Label
# A labeled block or statement.
class exports.Label extends Node
  (@label or \_, @it) ->

  ::{children, isCallable, isArray} = Parens::

  show: -> @label

  isStatement: YES

  getJump: (ctx or {}) ->
    ctx@@labels.push @label
    @it.getJump ctx <<< {+\break}

  makeReturn: -> @it.=makeReturn it; this

  compileNode: (o) ->
    {label, it} = this
    labels = o.labels = [...o.labels or []]
    @carp "duplicate label \"#label\"" if label of labels
    labels.push label
    it.isStatement! or it = Block it
    "#label: " + if it instanceof Block
      then o.indent += TAB; @compileBlock o, it
      else it.compile o

#### JS
# Embedded JavaScript snippets.
class exports.JS extends Node
  (@code, @literal, @comment) ~>

  show: -> if @comment then @code else "`#{@code}`"

  terminator : ''

  isCallable : -> not @comment
  isRegex    : -> not @comment and \/ is @code.charAt 0

  compile: -> if @literal then entab @code, it.indent else @code

#### Util
# A wrapper node for utility functions.
class exports.Util extends Node
  (@verb) ~>

  {::show} = Jump::

  isCallable: YES

  compile: -> utility @verb

  ##### Util.Extends
  # An operator that sets up class-ical inheritance between two constructors,
  # returning the left one.
  @Extends = -> Call.make Util(\extends), @@[0 1]

#### Parser Utils
# Helpers for modifying nodes in [parser](../lib/parser.js).

exports.L = (yylineno, node) -> node import line: yylineno + 1

##### Scope
# Regulates lexical scoping within Coco. As you
# generate code, you create a tree of scopes in the same shape as the nested
# functions. Each scope knows about the function parameters and the variables
# declared within it, and has references to its parent/shared enclosing scopes.
function Scope @parent, @shared
  @variables = []
  @positions = {}
  void
Scope::<<<
  # Adds a new variable or overrides an existing one.
  add: (name, type) ->
    if @variables[@positions[name]]
    then that <<< {type}
    else @positions[name] = ~-@variables.push {name, type}
    name

  # Declares a variable unless declared already.
  declare: (name) ->
    if @shared
      return if @check name
      scope = that
    else
      scope = this
    unless (type = scope.type name) and (type of <[ var arg ]> or type.value)
      scope.add name, \var

  # Ensures that an assignment is made at the top of this scope.
  assign: (name, value) -> @add name, {value}

  # If we need to store an intermediate result, find an available name for a
  # compiler-generated variable. `_var`, `_var2`, and so on...
  temporary: (name) ->
    i = 0
    do
      temp = \_ + if name.length > 1
      then name + (if i++ then i else '')
      else (i++ + parseInt name, 36)toString 36
    until @type(temp) of [\reuse void]
    @add temp, \var

  # Allows a variable to be reused.
  free: -> @add it, \reuse

  # Checks to see if a variable has already been declared.
  # Walks up the scope if `above` flag is specified.
  check: (name, above) ->
    return found if (found = @positions[name] in @variables) or not above
    @parent?check name, above

  # Gets the type of a variable from name.
  type: -> @variables[@positions[it]]?type

  # Concatenates the declarations in this scope.
  emit: (code, tab) ->
    usr = []; tmp = []; asn = []; fun = []
    for {name, type} of @variables
      if type of <[ var reuse ]>
        (if \_ is name.charAt 0 then tmp else usr)push name
      else if type.value
        if ~(val = entab that, tab)lastIndexOf \function( 0
        then fun.push "function #name#{ val.slice 8 }"
        else asn.push "#name = #val"
    code = "#{tab}var #that;\n#code" if usr.concat(tmp, asn)join ', '
    if fun.join "\n#tab" then "#code\n#tab#that" else code

##### Constants

function YES  then true
function NO   then false
function THIS then this
function VOID then void

UTILITIES =
  # Creates an object's prototypal child, ensuring `__proto__`.
  clone: '''function(it){
    function fn(){ if (this.__proto__ !== it) this.__proto__ = it }
    return fn.prototype = it, new fn;
  }'''
  # Sets up `.prototype` between a pair of constructors
  # as well as `.constructor` and `.superclass` references.
  extends: '''function(sub, sup){
    function ctor(){} ctor.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new ctor).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }'''

  # Wraps a function to fixate its `this` value.
  bind: '''
    function(me, fn){ return function(){ return fn.apply(me, arguments) } }
  '''

  # Copies properties from right to left.
  import: '''function(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }'''
  importAll: '''function(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }'''

  repeatString: '''function(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }'''
  repeatArray: '''function(arr, n){
    for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
      if (n & 1) r.push.apply(r, arr);
    return r;
  }'''

  # Shortcuts to speed up the lookup time for native methods.
  split    : "''.split"
  replace  : "''.replace"
  toString : '{}.toString'
  join     : '[].join'
  slice    : '[].slice'
  indexOf  : '''[].indexOf || function(x){
    var i = -1, l = this.length;
    while (++i < l) if (this.hasOwnProperty(i) && this[i] === x) return i;
    return -1;
  }'''

# Each level indicates a node's position in the AST.
LEVEL_TOP    = 0  # ...;
LEVEL_PAREN  = 1  # (...)
LEVEL_LIST   = 2  # [...]
LEVEL_COND   = 3  # ... ? x : y
LEVEL_OP     = 4  # !...
LEVEL_CALL   = 5  # ...()

# Operator precedances.
PREC = \? : 0.1, unary : 0.9
PREC\&& = PREC\||                                                  = 0.2
PREC\&  = PREC\^  = PREC\|                                         = 0.3
PREC\== = PREC\!= = PREC\=== = PREC\!==                            = 0.4
PREC\<  = PREC\>  = PREC\<=  = PREC\>= = PREC\in = PREC\instanceof = 0.5
PREC\<< = PREC\>> = PREC\>>>                                       = 0.6
PREC\+  = PREC\-                                                   = 0.7
PREC\*  = PREC\/  = PREC\%                                         = 0.8

TAB = ' ' * 2

ID = /^[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*$/

SIMPLENUM = /^\d+$/

##### Helpers

# Declares a utility function at the top level.
function utility then Scope.root.assign \__ + it, UTILITIES[it]

function entab code, tab then code.replace /\n/g \\n + tab
