<!DOCTYPE html>

<html>
<head>
  <title>ast.ls</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="ast.html">
                  ast.ls
                </a>
              
                
                <a class="source" href="browser.html">
                  browser.ls
                </a>
              
                
                <a class="source" href="command.html">
                  command.ls
                </a>
              
                
                <a class="source" href="grammar.html">
                  grammar.ls
                </a>
              
                
                <a class="source" href="index.html">
                  index.ls
                </a>
              
                
                <a class="source" href="lang-ls.html">
                  lang-ls.ls
                </a>
              
                
                <a class="source" href="lexer.html">
                  lexer.ls
                </a>
              
                
                <a class="source" href="mode-ls.html">
                  mode-ls.ls
                </a>
              
                
                <a class="source" href="node.html">
                  node.ls
                </a>
              
                
                <a class="source" href="options.html">
                  options.ls
                </a>
              
                
                <a class="source" href="util.html">
                  util.ls
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>ast.ls</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Contains all of the node classes for the AST (abstract syntax tree).
Most nodes are created as the result of actions in the <a href="#grammar">grammar</a>,
but some are created by other nodes as a method of code generation.
To convert the syntax tree into a string of JavaScript code,
call <code>Block::compile-root</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-built_in">require</span>! {
    <span class="hljs-string">'prelude-ls'</span>: {fold}
    <span class="hljs-string">'./util'</span>: {name-from-path, strip-string}
    <span class="hljs-string">'source-map'</span>: {SourceNode, SourceMapGenerator}
}<span class="hljs-function">

<span class="hljs-title">sn</span> = <span class="hljs-params">(node = {}, ...parts)</span> -&gt;</span>
    <span class="hljs-keyword">try</span>
        result = <span class="hljs-keyword">new</span> SourceNode node.line, node.column, <span class="hljs-literal">null</span>, parts
        result.display-name = node.constructor.display-name
        result
    <span class="hljs-keyword">catch</span> e
        <span class="hljs-built_in">console</span>.dir parts
        <span class="hljs-keyword">throw</span> e

sn-empty = <span class="hljs-function"><span class="hljs-params">(node)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> SourceNode
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children
            <span class="hljs-keyword">unless</span> sn-empty(child)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        <span class="hljs-literal">true</span>
    <span class="hljs-keyword">else</span>
        !node
sn-safe = <span class="hljs-function"><span class="hljs-params">(code)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> code <span class="hljs-keyword">instanceof</span> SourceNode <span class="hljs-keyword">then</span> code <span class="hljs-keyword">else</span> code.to-string!
sn-remove-left = <span class="hljs-function"><span class="hljs-params">(node, count)</span> -&gt;</span>
    <span class="hljs-keyword">for</span> i til node.children.length
        child = node.children[i]
        <span class="hljs-keyword">if</span> child <span class="hljs-keyword">instanceof</span> SourceNode
            count = sn-remove-left child, count
        <span class="hljs-keyword">else</span>
            child = child.to-string!
            node.children[i] = child.slice count
            count -= child.length
        <span class="hljs-keyword">if</span> count &lt;= <span class="hljs-number">0</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    count
sn-autofill = <span class="hljs-function"><span class="hljs-params">(node, parents = [])</span> -&gt;</span>
    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> SourceNode
        <span class="hljs-keyword">if</span> node.line
            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> parents
                p.line = node.line
                p.column = node.column
            parents.length = <span class="hljs-number">0</span>
        <span class="hljs-keyword">else</span>
            parents.push node
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children
            sn-autofill child, parents
    node

SourceNode::replace = <span class="hljs-function"><span class="hljs-params">(...args)</span> -&gt;</span>
    <span class="hljs-keyword">new</span> SourceNode @line, @column, @source, [..replace(...args) <span class="hljs-keyword">for</span> @children], @name
SourceNode::set-file = <span class="hljs-function"><span class="hljs-params">(filename)</span> -&gt;</span>
    @source = filename
    <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> @children <span class="hljs-keyword">when</span> child <span class="hljs-keyword">instanceof</span> SourceNode
        child.set-file filename</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Built-in version of this sucks, so replace it with our own</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>SourceNode::to-string-with-source-map = <span class="hljs-function"><span class="hljs-params">(...args)</span> -&gt;</span>
    gen = <span class="hljs-keyword">new</span> SourceMapGenerator ...args
    gen-line = <span class="hljs-number">1</span>
    gen-column = <span class="hljs-number">0</span>
    stack = []
    code = <span class="hljs-string">''</span>
    debug-output = <span class="hljs-string">''</span>
    debug-indent = <span class="hljs-string">''</span>
    debug-indent-str = <span class="hljs-string">'  '</span>

    gen-<span class="hljs-keyword">for</span>-node = <span class="hljs-function"><span class="hljs-params">(node)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> SourceNode
            debug-output += debug-indent + node.display-name</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Block nodes should essentially “clear out” any effects
from parent nodes, so always add them to the stack</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            valid = node.line and 'column' of node
            if valid
                stack.push node
                debug-output += '!'
            debug-output += " #{node.line}:#{node.column} #{gen-line}:#{gen-column}\n"

            debug-indent += debug-indent-str
            for child in node.children
                gen-for-node child
            debug-indent := debug-indent.slice 0, debug-indent.length - debug-indent-str.length

            if valid
                stack.pop!
        else
            debug-output += "#{debug-indent}#{ JSON.stringify node }\n"
            code += node
            cur = stack[*-1]
            if cur
                gen.add-mapping do
                    source: cur.source
                    original:
                        line: cur.line
                        column: cur.column
                    generated:
                        line: gen-line
                        column: gen-column
                    name: cur.name
            for i til node.length
                c = node.char-at i
                if c == "\n"
                    gen-column := 0
                    ++gen-line
                    if cur
                        gen.add-mapping do
                          source: cur.source
                          original:
                              line: cur.line
                              column: cur.column
                          generated:
                              line: gen-line
                              column: gen-column
                          name: cur.name
                else
                    ++gen-column

    gen-for-node(this)
    {code: code, map: gen, debug: debug-output}

/* # Use this to track down places where a SourceNode is being converted into a string and causing the location to be lost
tmp-to-string = SourceNode::to-string
SourceNode::to-string = (...args) -&gt;
    console.log("toString(): ", new Error().stack)
    tmp-to-string.apply this, args
*/</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="node">Node</h2>
<p>The abstract base class for all nodes in the syntax tree.
Each subclass implements the <code>compile-node</code> method, which performs the
code generation for that node. To compile a node to JavaScript,
call <code>compile</code> on it, which wraps <code>compile-node</code> in some generic extra smarts.
An options hash is passed and cloned throughout, containing information about
the environment from higher in the tree (such as if a returned value is
being requested by the surrounding function), information about the current
scope, and indentation level.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(Node = <span class="hljs-function">-&gt;</span> ...):: =
    compile: <span class="hljs-function"><span class="hljs-params">(options, level)</span> -&gt;</span>
        o = {} &lt;&lt;&lt; options
        o.level? = level
        node = @unfold-soak o <span class="hljs-keyword">or</span> <span class="hljs-keyword">this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>If a statement appears within an expression, wrap it in a closure.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> node.compile-closure o <span class="hljs-keyword">if</span> o.level <span class="hljs-keyword">and</span> node.<span class="hljs-keyword">is</span>-statement!
        code = (node &lt;&lt;&lt; tab: o.indent).compile-node o
        <span class="hljs-keyword">if</span> node.temps <span class="hljs-keyword">then</span> <span class="hljs-keyword">for</span> tmp <span class="hljs-keyword">in</span> that <span class="hljs-keyword">then</span> o.scope.free tmp
        code

    compile-closure: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>A statement that <em>jumps</em> out of current context (like <code>return</code>) can’t
be an expression via closure-wrapping, as its meaning will change.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        that.carp <span class="hljs-string">'inconvertible statement'</span> <span class="hljs-keyword">if</span> @get-jump!
        fun = Fun [] Block <span class="hljs-keyword">this</span>
        call = Call!
        fun.generator = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> o.<span class="hljs-keyword">in</span>-generator
        var hasArgs, hasThis
        @traverse-children !-&gt;
            <span class="hljs-keyword">switch</span> it.value
            | \<span class="hljs-keyword">this</span>      =&gt; hasThis := <span class="hljs-literal">true</span>
            | \arguments =&gt; hasArgs := it.value = \args$
        <span class="hljs-keyword">if</span> hasThis
            call.args.push Literal \<span class="hljs-keyword">this</span>
            call.method = \.call
        <span class="hljs-keyword">if</span> hasArgs
            call.args.push Literal \arguments
            fun.params.push Var \args$</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Flag the function as <code>wrapper</code> so that it shares a scope
with its parent to preserve the expected lexical scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        out = Parens(Chain fun&lt;&lt;&lt;{+wrapper, @void} [call]; <span class="hljs-literal">true</span>)
        <span class="hljs-keyword">if</span> o.<span class="hljs-keyword">in</span>-generator
            out = <span class="hljs-keyword">new</span> Yield <span class="hljs-string">'yieldfrom'</span>, out
        out.compile o</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Compiles a child node as a block statement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compile-block: <span class="hljs-function"><span class="hljs-params">(o, node)</span> -&gt;</span>
        <span class="hljs-keyword">unless</span> sn-empty(code = node?compile o, LEVEL_TOP)
            sn(<span class="hljs-literal">null</span>, <span class="hljs-string">"{\n"</span>, code, <span class="hljs-string">"\n<span class="hljs-subst">#{@tab}</span>}"</span>)
        <span class="hljs-keyword">else</span>
            sn(node, <span class="hljs-string">'{}'</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Spreads a transformation over a list and compiles it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compile-spread-over: <span class="hljs-function"><span class="hljs-params">(o, list, transform)</span> -&gt;</span>
        ob = list <span class="hljs-keyword">instanceof</span> Obj
        them = list.items
        <span class="hljs-keyword">for</span> node, i <span class="hljs-keyword">in</span> them
            node.=it <span class="hljs-keyword">if</span> sp = node <span class="hljs-keyword">instanceof</span> Splat
            node.=val <span class="hljs-keyword">if</span> ob <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> sp
            node = transform node
            node = lat = Splat node <span class="hljs-keyword">if</span> sp
            <span class="hljs-keyword">if</span> ob <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> sp <span class="hljs-keyword">then</span> them[i].val = node <span class="hljs-keyword">else</span> them[i] = node
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> lat <span class="hljs-keyword">and</span> (@void <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> o.level)
            list = Block(<span class="hljs-keyword">if</span> ob <span class="hljs-keyword">then</span> [..val <span class="hljs-keyword">for</span> them] <span class="hljs-keyword">else</span> them) &lt;&lt;&lt; {@front, +void}
        list.compile o, LEVEL_PAREN</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>If the code generation wishes to use the result of a complex expression
in multiple places, ensure that the expression is only ever evaluated once,
by assigning it to a temporary variable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    cache: <span class="hljs-function"><span class="hljs-params">(o, once, level)</span> -&gt;</span>
        <span class="hljs-keyword">unless</span> @is-complex!
            <span class="hljs-keyword">return</span> [<span class="hljs-keyword">if</span> level? <span class="hljs-keyword">then</span> @compile o, level <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span>] * <span class="hljs-number">2</span>
        sub = Assign ref = Var(o.scope.temporary!), <span class="hljs-keyword">this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Pass a <code>level</code> to precompile.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> level?
            sub.=compile o, level
            o.scope.free ref.value <span class="hljs-keyword">if</span> once
            <span class="hljs-keyword">return</span> [sub, ref.value]</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>If flagged as <code>once</code>, the tempvar will be auto-freed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> once <span class="hljs-keyword">then</span> [sub, ref &lt;&lt;&lt; {+temp}] <span class="hljs-keyword">else</span> [sub, ref, [ref.value]]</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Compiles to a variable/source pair suitable for looping.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compile-<span class="hljs-keyword">loop</span>-reference: <span class="hljs-function"><span class="hljs-params">(o, name, ret, safe-access)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Var   <span class="hljs-keyword">and</span> o.scope.check @value
        <span class="hljs-keyword">or</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Unary <span class="hljs-keyword">and</span> @op <span class="hljs-keyword">in</span> &lt;[ + - ]&gt; <span class="hljs-keyword">and</span> <span class="hljs-number">-1</span>/<span class="hljs-number">0</span> &lt; +@it.value &lt; <span class="hljs-number">1</span>/<span class="hljs-number">0</span>
        <span class="hljs-keyword">or</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Literal <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @is-complex!
            code = @compile o, LEVEL_PAREN
            code = <span class="hljs-string">"(#code)"</span> <span class="hljs-keyword">if</span> safe-access <span class="hljs-keyword">and</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Var
            <span class="hljs-keyword">return</span> [code] * <span class="hljs-number">2</span>
        asn = Assign Var(tmp = o.scope.temporary name), <span class="hljs-keyword">this</span>
        ret <span class="hljs-keyword">or</span> asn.void = <span class="hljs-literal">true</span>
        [tmp; asn.compile o, <span class="hljs-keyword">if</span> ret <span class="hljs-keyword">then</span> LEVEL_CALL <span class="hljs-keyword">else</span> LEVEL_PAREN]</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Passes each child to a function, returning its return value if exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    each-child: <span class="hljs-function"><span class="hljs-params">(fn)</span> -&gt;</span>
        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> @children <span class="hljs-keyword">when</span> child = @[name]
            <span class="hljs-keyword">if</span> \length <span class="hljs-keyword">of</span> child
                <span class="hljs-keyword">for</span> node, i <span class="hljs-keyword">in</span> child <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> that <span class="hljs-keyword">if</span> fn(node, name, i)
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> that <span class="hljs-keyword">if</span> fn(child, name)?</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Performs <code>each-child</code> on every descendant.
Overridden by <strong>Fun</strong> not to cross scope by default.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    traverse-children: <span class="hljs-function"><span class="hljs-params">(fn, xscope)</span> -&gt;</span>
        @each-child (node, name, index) ~&gt;
            fn(node, <span class="hljs-keyword">this</span>, name, index) ? node.traverse-children fn, xscope</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Performs anaphoric conversion if a <code>that</code> is found within <code>@aTargets</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    anaphorize: <span class="hljs-function">-&gt;</span>
        @children = @aTargets
        <span class="hljs-keyword">if</span> @each-child hasThat</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Set a flag and deal with it in the Existence node (it’s too
tricky here).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (base = <span class="hljs-keyword">this</span>)[name = @a-source] <span class="hljs-keyword">instanceof</span> Existence
                base[name].<span class="hljs-keyword">do</span>-anaphorize = <span class="hljs-literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>‘that = x’ here is fine.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> base[name]value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> \that
                base[name] = Assign Var(\that), base[name]
        function hasThat
            it.value <span class="hljs-keyword">is</span> \that <span class="hljs-keyword">or</span> <span class="hljs-keyword">if</span> it.a-source
            <span class="hljs-keyword">then</span> hasThat that <span class="hljs-keyword">if</span> it[that]
            <span class="hljs-keyword">else</span> it.each-child hasThat
        <span class="hljs-keyword">delete</span> @children
        @[@a-source] &lt;&lt;&lt; {+cond}</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Throws a syntax error, appending <code>@line</code> number to the message.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    carp: <span class="hljs-function"><span class="hljs-params">(msg, type = SyntaxError)</span> -&gt;</span>
        <span class="hljs-keyword">throw</span> type <span class="hljs-string">"#msg on line <span class="hljs-subst">#{ @line <span class="hljs-keyword">or</span> @traverse-children -&gt; it.line }</span>"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Defines delegators.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    delegate: !(names, fn) -&gt;
        <span class="hljs-keyword">for</span> let name <span class="hljs-keyword">in</span> names
            @[name] = <span class="hljs-function">-&gt;</span> fn.call <span class="hljs-keyword">this</span>, name, it</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Default implementations of the common node properties and methods. Nodes
will override these with custom logic, if needed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    children: []

    terminator: \;

    <span class="hljs-keyword">is</span>-complex: YES

    <span class="hljs-keyword">is</span>-statement  : NO
    <span class="hljs-keyword">is</span>-assignable : NO
    <span class="hljs-keyword">is</span>-callable   : NO
    <span class="hljs-keyword">is</span>-empty      : NO
    <span class="hljs-keyword">is</span>-array      : NO
    <span class="hljs-keyword">is</span>-string     : NO
    <span class="hljs-keyword">is</span>-regex      : NO

    <span class="hljs-keyword">is</span>-matcher: <span class="hljs-function">-&gt;</span> @is-string! <span class="hljs-keyword">or</span> @is-regex!</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Do I assign a certain variable?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    assigns: NO</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Picks up name(s) from LHS.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rip-name: VOID

    unfold-soak   : VOID
    unfold-assign : VOID
    unparen       : THIS
    unwrap        : THIS
    maybe-key     : THIS
    expand-slice  : THIS
    var-name      : String
    get-accessors : VOID
    get-call      : VOID
    get-default   : VOID</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Digs up a statement that jumps out of this node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    get-jump      : VOID

    invert: <span class="hljs-function">-&gt;</span> Unary \! <span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>

    invert-check: <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">if</span> it.inverted <span class="hljs-keyword">then</span> @invert! <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span>

    add-else: <span class="hljs-function"><span class="hljs-params">(@else)</span> -&gt;</span> <span class="hljs-keyword">this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Constructs a node that returns the current node’s result.
If obj is true, interprets this node as a key-value pair to be
stored on ref. Otherwise, pushes this node into ref.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    make-return: <span class="hljs-function"><span class="hljs-params">(ref, obj)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> obj <span class="hljs-keyword">then</span>
            items = <span class="hljs-keyword">if</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Arr
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> @items<span class="hljs-number">.0</span>? <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> @items<span class="hljs-number">.1</span>?
                    @carp <span class="hljs-string">'must specify both key and value for object comprehension'</span>
                @items
            <span class="hljs-keyword">else</span>
                kv = \keyValue$
                <span class="hljs-keyword">for</span> v, i <span class="hljs-keyword">in</span> [Assign(Var(kv), <span class="hljs-keyword">this</span>), Var(kv)]
                    Chain v .add Index Literal i
            Assign (Chain Var ref).add(Index items<span class="hljs-number">.0</span>, \., <span class="hljs-literal">true</span>), items<span class="hljs-number">.1</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ref
            Call.make JS(ref + \.push), [<span class="hljs-keyword">this</span>]
        <span class="hljs-keyword">else</span>
            Return <span class="hljs-keyword">this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Extra info for <code>toString</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    show: String</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>String representation of the node for inspecting the parse tree.
This is what <code>lsc --ast</code> prints out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    to-string: <span class="hljs-function"><span class="hljs-params">(idt <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>)</span> -&gt;</span>
        tree  = \\n + idt + @constructor.display-name
        tree += <span class="hljs-string">' '</span> + that <span class="hljs-keyword">if</span> @show!
        @each-child !-&gt; tree += it.toString idt + TAB
        tree</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>JSON serialization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    stringify: <span class="hljs-function"><span class="hljs-params">(space)</span> -&gt;</span> JSON.stringify <span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span> space
    to-JSON: <span class="hljs-function">-&gt;</span> {type: @constructor.display-name, ...<span class="hljs-keyword">this</span>}</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>JSON deserialization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.parse    = <span class="hljs-function"><span class="hljs-params">(json)</span> -&gt;</span> exports.from-JSON JSON.parse json
exports.from-JSON = function
    <span class="hljs-keyword">return</span> it <span class="hljs-keyword">unless</span> it <span class="hljs-keyword">and</span> <span class="hljs-keyword">typeof</span> it <span class="hljs-keyword">is</span> \object
    <span class="hljs-keyword">if</span> it.type
        node = ^^exports[that].prototype
        <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">of</span> it <span class="hljs-keyword">then</span> node[key] = from-JSON val
        <span class="hljs-keyword">return</span> node
    <span class="hljs-keyword">if</span> it.length? <span class="hljs-keyword">then</span> [from-JSON v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> it] <span class="hljs-keyword">else</span> it</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <h3 id="mixins">Mixins</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Negatable =
    show: <span class="hljs-function">-&gt;</span> @negated <span class="hljs-keyword">and</span> \!
    invert: <span class="hljs-function">-&gt;</span> !=@negated; <span class="hljs-keyword">this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <h3 id="block">Block</h3>
<p>A list of expressions that forms the body of an indented block of code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Block</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (body || []) ~&gt;
        <span class="hljs-keyword">if</span> \length <span class="hljs-keyword">of</span> body
            @lines = body
        <span class="hljs-keyword">else</span>
            @lines = []
            @add body

    children: [\lines]

    to-JSON: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">delete</span> @back; <span class="hljs-keyword">super</span>!

    add: <span class="hljs-function">-&gt;</span>
        it.=unparen!
        <span class="hljs-keyword">switch</span>
        | @back     =&gt; that.add it
        | it.lines  =&gt; @lines.push ...that
        | otherwise =&gt;
            @lines.push it
            @back = that <span class="hljs-keyword">if</span> <span class="hljs-keyword">delete</span> it.back
        <span class="hljs-keyword">this</span>

    prepend: <span class="hljs-function">-&gt;</span>
        @lines.splice @neck!, <span class="hljs-number">0</span>, ...arguments
        <span class="hljs-keyword">this</span>

    pipe: <span class="hljs-function"><span class="hljs-params">(target, type)</span> -&gt;</span>
        args = <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> \|&gt; <span class="hljs-keyword">then</span> @lines.pop! <span class="hljs-keyword">else</span> target
        args = [args] <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span>! args <span class="hljs-keyword">isnt</span> \Array
        <span class="hljs-keyword">switch</span> type
        | \|&gt;  =&gt; @lines.push Call.make(target,      args, pipe: <span class="hljs-literal">true</span>)
        | \&lt;|  =&gt; @lines.push Call.make(@lines.pop!, args)
        <span class="hljs-keyword">this</span>

    unwrap: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">if</span> @lines.length <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> @lines<span class="hljs-number">.0</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Removes trailing comment nodes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    chomp: <span class="hljs-function">-&gt;</span>
        {lines} = <span class="hljs-keyword">this</span>
        i = lines.length
        <span class="hljs-keyword">while</span> lines[--i] <span class="hljs-keyword">then</span> <span class="hljs-keyword">break</span> <span class="hljs-keyword">unless</span> that.comment
        lines.length = i + <span class="hljs-number">1</span>
        <span class="hljs-keyword">this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Finds the right position for inserting variable declarations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    neck: <span class="hljs-function">-&gt;</span>
        pos = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> @lines
            <span class="hljs-keyword">break</span> <span class="hljs-keyword">unless</span> x.comment <span class="hljs-keyword">or</span> x <span class="hljs-keyword">instanceof</span> Literal
            ++pos
        pos

    <span class="hljs-keyword">is</span>-complex: <span class="hljs-function">-&gt;</span> @lines.length &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> @lines<span class="hljs-number">.0</span>?<span class="hljs-keyword">is</span>-complex!

    ::delegate &lt;[ isCallable isArray isString isRegex ]&gt; -&gt; @lines[*<span class="hljs-number">-1</span>]?[it]!

    get-jump: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> @lines <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> that <span class="hljs-keyword">if</span> node.get-jump it</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p><strong>Block</strong> does not return its entire body, rather it
ensures that the final line is returned.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    make-return: <span class="hljs-function">-&gt;</span>
        @chomp!
        <span class="hljs-keyword">if</span> @lines[*<span class="hljs-number">-1</span>]?=make-<span class="hljs-keyword">return</span> ...&amp;
            --@lines.length <span class="hljs-keyword">if</span> that <span class="hljs-keyword">instanceof</span> Return <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> that.it
        <span class="hljs-keyword">this</span>

    compile: <span class="hljs-function"><span class="hljs-params">(o, level ? o.level)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> @compile-expressions o, level <span class="hljs-keyword">if</span> level
        o.block = <span class="hljs-keyword">this</span>
        tab = o.indent
        codes = []
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> @lines
            node = node.unfold-soak o <span class="hljs-keyword">or</span> node
            <span class="hljs-keyword">continue</span> <span class="hljs-keyword">if</span> sn-empty(code = (node &lt;&lt;&lt; {+front})compile o, level)
            codes.push tab
            codes.push code
            node.<span class="hljs-keyword">is</span>-statement! <span class="hljs-keyword">or</span> codes.push node.terminator
            codes.push \\n
        codes.pop!
        sn(<span class="hljs-literal">null</span>, ...codes)</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p><strong>Block</strong> is the only node that can serve as the root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compile-root: <span class="hljs-function"><span class="hljs-params">(options)</span> -&gt;</span>
        o = {
            level: LEVEL_TOP
            scope: @scope = Scope.root = <span class="hljs-keyword">new</span> Scope
            ...options
        }
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">delete</span> o.saveScope</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>use savedScope as your scope</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            @scope = Scope.root = o.scope = that.savedScope <span class="hljs-keyword">or</span>= o.scope
        <span class="hljs-keyword">delete</span> o.filename
        o.indent = <span class="hljs-keyword">if</span> bare = <span class="hljs-keyword">delete</span> o.bare <span class="hljs-keyword">then</span> <span class="hljs-string">''</span> <span class="hljs-keyword">else</span> TAB
        <span class="hljs-keyword">if</span> <span class="hljs-regexp">/^\s*(?:[/</span><span class="hljs-comment">#]|javascript:)/test @lines.0?.code</span>
            prefix = @lines.shift!code + \\n
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">delete</span> o.eval <span class="hljs-keyword">and</span> @chomp!lines.length
            <span class="hljs-keyword">if</span> bare <span class="hljs-keyword">then</span> @lines.push Parens @lines.pop! <span class="hljs-keyword">else</span> @make-<span class="hljs-keyword">return</span>!
        code = [(@compile-with-declarations o)]</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Wrap everything in a safety closure unless requested not to.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        bare <span class="hljs-keyword">or</span> code = [<span class="hljs-string">"(function(){\n"</span>, ...code, <span class="hljs-string">"\n}).call(this);\n"</span>]
        result = sn(<span class="hljs-literal">null</span>, prefix || [], ...code)</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Compile to a function body.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compile-with-declarations: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        o.level = LEVEL_TOP
        pre = []
        <span class="hljs-keyword">if</span> i = @neck!
            rest   = @lines.splice i, <span class="hljs-number">9e9</span>
            pre    = [(@compile o), <span class="hljs-string">"\n"</span>]
            @lines = rest
        <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, pre<span class="hljs-number">.0</span> || []) <span class="hljs-keyword">if</span> sn-empty(post = @compile o)
        sn(<span class="hljs-literal">null</span>, ...pre, <span class="hljs-keyword">if</span> @scope <span class="hljs-keyword">then</span> that.emit post, o.indent <span class="hljs-keyword">else</span> post)</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Compile to a comma-separated list of expressions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compile-expressions: <span class="hljs-function"><span class="hljs-params">(o, level)</span> -&gt;</span>
        {lines} = @chomp!
        i = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">while</span> lines[++i] <span class="hljs-keyword">then</span> lines.splice i-- <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> that.comment
        lines.push Literal \void <span class="hljs-keyword">unless</span> lines.length
        lines<span class="hljs-number">.0</span> &lt;&lt;&lt; {@front}
        lines[*<span class="hljs-number">-1</span>] &lt;&lt;&lt; {@void}
        <span class="hljs-keyword">return</span> lines<span class="hljs-number">.0</span>.compile o, level <span class="hljs-keyword">unless</span> lines<span class="hljs-number">.1</span>
        code = []
        last = lines.pop!
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> lines
            code.push (node &lt;&lt;&lt; {+void})compile(o, LEVEL_PAREN), <span class="hljs-string">', '</span>
        code.push (last.compile o, LEVEL_PAREN)
        <span class="hljs-keyword">if</span> level &lt; LEVEL_LIST <span class="hljs-keyword">then</span> sn(<span class="hljs-literal">null</span>, ...code) <span class="hljs-keyword">else</span> sn(<span class="hljs-literal">null</span>, <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <h3 id="atom">Atom</h3>
<p>An abstract node for simple values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Atom</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    show: <span class="hljs-function">-&gt;</span> @value
    <span class="hljs-keyword">is</span>-complex: NO</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <h3 id="literal">Literal</h3>
<p><code>this</code>, <code>debugger</code>, regexes and primitives.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Literal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Atom</span></span>
    (@value) ~&gt;
        <span class="hljs-keyword">return</span> JS <span class="hljs-string">"#value"</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> value.js
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Super        <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> \<span class="hljs-keyword">super</span>

    <span class="hljs-keyword">is</span>-empty    : <span class="hljs-function">-&gt;</span> @value <span class="hljs-keyword">in</span> &lt;[ void <span class="hljs-literal">null</span> ]&gt;
    <span class="hljs-keyword">is</span>-callable : <span class="hljs-function">-&gt;</span> @value <span class="hljs-keyword">in</span> &lt;[ <span class="hljs-keyword">this</span> eval .. ]&gt;
    <span class="hljs-keyword">is</span>-string   : <span class="hljs-function">-&gt;</span> <span class="hljs-number">0</span> &lt;= <span class="hljs-string">'\'"'</span>indexOf <span class="hljs-string">"<span class="hljs-subst">#{@value}</span>"</span>char-at!
    <span class="hljs-keyword">is</span>-regex    : <span class="hljs-function">-&gt;</span> <span class="hljs-string">"<span class="hljs-subst">#{@value}</span>"</span>char-at! <span class="hljs-keyword">is</span> \/
    <span class="hljs-keyword">is</span>-complex  : <span class="hljs-function">-&gt;</span> @is-regex! <span class="hljs-keyword">or</span> @value <span class="hljs-keyword">is</span> \<span class="hljs-keyword">debugger</span>
    <span class="hljs-keyword">is</span>-what     : <span class="hljs-function">-&gt;</span>
        | @is-empty!    =&gt; \empty
        | @is-callable! =&gt; \callable
        | @is-string!   =&gt; \string
        | @is-regex!    =&gt; \regex
        | @is-complex!  =&gt; \complex
        | otherwise     =&gt; void

    var-name: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">if</span> /^\w+$/test @value <span class="hljs-keyword">then</span> \$ + @value <span class="hljs-keyword">else</span> <span class="hljs-string">''</span>

    make-return: <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> it <span class="hljs-keyword">and</span> @value <span class="hljs-keyword">is</span> <span class="hljs-string">'debugger'</span>
            <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">super</span> ...

    maybe-key: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">if</span> ID.test @value <span class="hljs-keyword">then</span> Key @value <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span>

    compile: <span class="hljs-function"><span class="hljs-params">(o, level ? o.level)</span> -&gt;</span>
        <span class="hljs-keyword">switch</span> val = <span class="hljs-string">"<span class="hljs-subst">#{@value}</span>"</span>
        | \<span class="hljs-keyword">this</span>      =&gt; <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, o.scope.fun?bound <span class="hljs-keyword">or</span> val)
        | \void      =&gt;
            <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">''</span>) <span class="hljs-keyword">unless</span> level
            val += <span class="hljs-string">' 8'</span>
            fallthrough
        | \<span class="hljs-literal">null</span>      =&gt; @carp <span class="hljs-string">'invalid use of '</span> + @value <span class="hljs-keyword">if</span> level <span class="hljs-keyword">is</span> LEVEL_CALL
        | \<span class="hljs-literal">on</span> \<span class="hljs-literal">yes</span>   =&gt; val = <span class="hljs-string">'true'</span>
        | \<span class="hljs-literal">off</span> \<span class="hljs-literal">no</span>   =&gt; val = <span class="hljs-string">'false'</span>
        | \*         =&gt; @carp <span class="hljs-string">'stray star'</span>
        | \..        =&gt;
            @carp <span class="hljs-string">'stray reference'</span> <span class="hljs-keyword">unless</span> val = o.ref
            @cascadee <span class="hljs-keyword">or</span> val.erred = <span class="hljs-literal">true</span>
        | \<span class="hljs-keyword">debugger</span>  =&gt;
            <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"(function(){ debugger; }())"</span>) <span class="hljs-keyword">if</span> level
        sn(<span class="hljs-keyword">this</span>, sn-safe(val))</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <h3 id="var">Var</h3>
<p>Variables.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Var</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Atom</span></span>
    (@value) ~&gt;

    ::<span class="hljs-keyword">is</span>-assignable = ::<span class="hljs-keyword">is</span>-callable = YES

    assigns: <span class="hljs-function">-&gt;</span> it <span class="hljs-keyword">is</span> @value

    maybe-key: <span class="hljs-function">-&gt;</span> Key(@value) &lt;&lt;&lt; {@line}

    var-name: ::show

    compile: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">if</span> @temp <span class="hljs-keyword">then</span> o.scope.free @value <span class="hljs-keyword">else</span> @value)</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <h3 id="key">Key</h3>
<p>A property name in the form of <code>{key: _}</code> or <code>_.key</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Key</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (name, @reserved <span class="hljs-keyword">or</span> name.reserved) ~&gt; @name = <span class="hljs-string">''</span> + name

    <span class="hljs-keyword">is</span>-complex: NO

    assigns: <span class="hljs-function">-&gt;</span> it <span class="hljs-keyword">is</span> @name

    var-name: <span class="hljs-function">-&gt;</span>
        {name} = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">if</span> @reserved <span class="hljs-keyword">or</span> name <span class="hljs-keyword">in</span> &lt;[ arguments eval ]&gt; <span class="hljs-keyword">then</span> <span class="hljs-string">"$#name"</span> <span class="hljs-keyword">else</span> name

    show: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">if</span> @reserved <span class="hljs-keyword">then</span> <span class="hljs-string">"'<span class="hljs-subst">#{@name}</span>'"</span> <span class="hljs-keyword">else</span> @name
    compile: <span class="hljs-function">-&gt;</span> sn(<span class="hljs-keyword">this</span>, @show())</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <h3 id="index">Index</h3>
<p>Dots and brackets to access an object’s property.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (key, symbol <span class="hljs-keyword">or</span> \., init) ~&gt;
        <span class="hljs-keyword">if</span> init <span class="hljs-keyword">and</span> key <span class="hljs-keyword">instanceof</span> Arr
            <span class="hljs-keyword">switch</span> key.items.length
            | <span class="hljs-number">1</span> =&gt; key = Parens k <span class="hljs-keyword">unless</span> (k = key.items<span class="hljs-number">.0</span>) <span class="hljs-keyword">instanceof</span> Splat
        <span class="hljs-keyword">switch</span> symbol
        | <span class="hljs-string">'[]'</span> =&gt; @vivify = Arr
        | <span class="hljs-string">'{}'</span> =&gt; @vivify = Obj
        | _    =&gt;
            @assign = symbol.slice <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> \= <span class="hljs-keyword">is</span> symbol.slice <span class="hljs-number">-1</span>
        <span class="hljs-keyword">this</span> &lt;&lt;&lt; {key, symbol}

    children: [\key]

    show: <span class="hljs-function">-&gt;</span> [\? <span class="hljs-keyword">if</span> @soak] + @symbol

    <span class="hljs-keyword">is</span>-complex: <span class="hljs-function">-&gt;</span> @key.<span class="hljs-keyword">is</span>-complex!

    var-name: <span class="hljs-function">-&gt;</span> @key <span class="hljs-keyword">instanceof</span> [Key, Literal] <span class="hljs-keyword">and</span> @key.var-name!

    compile: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        code = @key.compile o, LEVEL_PAREN
        <span class="hljs-keyword">if</span> @key <span class="hljs-keyword">instanceof</span> Key <span class="hljs-keyword">and</span> \<span class="hljs-string">' is not code.to-string!.char-at 0
        then sn(this, ".", code) else sn(this, "[",code,"]")

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <h3 id="slice">Slice</h3>
<p>slices away at the target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Slice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    ({@type, @target, @from, @to}) ~&gt;
        @from ?= Literal <span class="hljs-number">0</span>
        @to = Binary \+ @to, Literal \<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> @to <span class="hljs-keyword">and</span> @type <span class="hljs-keyword">is</span> \to

    children: [\target \from \to]

    show: <span class="hljs-function">-&gt;</span> @type

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        @to = Binary \|| @to, Literal \<span class="hljs-number">9e9</span> <span class="hljs-keyword">if</span> @to <span class="hljs-keyword">and</span> @type <span class="hljs-keyword">is</span> \to
        args = [@target, @from]
        args.push @to <span class="hljs-keyword">if</span> @to
        Chain Var (util \slice) .add Index (Key \call), \. <span class="hljs-literal">true</span> .add Call args .compile o</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <h3 id="chain">Chain</h3>
<p>Acts as a container for property-access/function-call chains, by holding
<strong>Index</strong> or <strong>Call</strong> instances as <code>@tails</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Chain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (head, tails) ~&gt;
        <span class="hljs-keyword">return</span> head <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tails <span class="hljs-keyword">and</span> head <span class="hljs-keyword">instanceof</span> Chain
        <span class="hljs-keyword">this</span> &lt;&lt;&lt; {head, tails <span class="hljs-keyword">or</span> []}

    children: &lt;[ head tails ]&gt;

    add: <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">if</span> @tails.length
            last = @tails[*<span class="hljs-number">-1</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>optimize <code>x |&gt; f 1, _</code> to <code>f(1, x)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> last <span class="hljs-keyword">instanceof</span> Call
            <span class="hljs-keyword">and</span> last.partialized?length <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>
            <span class="hljs-keyword">and</span> it.args.length <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>
                index = last.partialized<span class="hljs-number">.0</span>.head.value <span class="hljs-comment"># Chain Literal i</span>
                <span class="hljs-keyword">delete</span> last.partialized</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>extract the single arg from pipe call</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                last.args[index] = it.args<span class="hljs-number">.0</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">if</span> @head <span class="hljs-keyword">instanceof</span> Existence
            {@head, @tails} = Chain @head.it
            it.soak = <span class="hljs-literal">true</span>
        @tails.push it
        bi = <span class="hljs-keyword">if</span> @head <span class="hljs-keyword">instanceof</span> Parens <span class="hljs-keyword">and</span> @head.it <span class="hljs-keyword">instanceof</span> Binary
         <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @head.it.partial <span class="hljs-keyword">then</span> @head.it
         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> @head <span class="hljs-keyword">instanceof</span> Binary <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @head.partial <span class="hljs-keyword">then</span> @head
        <span class="hljs-keyword">if</span> @head <span class="hljs-keyword">instanceof</span> Super
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> @head.called <span class="hljs-keyword">and</span> it <span class="hljs-keyword">instanceof</span> Call <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> it.method
                it.method = \.call
                it.args.unshift Literal \<span class="hljs-keyword">this</span>
                @head.called = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> @tails<span class="hljs-number">.1</span> <span class="hljs-keyword">and</span> it.key?name <span class="hljs-keyword">is</span> \prototype
                @head.sproto = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Call <span class="hljs-keyword">and</span> @tails.length <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">and</span> bi <span class="hljs-keyword">and</span> bi.op <span class="hljs-keyword">in</span> logics = &lt;[ &amp;&amp; || xor ]&gt;
            call = it<span class="hljs-function">
            <span class="hljs-title">f</span> = <span class="hljs-params">(x, key)</span> -&gt;</span>
                y = x[key]
                <span class="hljs-keyword">if</span> y <span class="hljs-keyword">instanceof</span> Binary <span class="hljs-keyword">and</span> y.op <span class="hljs-keyword">in</span> logics
                <span class="hljs-keyword">then</span> f y, \first; f y, \second
                <span class="hljs-keyword">else</span> x[key] = Chain y .auto-compare call.args
            f bi, \first
            f bi, \second
            <span class="hljs-keyword">return</span> bi
        <span class="hljs-keyword">this</span>

    auto-compare: <span class="hljs-function"><span class="hljs-params">(target)</span> -&gt;</span>
        test = @head
        <span class="hljs-keyword">switch</span>
        | test <span class="hljs-keyword">instanceof</span> Literal
            Binary \===  test, target<span class="hljs-number">.0</span>
        | test <span class="hljs-keyword">instanceof</span> Unary <span class="hljs-keyword">and</span> test.it <span class="hljs-keyword">instanceof</span> Literal
            Binary \===  test, target<span class="hljs-number">.0</span>
        | test <span class="hljs-keyword">instanceof</span> Arr, test <span class="hljs-keyword">instanceof</span> Obj
            Binary \==== test, target<span class="hljs-number">.0</span>
        | test <span class="hljs-keyword">instanceof</span> Var <span class="hljs-keyword">and</span> test.value <span class="hljs-keyword">is</span> \_
            Literal \<span class="hljs-literal">true</span>
        | otherwise
            <span class="hljs-keyword">this</span> .add Call target <span class="hljs-keyword">or</span> []

    flip-it: <span class="hljs-function">-&gt;</span> @flip = <span class="hljs-literal">true</span>; <span class="hljs-keyword">this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p><strong>Chain</strong> can be unwrapped as its inner node, if there are no subnodes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    unwrap: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">if</span> @tails.length <span class="hljs-keyword">then</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> @head

    ::delegate &lt;[ getJump assigns isStatement isString ]&gt;
           , <span class="hljs-function"><span class="hljs-params">(it, arg)</span> -&gt;</span> <span class="hljs-keyword">not</span> @tails.length <span class="hljs-keyword">and</span> @head[it] arg

    <span class="hljs-keyword">is</span>-complex  : <span class="hljs-function">-&gt;</span> @tails.length <span class="hljs-keyword">or</span> @head.<span class="hljs-keyword">is</span>-complex!
    <span class="hljs-keyword">is</span>-callable : <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">if</span> @tails[*<span class="hljs-number">-1</span>] <span class="hljs-keyword">then</span> <span class="hljs-keyword">not</span> that.key?items <span class="hljs-keyword">else</span> @head.<span class="hljs-keyword">is</span>-callable!
    <span class="hljs-keyword">is</span>-array    : <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">if</span> @tails[*<span class="hljs-number">-1</span>] <span class="hljs-keyword">then</span> that.key <span class="hljs-keyword">instanceof</span> Arr <span class="hljs-keyword">else</span> @head.<span class="hljs-keyword">is</span>-array!
    <span class="hljs-keyword">is</span>-regex    : <span class="hljs-function">-&gt;</span>
        @head.value <span class="hljs-keyword">is</span> \RegExp <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @tails<span class="hljs-number">.1</span> <span class="hljs-keyword">and</span> @tails<span class="hljs-number">.0</span> <span class="hljs-keyword">instanceof</span> Call

    <span class="hljs-keyword">is</span>-assignable: <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">return</span> @head.<span class="hljs-keyword">is</span>-assignable! <span class="hljs-keyword">unless</span> tail = @tails[*<span class="hljs-number">-1</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">if</span> tail <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Index
                     <span class="hljs-keyword">or</span> tail.key <span class="hljs-keyword">instanceof</span> List
                     <span class="hljs-keyword">or</span> tail.symbol <span class="hljs-keyword">is</span> \.~
        <span class="hljs-keyword">for</span> tail <span class="hljs-keyword">in</span> @tails <span class="hljs-keyword">when</span> tail.assign <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        <span class="hljs-literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p><code>@$</code> <code>o.0</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">is</span>-simple-access: <span class="hljs-function">-&gt;</span>
        @tails.length <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @head.<span class="hljs-keyword">is</span>-complex! <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @tails<span class="hljs-number">.0</span>.<span class="hljs-keyword">is</span>-complex!

    make-return: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">if</span> @tails.length <span class="hljs-keyword">then</span> <span class="hljs-keyword">super</span> ... <span class="hljs-keyword">else</span> @head.make-<span class="hljs-keyword">return</span> ...&amp;

    get-call: <span class="hljs-function">-&gt;</span> (tail = @tails[*<span class="hljs-number">-1</span>]) <span class="hljs-keyword">instanceof</span> Call <span class="hljs-keyword">and</span> tail

    var-name: <span class="hljs-function">-&gt;</span> @tails[*<span class="hljs-number">-1</span>]?var-name!</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>A reference has base part (<code>this</code> value) and name part.
We cache them separately for compiling complex expressions, so that e.g.</p>
<pre><code>a()[b()] ||= c
</code></pre><p>compiles to</p>
<pre><code>(ref$ = a())[key$ = b()] || (ref$[key$] = c);
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    cache-reference: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        name = @tails[*<span class="hljs-number">-1</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p><code>a.b()</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> @unwrap!cache o, <span class="hljs-literal">true</span> <span class="hljs-keyword">unless</span> @is-assignable!</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p><code>a</code> <code>a.b</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> @tails.length &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @head.<span class="hljs-keyword">is</span>-complex! <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> name?<span class="hljs-keyword">is</span>-complex!
            <span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>] * <span class="hljs-number">2</span>
        base = Chain @head, @tails.slice <span class="hljs-number">0</span> <span class="hljs-number">-1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p><code>a().b</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> base.<span class="hljs-keyword">is</span>-complex!
            ref  = o.scope.temporary!
            base = Chain Assign Var(ref), base
            bref = Var(ref) &lt;&lt;&lt; {+temp}</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p><code>a{}</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> [base, bref] <span class="hljs-keyword">unless</span> name</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p><code>a[b()]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> name.<span class="hljs-keyword">is</span>-complex!
            ref  = o.scope.temporary \key
            name = Index Assign Var(ref), name.key
            nref = Index Var(ref) &lt;&lt;&lt; {+temp}
        [base.add name; Chain bref || base.head, [nref <span class="hljs-keyword">or</span> name]]

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> @flip
            util \flip
            util \curry
        {head, tails} = <span class="hljs-keyword">this</span>
        head &lt;&lt;&lt; {@front, @newed}
        <span class="hljs-keyword">return</span> head.compile o <span class="hljs-keyword">unless</span> tails.length
        <span class="hljs-keyword">return</span> that.compile o <span class="hljs-keyword">if</span> @unfold-assign o
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tails <span class="hljs-keyword">when</span> t.partialized <span class="hljs-keyword">then</span> has-partial = <span class="hljs-literal">true</span>; <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">if</span> has-partial
            util \slice
            pre  = []
            rest = []
            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tails
                broken = broken <span class="hljs-keyword">or</span> t.partialized?
                <span class="hljs-keyword">if</span>   broken
                <span class="hljs-keyword">then</span> rest.push t
                <span class="hljs-keyword">else</span> pre .push t
            [partial, ...post] = rest <span class="hljs-keyword">if</span> rest?
            @tails = pre
            context = <span class="hljs-keyword">if</span> pre.length <span class="hljs-keyword">then</span> Chain head, pre[til <span class="hljs-number">-1</span>] <span class="hljs-keyword">else</span> Literal \<span class="hljs-keyword">this</span>
            <span class="hljs-keyword">return</span> (Chain (Chain Var util \partialize
                .add Index Key \apply
                .add Call [context, Arr [<span class="hljs-keyword">this</span>; Arr partial.args; Arr partial.partialized]]), post).compile o
        @carp <span class="hljs-string">'invalid callee'</span> <span class="hljs-keyword">if</span> tails<span class="hljs-number">.0</span> <span class="hljs-keyword">instanceof</span> Call <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> head.<span class="hljs-keyword">is</span>-callable!
        @expand-slice o
        @expand-vivify!
        @expand-bind o
        @expand-splat o
        @expand-star o
        <span class="hljs-keyword">if</span> @splatted-<span class="hljs-keyword">new</span>-args
            idt = o.indent + TAB
            func = Chain @head, tails.slice <span class="hljs-number">0</span> <span class="hljs-number">-1</span>
            <span class="hljs-keyword">return</span> sn(<span class="hljs-literal">null</span>, <span class="hljs-string">"""
                (function(func, args, ctor) {
                <span class="hljs-subst">#{idt}</span>ctor.prototype = func.prototype;
                <span class="hljs-subst">#{idt}</span>var child = new ctor, result = func.apply(child, args), t;
                <span class="hljs-subst">#{idt}</span>return (t = typeof result)  == "object" || t == "function" ? result || child : child;
                <span class="hljs-subst">#{TAB}</span>})("""</span>, (func.compile o), <span class="hljs-string">", "</span>, @splatted-<span class="hljs-keyword">new</span>-args, <span class="hljs-string">""", function(){})
            """</span>)
        <span class="hljs-keyword">return</span> @head.compile o <span class="hljs-keyword">unless</span> @tails.length
        base = [(@head.compile o, LEVEL_CALL)]
        news = []
        rest = []
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> @tails
            news.push <span class="hljs-string">'new '</span> <span class="hljs-keyword">if</span> t.<span class="hljs-keyword">new</span>
            rest.push t.compile o
        base.push <span class="hljs-string">' '</span> <span class="hljs-keyword">if</span> \. <span class="hljs-keyword">is</span> rest.join(<span class="hljs-string">""</span>).char-at <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> SIMPLENUM.test base<span class="hljs-number">.0</span>.to-string!
        sn(<span class="hljs-literal">null</span>, ...news, ...base, ...rest)</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Unfolds a soak into an <strong>If</strong>: <code>a?.b</code> =&gt; <code>a.b if a?</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    unfold-soak: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> @head.unfold-soak o
            that.<span class="hljs-keyword">then</span>.tails.push ...@tails
            <span class="hljs-keyword">return</span> that
        <span class="hljs-keyword">for</span> node, i <span class="hljs-keyword">in</span> @tails <span class="hljs-keyword">when</span> <span class="hljs-keyword">delete</span> node.soak
            bust = Chain @head, @tails.splice <span class="hljs-number">0</span> i
            node.carp <span class="hljs-string">'invalid accessign'</span> <span class="hljs-keyword">if</span> node.assign <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> bust.<span class="hljs-keyword">is</span>-assignable!
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">and</span> (node.assign <span class="hljs-keyword">or</span> node <span class="hljs-keyword">instanceof</span> Call)
                [test, bust] = bust.cache-reference o
                <span class="hljs-keyword">if</span> bust <span class="hljs-keyword">instanceof</span> Chain
                    @tails.unshift ...bust.tails
                    bust.=head
                @head = bust
            <span class="hljs-keyword">else</span>
                [test, @head] = bust.unwrap!cache o
            test = <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Call
                JS <span class="hljs-string">"typeof <span class="hljs-subst">#{ test.compile o, LEVEL_OP }</span> == 'function'"</span>
            <span class="hljs-keyword">else</span>
                Existence test
            <span class="hljs-keyword">return</span> If(test, <span class="hljs-keyword">this</span>) &lt;&lt;&lt; {+soak, @cond, @void}

    unfold-assign: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> @head.unfold-assign o
            that.right.tails.push ...@tails
            <span class="hljs-keyword">return</span> that
        <span class="hljs-keyword">for</span> index, i <span class="hljs-keyword">in</span> @tails <span class="hljs-keyword">then</span> <span class="hljs-keyword">if</span> op = index.assign
            index.assign = <span class="hljs-string">''</span>
            left = Chain @head, @tails.splice <span class="hljs-number">0</span> i .expand-slice o .unwrap!
            <span class="hljs-keyword">if</span> left <span class="hljs-keyword">instanceof</span> Arr</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p><code>[a, b].=reverse()</code> =&gt; <code>[a, b] = [a, b].reverse()</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                lefts = left.items
                {items: rites} = @head = Arr!
                <span class="hljs-keyword">for</span> node, i <span class="hljs-keyword">in</span> lefts
                    [rites[i], lefts[i]] = Chain node .cache-reference o
            <span class="hljs-keyword">else</span>
                [left, @head] = Chain left .cache-reference o
            op = \:= <span class="hljs-keyword">if</span> op <span class="hljs-keyword">is</span> \=
            <span class="hljs-keyword">return</span> Assign(left, <span class="hljs-keyword">this</span>, op) &lt;&lt;&lt; {+access}

    expand-splat: !(o) -&gt;
        {tails} = <span class="hljs-keyword">this</span>
        i = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">while</span> call = tails[++i]
            <span class="hljs-keyword">continue</span> <span class="hljs-keyword">unless</span> args = call.args
            ctx = call.method <span class="hljs-keyword">is</span> \.call <span class="hljs-keyword">and</span> (args.=concat!)shift!
            <span class="hljs-keyword">continue</span> <span class="hljs-keyword">unless</span> !sn-empty(args = Splat.compile-array o, args, <span class="hljs-literal">true</span>)
            <span class="hljs-keyword">if</span> call.<span class="hljs-keyword">new</span>
                @splatted-<span class="hljs-keyword">new</span>-args = args
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ctx <span class="hljs-keyword">and</span> tails[i<span class="hljs-number">-1</span>] <span class="hljs-keyword">instanceof</span> Index
                    [@head, ctx] = Chain(@head, tails.splice <span class="hljs-number">0</span> i<span class="hljs-number">-1</span>)cache o, <span class="hljs-literal">true</span>
                    i = <span class="hljs-number">0</span>
                call &lt;&lt;&lt; method: \.apply, args: [ctx <span class="hljs-keyword">or</span> Literal \<span class="hljs-literal">null</span>; JS args]

    expand-vivify: !-&gt;
        {tails} = <span class="hljs-keyword">this</span>
        i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i &lt; tails.length <span class="hljs-keyword">when</span> <span class="hljs-keyword">delete</span> tails[i++]vivify
            @head = Assign Chain(@head, tails.splice <span class="hljs-number">0</span>, i), that!, \= \||
            i = <span class="hljs-number">0</span>

    expand-bind: !(o) -&gt;
        {tails} = <span class="hljs-keyword">this</span>
        i = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">while</span> tails[++i]
            <span class="hljs-keyword">continue</span> <span class="hljs-keyword">unless</span> that.symbol <span class="hljs-keyword">is</span> \.~
            that.symbol = <span class="hljs-string">''</span>
            obj   = Chain(@head, tails.splice <span class="hljs-number">0</span> i)unwrap!
            {key} = tails.shift!
            call  = Call.make Util(\bind), [obj, key &lt;&lt;&lt; {+reserved}]
            @head = <span class="hljs-keyword">if</span> @newed <span class="hljs-keyword">then</span> Parens call, <span class="hljs-literal">true</span> <span class="hljs-keyword">else</span> call
            i = <span class="hljs-number">-1</span>

    expand-star: !(o) -&gt;
        {tails} = <span class="hljs-keyword">this</span>
        i = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">while</span> tails[++i]
            <span class="hljs-keyword">continue</span> <span class="hljs-keyword">if</span> that.args <span class="hljs-keyword">or</span> that.stars <span class="hljs-keyword">or</span> that.key <span class="hljs-keyword">instanceof</span> Key
            stars = that.stars = []
            that.each-child seek
            <span class="hljs-keyword">continue</span> <span class="hljs-keyword">unless</span> stars.length
            [sub, ref, temps] = Chain(@head, tails.splice <span class="hljs-number">0</span> i)unwrap!cache o
            value = Chain(ref, [Index Key \length])compile o
            <span class="hljs-keyword">for</span> star <span class="hljs-keyword">in</span> stars <span class="hljs-keyword">then</span> star &lt;&lt;&lt; {value, <span class="hljs-keyword">is</span>-assignable: YES}
            @head = JS sub.compile(o, LEVEL_CALL) + tails.shift!compile o
            o.scope.free temps<span class="hljs-number">.0</span> <span class="hljs-keyword">if</span> temps
            i = <span class="hljs-number">-1</span>
        !function seek
            <span class="hljs-keyword">if</span> it.value <span class="hljs-keyword">is</span> \*               <span class="hljs-keyword">then</span> stars.push it
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">unless</span> it <span class="hljs-keyword">instanceof</span> Index <span class="hljs-keyword">then</span> it.each-child seek</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p><code>a[x, y] = b{z} = c</code> =&gt; <code>[a[x], a[y]] = {z: b.z} = c</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    expand-slice: <span class="hljs-function"><span class="hljs-params">(o, assign)</span> -&gt;</span>
        {tails} = <span class="hljs-keyword">this</span>
        i = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">while</span> tail = tails[++i] <span class="hljs-keyword">when</span> tail.key?items
            tail.carp <span class="hljs-string">'calling a slice'</span> <span class="hljs-keyword">if</span> tails[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">instanceof</span> Call
            x = tails.splice <span class="hljs-number">0</span> i+<span class="hljs-number">1</span>
            x = x.pop!key.to-slice o, Chain(@head, x)unwrap!, tail.symbol, assign
            @head = x &lt;&lt;&lt; {@front}
            i = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <h3 id="call">Call</h3>
<p><code>x(y)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Call</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (args || []) ~&gt;
        <span class="hljs-keyword">if</span> args.length <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (splat = args<span class="hljs-number">.0</span>) <span class="hljs-keyword">instanceof</span> Splat
            <span class="hljs-keyword">if</span> splat.filler
                @method = \.call
                args &lt;&lt;&lt; [Literal \<span class="hljs-keyword">this</span>; Splat Literal \arguments]
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> splat.it <span class="hljs-keyword">instanceof</span> Arr
                args = splat.it.items
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">for</span> a, i <span class="hljs-keyword">in</span> args <span class="hljs-keyword">when</span> a.value <span class="hljs-keyword">is</span> \_
                args[i] = Chain Literal \void
                args[i].placeholder = <span class="hljs-literal">true</span>
                (@partialized ?= []).push Chain Literal i
        <span class="hljs-keyword">this</span> &lt;&lt;&lt; {args}

    children: [\args]

    show: <span class="hljs-function">-&gt;</span> [@new] + [@method] + [\? <span class="hljs-keyword">if</span> @soak]

    compile: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        code  =  [sn(<span class="hljs-keyword">this</span>, (@method <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>), \() + (<span class="hljs-keyword">if</span> @pipe <span class="hljs-keyword">then</span> <span class="hljs-string">"\n<span class="hljs-subst">#{o.indent}</span>"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">''</span>)]
        <span class="hljs-keyword">for</span> a, i <span class="hljs-keyword">in</span> @args
            code.push (<span class="hljs-keyword">if</span> i <span class="hljs-keyword">then</span> <span class="hljs-string">', '</span> <span class="hljs-keyword">else</span> <span class="hljs-string">''</span>), a.compile o, LEVEL_LIST
        code.push sn(<span class="hljs-keyword">this</span>, \))
        sn(<span class="hljs-literal">null</span>, ...code)
    @make = <span class="hljs-function"><span class="hljs-params">(callee, args, opts)</span> -&gt;</span>
        call = Call args
        call &lt;&lt;&lt; opts <span class="hljs-keyword">if</span> opts
        Chain(callee)add call

    @block = <span class="hljs-function"><span class="hljs-params">(fun, args, method)</span> -&gt;</span>
        Parens(Chain fun, [Call(args) &lt;&lt;&lt; {method}]; <span class="hljs-literal">true</span>) &lt;&lt;&lt; {+calling}

    @back = <span class="hljs-function"><span class="hljs-params">(params, node, bound, curried, hushed, generator)</span> -&gt;</span>
        fun = Fun params,, bound, curried, hushed, generator
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Label
            fun &lt;&lt;&lt; {name: node.label, +labeled}
            node.=it
        node.=it <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> fun.hushed <span class="hljs-keyword">and</span> fun.hushed = node.op <span class="hljs-keyword">is</span> \!
        node.get-call!?partialized = <span class="hljs-literal">null</span>
        {args} = node.get-call! <span class="hljs-keyword">or</span> (node = Chain node .add Call!)get-call!
        index = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> args
            <span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> a.placeholder
            ++index
        node &lt;&lt;&lt; back: (args[index] = fun)body

    @let = <span class="hljs-function"><span class="hljs-params">(args, body, generator = <span class="hljs-literal">false</span>)</span> -&gt;</span>
        params = <span class="hljs-keyword">for</span> a, i <span class="hljs-keyword">in</span> args
            <span class="hljs-keyword">if</span> a.op <span class="hljs-keyword">is</span> \= <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> a.logic <span class="hljs-keyword">and</span> a.right
                args[i] = that
                <span class="hljs-keyword">continue</span> <span class="hljs-keyword">if</span> i <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> gotThis = a.left.value <span class="hljs-keyword">is</span> \<span class="hljs-keyword">this</span>
                a.left
            <span class="hljs-keyword">else</span> Var a.var-name! || a.carp <span class="hljs-string">'invalid "let" argument'</span>
        gotThis <span class="hljs-keyword">or</span> args.unshift Literal \<span class="hljs-keyword">this</span>
        @block Fun(params, body, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, generator), args, \.call</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <h3 id="list">List</h3>
<p>An abstract node for a list of comma-separated items.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    children: [\items]

    show  : <span class="hljs-function">-&gt;</span> @name
    named : <span class="hljs-function"><span class="hljs-params">(@name)</span> -&gt;</span> <span class="hljs-keyword">this</span>

    <span class="hljs-keyword">is</span>-empty: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">not</span> @items.length
    assigns: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> @items <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> node.assigns it

    @compile = <span class="hljs-function"><span class="hljs-params">(o, items, deep-eq)</span> -&gt;</span>
        <span class="hljs-keyword">switch</span> items.length
        | <span class="hljs-number">0</span> =&gt; <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
        | <span class="hljs-number">1</span> =&gt; <span class="hljs-keyword">return</span> items<span class="hljs-number">.0</span>.compile o, LEVEL_LIST
        {indent, level} = o
        o &lt;&lt;&lt; indent: indent + TAB, level: LEVEL_LIST
        code  = [items[i = <span class="hljs-number">0</span>]compile o]
        <span class="hljs-keyword">while</span> items[++i]
            code.push <span class="hljs-string">', '</span>
            target = that
            <span class="hljs-keyword">if</span> deep-eq
                <span class="hljs-keyword">if</span> target <span class="hljs-keyword">instanceof</span> Var <span class="hljs-keyword">and</span> target.value <span class="hljs-keyword">is</span> \_
                    target = Obj [Prop (Key \__placeholder__), Literal <span class="hljs-literal">true</span>]
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> target <span class="hljs-keyword">instanceof</span> [Obj, Arr]
                    target.deep-eq = <span class="hljs-literal">true</span>
            code.push target.compile o
        code  = [<span class="hljs-string">"\n<span class="hljs-subst">#{o.indent}</span>"</span>, ...code, <span class="hljs-string">"\n#indent"</span>] <span class="hljs-keyword">if</span> ~code.join(<span class="hljs-string">""</span>).indexOf \\n
        o &lt;&lt;&lt; {indent, level}
        sn(<span class="hljs-keyword">this</span>, ...code)</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <h3 id="obj">Obj</h3>
<p><code>{x: y}</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Obj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">List</span></span>
    (@items <span class="hljs-keyword">or</span> []) ~&gt;

    as-obj: THIS</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p><code>base{x: y}</code> =&gt; <code>{x: base.y}</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    to-slice: <span class="hljs-function"><span class="hljs-params">(o, base, symbol, assign)</span> -&gt;</span>
        {items} = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">if</span> items.length &gt; <span class="hljs-number">1</span>
            [base, ref, temps] = base.cache o
        <span class="hljs-keyword">else</span>
            ref = base
        <span class="hljs-keyword">for</span> node, i <span class="hljs-keyword">in</span> items
            <span class="hljs-keyword">continue</span> <span class="hljs-keyword">if</span> node.comment
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> [Prop, Splat]
                node[name = node.children[*<span class="hljs-number">-1</span>]] =
                    chain = Chain base, [Index node[name]maybe-key!]
            <span class="hljs-keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p><code>o{k or v}</code> =&gt; <code>{k: a.k or v}</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                node.=first <span class="hljs-keyword">if</span> logic = node.get-default!
                <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Parens</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p><code>a{(++i)}</code> =&gt; <code>{(ref$ = ++i): a[ref$]}</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    [key, node] = node.cache o, <span class="hljs-literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p><code>a{(++i)} = b</code> =&gt; <code>{(ref$): a[ref$ = ++i]} = b</code>
               =&gt; <code>a[ref$ = ++i] = b[ref$]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    [key, node] = [node, key] <span class="hljs-keyword">if</span> assign
                    key = Parens key
                <span class="hljs-keyword">else</span> key = node
                val = chain = Chain base, [Index node.maybe-key!, symbol]
                val = logic &lt;&lt;&lt; first: val <span class="hljs-keyword">if</span> logic
                items[i] = Prop key, val
            base = ref
        chain <span class="hljs-keyword">or</span> @carp <span class="hljs-string">'empty slice'</span>
        (chain.head = Var temps<span class="hljs-number">.0</span>)temp = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> temps
        <span class="hljs-keyword">this</span>

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        {items} = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">if</span> @front <span class="hljs-keyword">then</span> <span class="hljs-string">'({})'</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'{}'</span>) <span class="hljs-keyword">unless</span> items.length
        code = []
        idt = \\n + o.indent += TAB
        dic = {}
        <span class="hljs-keyword">for</span> node, i <span class="hljs-keyword">in</span> items
            <span class="hljs-keyword">if</span> node.comment
                code.push idt, node.compile o
                <span class="hljs-keyword">continue</span>
            node.=first <span class="hljs-keyword">if</span> logic = node.get-default!
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Splat <span class="hljs-keyword">or</span> (node.key <span class="hljs-keyword">or</span> node) <span class="hljs-keyword">instanceof</span> Parens
                rest = items.slice i
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">if</span> logic</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p><code>{@a or b}</code> =&gt; <code>{a: @a or b}</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Prop
                <span class="hljs-keyword">then</span> node.val = logic &lt;&lt;&lt; first: node.val
                <span class="hljs-keyword">else</span> node = Prop node, logic &lt;&lt;&lt; first: node
            <span class="hljs-keyword">if</span> @deep-eq <span class="hljs-keyword">and</span> node <span class="hljs-keyword">instanceof</span> Prop
                <span class="hljs-keyword">if</span> node.val <span class="hljs-keyword">instanceof</span> Var <span class="hljs-keyword">and</span> node.val.value <span class="hljs-keyword">is</span> \_
                    node.val = Obj [Prop (Key \__placeholder__), Literal <span class="hljs-literal">true</span>]
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> node.val <span class="hljs-keyword">instanceof</span> [Obj, Arr]
                    node.val.deep-eq = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">if</span> multi <span class="hljs-keyword">then</span> code.push \, <span class="hljs-keyword">else</span> multi = <span class="hljs-literal">true</span>
            code.push idt
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Prop
                {key, val} = node
                <span class="hljs-keyword">if</span> node.accessor
                    code.push (node.compile-accessor o, key.=compile o)
                <span class="hljs-keyword">else</span>
                    val.rip-name key
                    code.push (key.=compile o), <span class="hljs-string">": "</span>, (val.compile o, LEVEL_LIST)
            <span class="hljs-keyword">else</span>
                code.push (key = node.compile o), <span class="hljs-string">": "</span>, key</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Canonicalize the key, e.g.: <code>0.0</code> =&gt; <code>0</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            ID.test key <span class="hljs-keyword">or</span> key = <span class="hljs-keyword">do</span> Function <span class="hljs-string">"return #key"</span>
            node.carp <span class="hljs-string">"duplicate property \"#key\""</span> <span class="hljs-keyword">unless</span> dic<span class="hljs-string">"#key."</span> .^.= <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> code.join(<span class="hljs-string">""</span>) <span class="hljs-keyword">then</span> code.push \\n + @tab
        code = sn(<span class="hljs-literal">null</span>, sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"{"</span>), ...code, sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"}"</span>))
        rest <span class="hljs-keyword">and</span> code = Import(JS code; Obj rest)compile o &lt;&lt;&lt; indent: @tab
        <span class="hljs-keyword">if</span> @front <span class="hljs-keyword">and</span> \{ <span class="hljs-keyword">is</span> code.to-string!.char-at! <span class="hljs-keyword">then</span> sn(<span class="hljs-literal">null</span>, <span class="hljs-string">"("</span>, code, <span class="hljs-string">")"</span>) <span class="hljs-keyword">else</span> code</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <h3 id="prop">Prop</h3>
<p><code>x: y</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Prop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@key, @val) ~&gt;
        <span class="hljs-keyword">return</span> Splat @val <span class="hljs-keyword">if</span> key.value <span class="hljs-keyword">is</span> \...
        <span class="hljs-keyword">if</span> val.get-accessors!
            @val = that
            <span class="hljs-keyword">for</span> fun <span class="hljs-keyword">in</span> that
                fun.x = <span class="hljs-keyword">if</span> fun.hushed = fun.params.length <span class="hljs-keyword">then</span> \s <span class="hljs-keyword">else</span> \g
            <span class="hljs-keyword">this</span> &lt;&lt;&lt; {\accessor}

    children: &lt;[ key val ]&gt;

    show: <span class="hljs-function">-&gt;</span> @accessor

    assigns: <span class="hljs-function">-&gt;</span> @val.assigns? it

    compile-accessor: <span class="hljs-function"><span class="hljs-params">(o, key)</span> -&gt;</span>
        funs = @val
        <span class="hljs-keyword">if</span> funs<span class="hljs-number">.1</span> <span class="hljs-keyword">and</span> funs<span class="hljs-number">.0</span>.params.length + funs<span class="hljs-number">.1</span>.params.length <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-number">1</span>
            funs<span class="hljs-number">.0</span>.carp <span class="hljs-string">'invalid accessor parameter'</span>

        code = []
        <span class="hljs-keyword">for</span> fun <span class="hljs-keyword">in</span> funs
            fun.accessor = <span class="hljs-literal">true</span>
            code.push fun.x, <span class="hljs-string">"et "</span>, key, (fun.compile o, LEVEL_LIST .to-string!.slice <span class="hljs-number">8</span>), <span class="hljs-string">',\n'</span> + o.indent
        code.pop!
        sn(<span class="hljs-literal">null</span>, ...code)

    compile-descriptor: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        obj = Obj!
        <span class="hljs-keyword">for</span> fun <span class="hljs-keyword">in</span> @val <span class="hljs-keyword">then</span> obj.items.push Prop Key(fun.x + \et  ), fun
        obj.items.push Prop Key(\configurable), Literal <span class="hljs-literal">true</span>
        obj.items.push Prop Key(\enumerable  ), Literal <span class="hljs-literal">true</span>
        obj.compile o</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <h3 id="arr">Arr</h3>
<p><code>[x, y]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Arr</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">List</span></span>
    (@items <span class="hljs-keyword">or</span> []) ~&gt;

    <span class="hljs-keyword">is</span>-array: YES

    as-obj: <span class="hljs-function">-&gt;</span> Obj([Prop Literal(i), item <span class="hljs-keyword">for</span> item, i <span class="hljs-keyword">in</span> @items])</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p><code>base[x, ...y]</code> =&gt; <code>[base[x], ...base[y]]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    to-slice: <span class="hljs-function"><span class="hljs-params">(o, base, symbol)</span> -&gt;</span>
        {items} = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">if</span> items.length &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> [base, ref] = base.cache o <span class="hljs-keyword">else</span> ref = base
        <span class="hljs-keyword">for</span> item, i <span class="hljs-keyword">in</span> items
            item.=it <span class="hljs-keyword">if</span> splat = item <span class="hljs-keyword">instanceof</span> Splat
            <span class="hljs-keyword">continue</span> <span class="hljs-keyword">if</span> item.<span class="hljs-keyword">is</span>-empty!
            chain = Chain base, [Index item, symbol]
            items[i] = <span class="hljs-keyword">if</span> splat <span class="hljs-keyword">then</span> Splat chain <span class="hljs-keyword">else</span> chain
            base = ref
        chain <span class="hljs-keyword">or</span> @carp <span class="hljs-string">'empty slice'</span>
        <span class="hljs-keyword">this</span>

    compile: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        {items} = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">'[]'</span>) <span class="hljs-keyword">unless</span> items.length
        <span class="hljs-keyword">unless</span> sn-empty(code = Splat.compile-array o, items)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> @newed <span class="hljs-keyword">then</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, code, <span class="hljs-string">")"</span>) <span class="hljs-keyword">else</span> sn(<span class="hljs-keyword">this</span>, code)
        sn(<span class="hljs-literal">null</span>, sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"["</span>), (List.compile o, items, @deep-eq), sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"]"</span>))

    @maybe = <span class="hljs-function"><span class="hljs-params">(nodes)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> nodes<span class="hljs-number">.0</span> <span class="hljs-keyword">if</span> nodes.length <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nodes<span class="hljs-number">.0</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Splat
        constructor nodes

    @wrap = <span class="hljs-function">-&gt;</span> constructor [Splat it &lt;&lt;&lt; <span class="hljs-keyword">is</span>-array: YES]

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Yield</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@op, @it) ~&gt;

    children: &lt;[ it ]&gt;

    show: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">if</span> @op <span class="hljs-keyword">is</span> <span class="hljs-string">'yieldfrom'</span> <span class="hljs-keyword">then</span> <span class="hljs-string">'from'</span> <span class="hljs-keyword">else</span> <span class="hljs-string">''</span>

    ::delegate &lt;[ isCallable ]&gt; -&gt; <span class="hljs-literal">yes</span>

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        code = []

        <span class="hljs-keyword">if</span> @op <span class="hljs-keyword">is</span> \yieldfrom
            code.push <span class="hljs-string">'yield*'</span>
        <span class="hljs-keyword">else</span>
            code.push <span class="hljs-string">'yield'</span>

        <span class="hljs-keyword">if</span> @it
            code.push <span class="hljs-string">" <span class="hljs-subst">#{@it.compile o, LEVEL_OP + PREC.unary}</span>"</span>

        sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <h3 id="unary-operators">Unary operators</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Unary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p><code>flag</code> denotes inversion or postcrement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    (op, it, flag) ~&gt;
        <span class="hljs-keyword">if</span> it?
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag <span class="hljs-keyword">and</span> it.unaries
                that.push op
                <span class="hljs-keyword">return</span> it
            <span class="hljs-keyword">switch</span> op
            case \!
                <span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> flag
                <span class="hljs-keyword">return</span> it &lt;&lt;&lt; {+hushed} <span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Fun <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> it.hushed
                <span class="hljs-keyword">return</span> it.invert!
            case \++ \-- <span class="hljs-keyword">then</span> @post = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> flag
            case \<span class="hljs-keyword">new</span></pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p><code>new C?</code> =&gt; <code>new C?()</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Existence <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> it.negated
                    it = Chain(it)add Call!
                it.newed = <span class="hljs-literal">true</span>
                <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> it.tails <span class="hljs-keyword">or</span> <span class="hljs-string">''</span> <span class="hljs-keyword">when</span> node <span class="hljs-keyword">instanceof</span> Call <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.<span class="hljs-keyword">new</span>
                    node.args.shift! <span class="hljs-keyword">if</span> node.method <span class="hljs-keyword">is</span> \.call
                    node &lt;&lt;&lt; {\<span class="hljs-keyword">new</span>, method: <span class="hljs-string">''</span>}
                    <span class="hljs-keyword">return</span> it
            case \~ <span class="hljs-keyword">then</span> <span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Fun <span class="hljs-keyword">and</span> it.statement <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> it.bound
                <span class="hljs-keyword">return</span> it &lt;&lt;&lt; bound: \<span class="hljs-keyword">this</span>$
        <span class="hljs-keyword">this</span> &lt;&lt;&lt; {op, it}

    children: [\it]

    show: <span class="hljs-function">-&gt;</span> [\@ <span class="hljs-keyword">if</span> @post] + @op

    <span class="hljs-keyword">is</span>-callable: <span class="hljs-function">-&gt;</span> @op <span class="hljs-keyword">in</span> &lt;[ <span class="hljs-keyword">do</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">delete</span> ]&gt; <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> @it?

    <span class="hljs-keyword">is</span>-array: <span class="hljs-function">-&gt;</span> @it <span class="hljs-keyword">instanceof</span> Arr   <span class="hljs-keyword">and</span> @it.items.length
           <span class="hljs-keyword">or</span> @it <span class="hljs-keyword">instanceof</span> Chain <span class="hljs-keyword">and</span> @it.<span class="hljs-keyword">is</span>-array!

    <span class="hljs-keyword">is</span>-string: <span class="hljs-function">-&gt;</span> @op <span class="hljs-keyword">in</span> &lt;[ <span class="hljs-keyword">typeof</span> classof ]&gt;

    invert: <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">return</span> @it <span class="hljs-keyword">if</span> @op <span class="hljs-keyword">is</span> \! <span class="hljs-keyword">and</span> @it.op <span class="hljs-keyword">in</span> &lt;[ ! &lt; &gt; &lt;= &gt;= <span class="hljs-keyword">of</span> <span class="hljs-keyword">instanceof</span> ]&gt;
        constructor \! <span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>

    unfold-soak: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        @op <span class="hljs-keyword">in</span> &lt;[ ++ -- <span class="hljs-keyword">delete</span> ]&gt; <span class="hljs-keyword">and</span> @it? <span class="hljs-keyword">and</span> If.unfold-soak o, <span class="hljs-keyword">this</span>, \it

    get-accessors: <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">unless</span> @op <span class="hljs-keyword">is</span> \~
        <span class="hljs-keyword">return</span> [@it] <span class="hljs-keyword">if</span> @it <span class="hljs-keyword">instanceof</span> Fun
        <span class="hljs-keyword">if</span> @it <span class="hljs-keyword">instanceof</span> Arr
            {items} = @it
            <span class="hljs-keyword">return</span> items <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> items<span class="hljs-number">.2</span>
                         <span class="hljs-keyword">and</span> items<span class="hljs-number">.0</span> <span class="hljs-keyword">instanceof</span> Fun
                         <span class="hljs-keyword">and</span> items<span class="hljs-number">.1</span> <span class="hljs-keyword">instanceof</span> Fun

    function crement <span class="hljs-keyword">then</span> {<span class="hljs-string">'++'</span>:\<span class="hljs-keyword">in</span> <span class="hljs-string">'--'</span>:\de}[it] + \crement

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> @compile-as-func o <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> @it?
        <span class="hljs-keyword">return</span> that <span class="hljs-keyword">if</span> @compile-spread o
        {op, it} = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">switch</span> op
        case \!   <span class="hljs-keyword">then</span> it.cond = <span class="hljs-literal">true</span>
        case \<span class="hljs-keyword">new</span> <span class="hljs-keyword">then</span> it.<span class="hljs-keyword">is</span>-callable! <span class="hljs-keyword">or</span> it.carp <span class="hljs-string">'invalid constructor'</span>
        case \<span class="hljs-keyword">do</span></pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p><code>do f?</code> =&gt; <code>f?()</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> o.level <span class="hljs-keyword">is</span> LEVEL_TOP <span class="hljs-keyword">and</span> it <span class="hljs-keyword">instanceof</span> Fun <span class="hljs-keyword">and</span> it.<span class="hljs-keyword">is</span>-statement!
                <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, (it.compile o), <span class="hljs-string">" "</span>, (Unary \<span class="hljs-keyword">do</span> Var it.name .compile o))
            x = Parens <span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Existence <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> it.negated
                 <span class="hljs-keyword">then</span> Chain(it)add Call!
                 <span class="hljs-keyword">else</span> Call.make it
            <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, (x &lt;&lt;&lt; {@front, @newed})compile o)
        case \<span class="hljs-keyword">delete</span>
            @carp <span class="hljs-string">'invalid delete'</span> <span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Var <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> it.<span class="hljs-keyword">is</span>-assignable!
            <span class="hljs-keyword">return</span> @compile-pluck o <span class="hljs-keyword">if</span> o.level <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @void
        case \++ \--
            it.<span class="hljs-keyword">is</span>-assignable! <span class="hljs-keyword">or</span> @carp <span class="hljs-string">'invalid '</span> + crement op
            <span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Var <span class="hljs-keyword">and</span> o.scope.checkReadOnly it.value
                @carp <span class="hljs-string">"<span class="hljs-subst">#{ crement op }</span> of #that \"<span class="hljs-subst">#{it.value}</span>\""</span> ReferenceError
            it{front} = <span class="hljs-keyword">this</span> <span class="hljs-keyword">if</span> @post
        case \^^ <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, (util \clone), <span class="hljs-string">"("</span>, (it.compile o, LEVEL_LIST), <span class="hljs-string">")"</span>)
        case \jsdelete <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"delete "</span>, (it.compile o, LEVEL_LIST))
        case \classof
            <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, (util \toString), <span class="hljs-string">".call(
              "</span>, (it.compile o, LEVEL_LIST), <span class="hljs-string">").slice(8, -1)"</span>)
        code = [(it.compile o, LEVEL_OP + PREC.unary)]
        <span class="hljs-keyword">if</span> @post <span class="hljs-keyword">then</span> code.push op <span class="hljs-keyword">else</span>
            op += <span class="hljs-string">' '</span> <span class="hljs-keyword">if</span> op <span class="hljs-keyword">in</span> &lt;[ <span class="hljs-keyword">new</span> <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">delete</span> ]&gt;
                <span class="hljs-keyword">or</span> op <span class="hljs-keyword">in</span> &lt;[ + - ]&gt; <span class="hljs-keyword">and</span> op <span class="hljs-keyword">is</span> code.join(<span class="hljs-string">""</span>).char-at!
            code.unshift op
        <span class="hljs-keyword">if</span> o.level &lt; LEVEL_CALL <span class="hljs-keyword">then</span> sn(<span class="hljs-keyword">this</span>, ...code) <span class="hljs-keyword">else</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p><code>^delete ...o[p, ...q]</code> =&gt; <code>[^delete o[p], ...^delete o[q]]</code>
<code>^delete ...o{p, ...q}</code> =&gt; <code>{p: ^delete o[p], ...^delete o[q]}</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compile-spread: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        {it} = <span class="hljs-keyword">this</span>
        ops = [<span class="hljs-keyword">this</span>]
        <span class="hljs-keyword">while</span> it <span class="hljs-keyword">instanceof</span> constructor, it.=it <span class="hljs-keyword">then</span> ops.push it
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span> <span class="hljs-keyword">unless</span> it <span class="hljs-keyword">instanceof</span> Splat
                  <span class="hljs-keyword">and</span> it.=it.expand-slice(o)unwrap! <span class="hljs-keyword">instanceof</span> List

        @compile-spread-over o, it, <span class="hljs-function"><span class="hljs-params">(node)</span> -&gt;</span>
            <span class="hljs-keyword">for</span> op <span class="hljs-keyword">in</span> ops <span class="hljs-keyword">by</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">then</span> node = constructor op.op, node, op.post
            node</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p><code>v = delete o.k</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compile-pluck: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        [get, del] = Chain @it .cache-reference o
        code = [ref = o.scope.temporary!, <span class="hljs-string">" = \
            "</span>, (get.compile o, LEVEL_LIST), <span class="hljs-string">", delete \
            "</span>, (del.compile o, LEVEL_LIST), <span class="hljs-string">", \
            "</span>, (o.scope.free ref)]
        <span class="hljs-keyword">if</span> o.level &lt; LEVEL_LIST <span class="hljs-keyword">then</span> sn(<span class="hljs-keyword">this</span>, ...code) <span class="hljs-keyword">else</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>)

    compile-as-func: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> @op <span class="hljs-keyword">is</span> \!
        <span class="hljs-keyword">then</span> sn(<span class="hljs-keyword">this</span>, util \<span class="hljs-keyword">not</span>)
        <span class="hljs-keyword">else</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, ((Fun [], Block Unary @op, Chain Var \it).compile o), <span class="hljs-string">")"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <h3 id="binary-operators">Binary operators</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Binary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (op, first, second, destructuring) ~&gt;
        <span class="hljs-keyword">if</span> destructuring
            logic = op.logic
            logic = destructuring <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span>! destructuring <span class="hljs-keyword">is</span> \String
            op = | logic    =&gt; that
                 | op <span class="hljs-keyword">is</span> \= <span class="hljs-function">=&gt;</span> \?
                 | _        =&gt; \=
        @partial = <span class="hljs-keyword">not</span> first? <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> second?
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> @partial
            <span class="hljs-keyword">if</span> \= <span class="hljs-keyword">is</span> op.char-at op.length<span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> op.char-at(op.length<span class="hljs-number">-2</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> &lt;[ = &lt; &gt; ! ]&gt;
                <span class="hljs-keyword">return</span> Assign first.unwrap!, second, op
            <span class="hljs-keyword">switch</span> op
            | \<span class="hljs-keyword">in</span>        =&gt; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> In first, second
            | \with      =&gt; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Import (Unary \^^ first), second, <span class="hljs-literal">false</span>
            | \&lt;&lt;&lt; \&lt;&lt;&lt;&lt; =&gt; <span class="hljs-keyword">return</span> Import first, second, op <span class="hljs-keyword">is</span> \&lt;&lt;&lt;&lt;
            | \&lt;|        =&gt; <span class="hljs-keyword">return</span> Block first .pipe second, op
            | \|&gt;        =&gt; <span class="hljs-keyword">return</span> Block second .pipe first, \&lt;|
            | \. \.~     =&gt; <span class="hljs-keyword">return</span> Chain first .add Index second, op
        <span class="hljs-keyword">this</span> &lt;&lt;&lt; {op, first, second}

    children: &lt;[ first second ]&gt;

    show: <span class="hljs-function">-&gt;</span> @op

    <span class="hljs-keyword">is</span>-callable: <span class="hljs-function">-&gt;</span>
        @partial <span class="hljs-keyword">or</span> @op <span class="hljs-keyword">in</span> &lt;[ &amp;&amp; || ? &lt;&lt; &gt;&gt; ]&gt; <span class="hljs-keyword">and</span> @first.<span class="hljs-keyword">is</span>-callable! <span class="hljs-keyword">and</span> @second.<span class="hljs-keyword">is</span>-callable!

    <span class="hljs-keyword">is</span>-array: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">switch</span> @op | \* =&gt; @first .<span class="hljs-keyword">is</span>-array!
                          | \/ =&gt; @second.<span class="hljs-keyword">is</span>-matcher!

    <span class="hljs-keyword">is</span>-string: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">switch</span> @op
        | \+ \* =&gt; @first.<span class="hljs-keyword">is</span>-string! <span class="hljs-keyword">or</span> @second.<span class="hljs-keyword">is</span>-string!
        | \-    =&gt; @second.<span class="hljs-keyword">is</span>-matcher!

    COMPARER   = <span class="hljs-regexp">/^(?:[!=]=|[&lt;&gt;])=?$/</span>
    INVERSIONS = <span class="hljs-string">'==='</span>:<span class="hljs-string">'!=='</span> <span class="hljs-string">'!=='</span>:<span class="hljs-string">'==='</span> <span class="hljs-string">'=='</span>:<span class="hljs-string">'!='</span> <span class="hljs-string">'!='</span>:<span class="hljs-string">'=='</span>

    invert: <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> COMPARER.test @second.op <span class="hljs-keyword">and</span> INVERSIONS[@op]
            @op = that
            @was-inverted = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
        Unary \! Parens(<span class="hljs-keyword">this</span>), <span class="hljs-literal">true</span>

    invertIt: <span class="hljs-function">-&gt;</span> @inverted = <span class="hljs-literal">true</span>; <span class="hljs-keyword">this</span>

    get-default: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">switch</span> @op | \? \|| \&amp;&amp; =&gt; <span class="hljs-keyword">this</span>

    xor-children: <span class="hljs-function"><span class="hljs-params">(test)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">unless</span> (first = test @first) xor test @second
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> first <span class="hljs-keyword">then</span> [@first, @second] <span class="hljs-keyword">else</span> [@second, @first]

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> @compilePartial o <span class="hljs-keyword">if</span> @partial
        <span class="hljs-keyword">switch</span> @op
        case \? <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> @compileExistence o
        case \*
            <span class="hljs-keyword">return</span> @compileJoin   o <span class="hljs-keyword">if</span> @second.<span class="hljs-keyword">is</span>-string!
            <span class="hljs-keyword">return</span> @compileRepeat o <span class="hljs-keyword">if</span> @first.<span class="hljs-keyword">is</span>-string! <span class="hljs-keyword">or</span> @first.<span class="hljs-keyword">is</span>-array!
        case \-       <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> @compileRemove o <span class="hljs-keyword">if</span> @second.<span class="hljs-keyword">is</span>-matcher!
        case \/       <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> @compileSplit  o <span class="hljs-keyword">if</span> @second.<span class="hljs-keyword">is</span>-matcher!
        case \** \^   <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> @compilePow o
        case \&lt;? \&gt;?  <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> @compileMinMax o
        case \&lt;&lt; \&gt;&gt;  <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> @compileCompose o
        case \++      <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> @compileConcat o
        case \%%      <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> @compileMod o
        case \xor     <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> @compileXor o
        case \&amp;&amp; \||
            @second.void = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> top = @void <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> o.level
            <span class="hljs-keyword">if</span> top <span class="hljs-keyword">or</span> @cond
                @first .cond = <span class="hljs-literal">true</span>
                @second.cond = <span class="hljs-literal">true</span>
        case \<span class="hljs-keyword">instanceof</span>
            {items}:rite = @second.expand-slice(o)unwrap!
            <span class="hljs-keyword">if</span> rite <span class="hljs-keyword">instanceof</span> Arr
                <span class="hljs-keyword">return</span> @compileAnyInstanceOf o, items <span class="hljs-keyword">if</span> items<span class="hljs-number">.1</span>
                @second = items<span class="hljs-number">.0</span> <span class="hljs-keyword">or</span> rite
            @second.<span class="hljs-keyword">is</span>-callable! <span class="hljs-keyword">or</span> @second.carp <span class="hljs-string">'invalid instanceof operand'</span>
        case &lt;[ ==== !=== ]&gt;       <span class="hljs-keyword">then</span> @op.=slice <span class="hljs-number">0</span> <span class="hljs-number">3</span>; fallthrough
        case &lt;[ &lt;== &gt;== &lt;&lt;= &gt;&gt;= ]&gt; <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> @compileDeepEq o
        default
            <span class="hljs-keyword">if</span> COMPARER.test @op
                <span class="hljs-keyword">if</span> @op <span class="hljs-keyword">in</span> [\=== \!==] <span class="hljs-keyword">and</span> @xor-children (.<span class="hljs-keyword">is</span>-regex!)
                    <span class="hljs-keyword">return</span> @compileRegexEquals o, that
                <span class="hljs-keyword">if</span> @op <span class="hljs-keyword">is</span> \=== <span class="hljs-keyword">and</span> (@first <span class="hljs-keyword">instanceof</span> Literal <span class="hljs-keyword">and</span> @second <span class="hljs-keyword">instanceof</span> Literal)
                <span class="hljs-keyword">and</span> @first.<span class="hljs-keyword">is</span>-what! <span class="hljs-keyword">isnt</span> @second.<span class="hljs-keyword">is</span>-what!
                    <span class="hljs-built_in">console</span>?.warn <span class="hljs-string">"WARNING: strict comparison of two different types will always be false: <span class="hljs-subst">#{@first.value}</span> == <span class="hljs-subst">#{@second.value}</span>"</span>
            <span class="hljs-keyword">return</span> @compileChain o <span class="hljs-keyword">if</span> COMPARER.test @op <span class="hljs-keyword">and</span> COMPARER.test @second.op
        @first &lt;&lt;&lt; {@front}
        code = [(@first .compile o, level = LEVEL_OP + PREC[@op]), <span class="hljs-string">" "</span>, (@mapOp @op), <span class="hljs-string">" "</span>, (@second.compile o, level)]
        <span class="hljs-keyword">if</span> o.level &lt;= level <span class="hljs-keyword">then</span> sn(<span class="hljs-keyword">this</span>, ...code) <span class="hljs-keyword">else</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>)

    mapOp: <span class="hljs-function"><span class="hljs-params">(op)</span> -&gt;</span>
        | op.match <span class="hljs-regexp">//</span>\.([&amp;\|\^] | &lt;&lt; | &gt;&gt;&gt;?)\.<span class="hljs-regexp">//</span> =&gt; that<span class="hljs-number">.1</span>
        | op <span class="hljs-keyword">is</span> \<span class="hljs-keyword">of</span>                              =&gt; \<span class="hljs-keyword">in</span>
        | otherwise                              =&gt; op</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>Mimic Python/Perl6’s chained comparisons
when multiple comparison operators are used sequentially:</p>
<pre><code>$ livescript -pe <span class="hljs-string">'50 &lt; 65 === 9r72 &gt; 10'</span>
<span class="hljs-literal">true</span>
</code></pre><p>See <a href="http://docs.python.org/reference/expressions.html#notin">http://docs.python.org/reference/expressions.html#notin</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compileChain: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        code = [(@first.compile o, level = LEVEL_OP + PREC[@op])]
        [sub, @second.first] = @second.first.cache o, <span class="hljs-literal">true</span>
        code.push <span class="hljs-string">" "</span>, @op, <span class="hljs-string">" "</span>, (sub.compile o, level), <span class="hljs-string">" &amp;&amp; "</span>, (@second.compile o, LEVEL_OP)
        <span class="hljs-keyword">if</span> o.level &lt;= LEVEL_OP <span class="hljs-keyword">then</span> sn(<span class="hljs-keyword">this</span>, ...code) <span class="hljs-keyword">else</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>)

    compileExistence: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> @void <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> o.level
            x = Binary \&amp;&amp; Existence(@first, <span class="hljs-literal">true</span>), @second
            <span class="hljs-keyword">return</span> (x &lt;&lt;&lt; {+void})compile-node o
        x = @first.cache o, <span class="hljs-literal">true</span>
        sn(<span class="hljs-keyword">this</span>, If(Existence x<span class="hljs-number">.0</span>; x<span class="hljs-number">.1</span>)add-<span class="hljs-keyword">else</span>(@second)compile-expression o)</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p><code>x instanceof [A, B]</code> =&gt; <code>x instanceof A || x instanceof B</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compileAnyInstanceOf: <span class="hljs-function"><span class="hljs-params">(o, items)</span> -&gt;</span>
        [sub, ref, @temps] = @first.cache o
        test = Binary \<span class="hljs-keyword">instanceof</span> sub, items.shift!
        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items <span class="hljs-keyword">then</span> test = Binary \|| test, Binary \<span class="hljs-keyword">instanceof</span> ref, item
        sn(<span class="hljs-keyword">this</span>, Parens test .compile o)

    compileMinMax: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        lefts = @first .cache o, <span class="hljs-literal">true</span>
        rites = @second.cache o, <span class="hljs-literal">true</span>
        x = Binary @op.char-at!, lefts<span class="hljs-number">.0</span>, rites<span class="hljs-number">.0</span>
        sn(<span class="hljs-keyword">this</span>, If x, lefts<span class="hljs-number">.1</span> .add-<span class="hljs-keyword">else</span> rites<span class="hljs-number">.1</span> .compile-expression o)

    compileMethod: <span class="hljs-function"><span class="hljs-params">(o, klass, method, arg)</span> -&gt;</span>
        args = [@second] ++ (arg || [])
        <span class="hljs-keyword">if</span> @first<span class="hljs-string">"is#klass"</span>!
            sn(<span class="hljs-keyword">this</span>, Chain(@first, [Index Key method; Call args])compile o)
        <span class="hljs-keyword">else</span>
            args.unshift @first
            sn(<span class="hljs-keyword">this</span>, Call.make(JS util(method) + \.call; args)compile o)

    compileJoin   : <span class="hljs-function">-&gt;</span> @compileMethod it, \Array  \join
    compileRemove : <span class="hljs-function">-&gt;</span> @compileMethod it, \String \replace JS <span class="hljs-string">"''"</span>
    compileSplit  : <span class="hljs-function">-&gt;</span> @compileMethod it, \String \split

    compileRepeat: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        {first: x, second: n} = <span class="hljs-keyword">this</span>
        {items} = x.=expand-slice o .unwrap!
        arr = x.<span class="hljs-keyword">is</span>-array! <span class="hljs-keyword">and</span> \Array
        <span class="hljs-keyword">if</span> items <span class="hljs-keyword">and</span> !sn-empty(arrCode = Splat.compile-array o, items)
            x     = JS arrCode
            items = <span class="hljs-literal">null</span>
        <span class="hljs-keyword">if</span> arr <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> items
        <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> (n <span class="hljs-keyword">instanceof</span> Literal <span class="hljs-keyword">and</span> n.value &lt; <span class="hljs-number">0x20</span>)
            <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, (Call.make Util(\repeat + (arr <span class="hljs-keyword">or</span> \String)), [x, n] .compile o))
        n = +n.value
        <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, x.compile o) <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> &lt;= n &lt; <span class="hljs-number">2</span></pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p><code>[x] * 2</code> =&gt; <code>[x, x]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> items
            <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, (Block items .add JS <span class="hljs-string">'[]'</span> .compile o))
            refs = []
            <span class="hljs-keyword">for</span> item, i <span class="hljs-keyword">in</span> items <span class="hljs-keyword">then</span> [items[i], refs.*] = item.cache o, <span class="hljs-number">1</span>x
            items.push JS! &lt;&lt;&lt;
                compile: <span class="hljs-function">-&gt;</span> sn(<span class="hljs-keyword">this</span>, ...(([<span class="hljs-string">", "</span>, (List.compile o, refs)] * (n<span class="hljs-number">-1</span>))slice <span class="hljs-number">1</span>))
            sn(<span class="hljs-keyword">this</span>, x.compile o)</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p><code>&#39;x&#39; * 2</code> =&gt; <code>&#39;xx&#39;</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x <span class="hljs-keyword">instanceof</span> Literal
            sn(<span class="hljs-keyword">this</span>, (q = (x.=compile o .to-string!)char-at!) + <span class="hljs-string">"<span class="hljs-subst">#{ x.slice <span class="hljs-number">1</span> <span class="hljs-number">-1</span> }</span>"</span> * n + q)</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p><code>&quot;#{x}&quot; * 2</code> =&gt; <code>(ref$ = &quot;&quot; + x) + ref$</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, Block(x.it)add(JS <span class="hljs-string">"''"</span>)compile o)
            x = (refs = x.cache o, <span class="hljs-number">1</span>, LEVEL_OP)<span class="hljs-number">0</span> + <span class="hljs-string">" + <span class="hljs-subst">#{refs<span class="hljs-number">.1</span>}</span>"</span> * (n<span class="hljs-number">-1</span>)
            <span class="hljs-keyword">if</span> o.level &lt; LEVEL_OP + PREC\+ <span class="hljs-keyword">then</span> sn(<span class="hljs-keyword">this</span>, x) <span class="hljs-keyword">else</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, x, <span class="hljs-string">")"</span>)

    compilePow: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span> sn(<span class="hljs-literal">null</span>, Call.make(CopyL <span class="hljs-keyword">this</span>, JS \Math.pow; [@first, @second])compile o)

    compileConcat: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span><span class="hljs-function">
        <span class="hljs-title">f</span> = <span class="hljs-params">(x)</span> -&gt;</span>
            | x <span class="hljs-keyword">instanceof</span> Binary <span class="hljs-keyword">and</span> x.op <span class="hljs-keyword">is</span> \++ =&gt;
                (f x.first) ++ (f x.second)
            | otherwise                            =&gt; [x]
        sn(<span class="hljs-literal">null</span>, (Chain @first .add(CopyL <span class="hljs-keyword">this</span>, Index (Key \concat), \., <span class="hljs-literal">true</span>) .add Call(f @second) .compile o))

    compileCompose: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        op = @op
        functions = [@first]
        x = @second
        <span class="hljs-keyword">while</span> x <span class="hljs-keyword">instanceof</span> Binary <span class="hljs-keyword">and</span> x.op <span class="hljs-keyword">is</span> op <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> x.partial
            functions.push x.first
            x = x.second
        functions.push x

        functions.reverse! <span class="hljs-keyword">if</span> op <span class="hljs-keyword">is</span> \&lt;&lt;

        sn(<span class="hljs-keyword">this</span>, (Chain Var (util \compose) .add Call functions .compile o))

    compileMod: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        ref = o.scope.temporary!
        code = [sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"((("</span>), (@first.compile o), sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">") % ("</span>), sn(<span class="hljs-keyword">this</span>, ref, <span class="hljs-string">" = "</span>), (@second.compile o), sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">") + "</span>, ref, <span class="hljs-string">") % "</span>, ref, <span class="hljs-string">")"</span>)]
        o.scope.free ref
        sn(<span class="hljs-literal">null</span>, ...code)

    compilePartial: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        vit = Var \it
        <span class="hljs-keyword">switch</span>
        case  <span class="hljs-keyword">not</span> @first? <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @second?
            x = Var \x$
            y = Var \y$
            sn(<span class="hljs-keyword">this</span>, (Fun [x, y], Block((Binary @op, x, y).invert-check <span class="hljs-keyword">this</span>), <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>).compile o)
        case @first?
            sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, ((Fun [vit], Block((Binary @op, @first, vit) .invert-check <span class="hljs-keyword">this</span>), <span class="hljs-literal">true</span>).compile o), <span class="hljs-string">")"</span>)
        default
            sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, ((Fun [vit], Block((Binary @op, vit, @second).invert-check <span class="hljs-keyword">this</span>), <span class="hljs-literal">true</span>).compile o), <span class="hljs-string">")"</span>)

    compileRegexEquals: <span class="hljs-function"><span class="hljs-params">(o, [regex, target])</span> -&gt;</span>
        <span class="hljs-keyword">if</span> @op <span class="hljs-keyword">is</span> \===
            method = <span class="hljs-keyword">if</span> @was-inverted <span class="hljs-keyword">then</span> \test <span class="hljs-keyword">else</span> \exec
            sn(<span class="hljs-keyword">this</span>, (Chain regex .add Index Key method .add Call [target] .compile o))
        <span class="hljs-keyword">else</span>
            sn(<span class="hljs-keyword">this</span>, (Unary \! (Chain regex .add Index Key \test .add Call [target]) .compile o))

    compileDeepEq: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> @op <span class="hljs-keyword">in</span> &lt;[ &gt;== &gt;&gt;= ]&gt;
            [@first, @second] = [@second, @first]
            @op = <span class="hljs-keyword">if</span> @op <span class="hljs-keyword">is</span> \&gt;== <span class="hljs-keyword">then</span> \&lt;== <span class="hljs-keyword">else</span> \&lt;&lt;=
        <span class="hljs-keyword">if</span> @op <span class="hljs-keyword">is</span> \!==
            @op = \===
            negate = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [@first, @second]
            x.deep-eq = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> x <span class="hljs-keyword">instanceof</span> [Obj, Arr]
        r = Chain Var (util \deepEq) .add Call [@first, @second, Literal <span class="hljs-string">"'<span class="hljs-subst">#{@op}</span>'"</span>]
        sn(<span class="hljs-keyword">this</span>, (<span class="hljs-keyword">if</span> negate <span class="hljs-keyword">then</span> Unary \! r <span class="hljs-keyword">else</span> r).compile o)

    compileXor: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        left  = Chain @first  .cache-reference o
        right = Chain @second .cache-reference o
        sn(<span class="hljs-keyword">this</span>, (Binary \&amp;&amp; (Binary \!== (Unary \! left<span class="hljs-number">.0</span>), (Unary \! right<span class="hljs-number">.0</span>))
             , (Parens Binary \|| left<span class="hljs-number">.1</span>, right<span class="hljs-number">.1</span>) .compile o))</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <h3 id="assign">Assign</h3>
<p>Assignment to a variable/property.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Assign</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@left, rite, @op <span class="hljs-keyword">or</span> \=, @logic <span class="hljs-keyword">or</span> @op.logic, @defParam) ~&gt;
        @opLoc = @op
        @op += <span class="hljs-string">''</span>
        @[<span class="hljs-keyword">if</span> rite <span class="hljs-keyword">instanceof</span> Node <span class="hljs-keyword">then</span> \right <span class="hljs-keyword">else</span> \unaries] = rite

    children: &lt;[ left right ]&gt;

    show: <span class="hljs-function">-&gt;</span> [,]concat(@unaries)reverse!join(<span class="hljs-string">' '</span>) + [@logic] + @op

    assigns: <span class="hljs-function">-&gt;</span> @left.assigns it

    ::delegate &lt;[ isCallable isRegex ]&gt; -&gt; @op <span class="hljs-keyword">in</span> &lt;[ = := ]&gt; <span class="hljs-keyword">and</span> @right <span class="hljs-keyword">and</span> @right[it]!

    <span class="hljs-keyword">is</span>-array: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">switch</span> @op
        | \= \:= <span class="hljs-function">=&gt;</span> @right <span class="hljs-keyword">and</span> @right.<span class="hljs-keyword">is</span>-array!
        | \/=    <span class="hljs-function">=&gt;</span> @right <span class="hljs-keyword">and</span> @right.<span class="hljs-keyword">is</span>-matcher!

    <span class="hljs-keyword">is</span>-string: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">switch</span> @op
        | \= \:= \+= \*= <span class="hljs-function">=&gt;</span> @right <span class="hljs-keyword">and</span> @right.<span class="hljs-keyword">is</span>-string!
        | \-=            <span class="hljs-function">=&gt;</span> @right <span class="hljs-keyword">and</span> @right.<span class="hljs-keyword">is</span>-matcher!

    unfold-soak: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> @left <span class="hljs-keyword">instanceof</span> Existence</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p><code>[a, b]? = c</code> =&gt; <code>[a, b] = c if c?</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            if delete (@left.=it)name
            then rite = @right; rite = Assign @right = Var(that), rite
            else [rite, @right, temps] = @right.cache o
            return If(Existence rite; this) &lt;&lt;&lt; {temps, @cond, @void}
        If.unfold-soak o, this, \left

    unfold-assign: -&gt; @access and this

    compile-node: (o) -&gt;
        return @compileSplice o if @left instanceof Slice and @op is \=
        left = @left
        left.=it if sp = @left instanceof Splat
        left.=expand-slice(o, true)unwrap!
        if sp
            left instanceof List or @left.carp 'invalid splat'
            return @compile-spread o, left
        unless @right
            left.is-assignable! or left.carp 'invalid unary assign'
            [left, @right] = Chain left .cache-reference o
            for op in @unaries then @right = Unary op, @right
        return sn(null, (Parens(@right) &lt;&lt;&lt; {@front, @newed})compile o) if left.is-empty!
        if left.get-default!
            @right = Binary left.op, @right, left.second
            left.=first
        return @compileDestructuring o, left if left.items
        left.is-assignable! or left.carp 'invalid assign'
        return @compileConditional   o, left if @logic
        {op, right} = this
        return @compileMinMax  o, left, right if op in &lt;[ &lt;?= &gt;?= ]&gt;
        if op in &lt;[ **= ^= %%= ++= |&gt;= ]&gt;
        or op is \*= and right.is-string!
        or op in &lt;[ -= /= ]&gt; and right.is-matcher!
            [left, reft] = Chain(left)cache-reference o
            right = Binary op.slice(0 -1), reft, right
            op    = \:=
        op = (op.slice 1 -2) + \= if op in &lt;[ .&amp;.= .|.= .^.= .&lt;&lt;.= .&gt;&gt;.= .&gt;&gt;&gt;.= ]&gt;
        (right.=unparen!)rip-name left.=unwrap!
        sign = sn(@opLoc, " ", (op.replace \: ''), " ")
        name = ((left &lt;&lt;&lt; {+front})compile o, LEVEL_LIST)
        if lvar = left instanceof Var
            if op is \=
                o.scope.declare name.to-string!, left,
                    (@const or not @defParam and o.const and \$ isnt name.to-string!.slice -1)
            else if o.scope.checkReadOnly name.to-string!
                left.carp "assignment to #that \"#name\"" ReferenceError
        if left instanceof Chain and right instanceof Fun
            proto-split = name.to-string!.split '.prototype.'
            dot-split = name.to-string!.split \.
            if proto-split.length &gt; 1
                right.in-class = proto-split.0
            else if dot-split.length &gt; 1
                right.in-class-static = dot-split[til -1].join ''
        code = if not o.level and right instanceof While and not right.else and
              (lvar or left instanceof Chain and left.is-simple-access!)</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Optimize <code>a = while ...</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            empty = <span class="hljs-keyword">if</span> right.objComp <span class="hljs-keyword">then</span> <span class="hljs-string">'{}'</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'[]'</span>
            [(res = o.scope.temporary \res), <span class="hljs-string">" = #empty;\n<span class="hljs-subst">#{@tab}</span>"</span>, (right.make-<span class="hljs-keyword">return</span>(res)compile o), <span class="hljs-string">"\n<span class="hljs-subst">#{@tab}</span>"</span>, name, sign, o.scope.free res]
        <span class="hljs-keyword">else</span>
            [name, sign, (right.compile o, LEVEL_LIST)]
        code = [<span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>] <span class="hljs-keyword">if</span> o.level &gt; LEVEL_LIST
        sn(<span class="hljs-literal">null</span>, ...code)

    compileConditional: <span class="hljs-function"><span class="hljs-params">(o, left)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> left <span class="hljs-keyword">instanceof</span> Var <span class="hljs-keyword">and</span> @logic <span class="hljs-keyword">in</span> &lt;[ ? ]&gt; <span class="hljs-keyword">and</span> @op <span class="hljs-keyword">is</span> \=
            o.scope.declare left.value, left
        lefts = Chain(left)cache-reference o</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>Deal with <code>a &amp;&amp; b ||= c</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        o.level += LEVEL_OP &lt; o.level
        morph = Binary @logic, lefts<span class="hljs-number">.0</span>, @&lt;&lt;&lt;{-logic, left: lefts<span class="hljs-number">.1</span>}
        sn(<span class="hljs-keyword">this</span>, (morph &lt;&lt;&lt; {@void})compile-node o)

    compileMinMax: <span class="hljs-function"><span class="hljs-params">(o, left, right)</span> -&gt;</span>
        lefts = Chain(left)cache-reference o
        rites = right.cache o, <span class="hljs-literal">true</span>
        test  = Binary @op.replace(\? <span class="hljs-string">''</span>), lefts<span class="hljs-number">.0</span>, rites<span class="hljs-number">.0</span>
        put   = Assign lefts<span class="hljs-number">.1</span>, rites<span class="hljs-number">.1</span>, \:=</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p><code>a &lt;?= b</code> =&gt; <code>a &lt;= b || a = b</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> Parens(Binary \|| test, put)compile o <span class="hljs-keyword">if</span> @void <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> o.level</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p><code>r = a &lt;?= b</code> =&gt; <code>r = if a &lt;= b then a else a = b</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        [test.first, left] = test.first.cache o, <span class="hljs-literal">true</span>
        sn(<span class="hljs-keyword">this</span>, (If test, left .add-<span class="hljs-keyword">else</span> put .compile-expression o))</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>Implementation of recursive destructuring,
when assigning to an array or object literal.
See <a href="http://wiki.ecmascript.org/doku.php?id=harmony:destructuring">http://wiki.ecmascript.org/doku.php?id=harmony:destructuring</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compileDestructuring: <span class="hljs-function"><span class="hljs-params">(o, {{length: len}:items}:left)</span> -&gt;</span>
        ret  = o.level <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @void
        rite = @right.compile o, <span class="hljs-keyword">if</span> len <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> LEVEL_CALL <span class="hljs-keyword">else</span> LEVEL_LIST
        <span class="hljs-keyword">if</span> left.name
            cache = sn(<span class="hljs-keyword">this</span>, that, <span class="hljs-string">" = "</span>, rite)
            o.scope.declare rite = that, left
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret <span class="hljs-keyword">or</span> len &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> ID.test rite.to-string! <span class="hljs-keyword">or</span> left.assigns rite.to-string!)
            cache = sn(<span class="hljs-keyword">this</span>, (rref = o.scope.temporary!), <span class="hljs-string">" = "</span>, rite)
            rite  = rref
        <span class="hljs-keyword">if</span> rite.to-string! <span class="hljs-keyword">is</span> \arguments <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> ret
            destructure-args = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">if</span> left <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Arr
                @carp <span class="hljs-string">'arguments can only destructure to array'</span>
        list = @<span class="hljs-string">"rend<span class="hljs-subst">#{ left.constructor.display-name }</span>"</span> o, items, rite, destructure-args
        o.scope.free rref  <span class="hljs-keyword">if</span> rref
        list.unshift cache <span class="hljs-keyword">if</span> cache
        list.push rite     <span class="hljs-keyword">if</span> ret <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> list.length
        code = []
        sep = <span class="hljs-keyword">if</span> destructure-args <span class="hljs-keyword">then</span> <span class="hljs-string">'; '</span> <span class="hljs-keyword">else</span> <span class="hljs-string">', '</span>
        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> list
            code.push item, sep
        code.pop!
        <span class="hljs-keyword">if</span> list.length &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> o.level &lt; LEVEL_LIST <span class="hljs-keyword">then</span> sn(<span class="hljs-keyword">this</span>, ...code) <span class="hljs-keyword">else</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>)

    compileSplice: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        [from-exp-node, from-exp] = Chain @left.from .cache-reference o
        [right-node, right]       = Chain @right     .cache-reference o
        to-exp = Binary \- @left.to, from-exp
        sn(<span class="hljs-keyword">this</span>, (Block [Chain Var (util \splice) .add Index (Key \apply), \. <span class="hljs-literal">true</span>
                .add Call [@left.target, (Chain Arr [from-exp-node, to-exp]
                .add Index (Key \concat), \. <span class="hljs-literal">true</span> .add Call [right-node])]; right]
            .compile o, LEVEL_LIST))

    compile-spread: <span class="hljs-function"><span class="hljs-params">(o, left)</span> -&gt;</span>
        [rite, rref] =
            <span class="hljs-keyword">if</span> @unaries <span class="hljs-keyword">then</span> [that] * <span class="hljs-number">2</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> left.items.length &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> [@right] * <span class="hljs-number">2</span>
            <span class="hljs-keyword">else</span> @right.cache o, <span class="hljs-literal">true</span>

        @compile-spread-over o, left, ~&gt;
            result = constructor it, rite, @op, @logic
            rite := rref
            result

    rendArr: <span class="hljs-function"><span class="hljs-params">(o, nodes, rite, destructure-args)</span> -&gt;</span>
        ~function args-slice(begin, end)</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>[&amp;[..] for from (begin) til (end)]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">new</span> For {+ref, from: begin, op: \til, to: end}
                .make-comprehension (Chain Var \arguments .add Index Literal \..), []
        ret = []
        <span class="hljs-keyword">for</span> node, i <span class="hljs-keyword">in</span> nodes
            <span class="hljs-keyword">continue</span> <span class="hljs-keyword">if</span> node.<span class="hljs-keyword">is</span>-empty!
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Splat
                len <span class="hljs-keyword">and</span> node.carp <span class="hljs-string">'multiple splat in an assignment'</span>
                skip = (node.=it).<span class="hljs-keyword">is</span>-empty!
                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span> <span class="hljs-keyword">is</span> len = nodes.length
                    <span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> skip
                    <span class="hljs-keyword">if</span> destructure-args
                        val = args-slice <span class="hljs-keyword">do</span> <span class="hljs-comment"># from i to &amp;length</span>
                            Literal(i)
                            (Chain Var \arguments .add Index Key \length)
                    <span class="hljs-keyword">else</span>
                        val = Arr.wrap JS <span class="hljs-keyword">do</span>
                            util(\slice) + \.call( + rite + <span class="hljs-keyword">if</span> i <span class="hljs-keyword">then</span> <span class="hljs-string">", #i)"</span> <span class="hljs-keyword">else</span> \)
                <span class="hljs-keyword">else</span>
                    val = ivar = <span class="hljs-string">"#rite.length - <span class="hljs-subst">#{ len - i - <span class="hljs-number">1</span> }</span>"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>Optimize <code>[..., a] = b</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">continue</span> <span class="hljs-keyword">if</span> skip <span class="hljs-keyword">and</span> i+<span class="hljs-number">2</span> <span class="hljs-keyword">is</span> len
                    start = i+<span class="hljs-number">1</span>
                    @.[]temps.push ivar = o.scope.temporary \i
                    val = <span class="hljs-keyword">switch</span>
                    | skip
                        Arr.wrap JS <span class="hljs-string">"#i &lt; (#ivar = #val) ? #i : (#ivar = #i)"</span>
                    | destructure-args
                        args-slice <span class="hljs-keyword">do</span>
                            JS <span class="hljs-string">"#i &lt; (#ivar = #val) ? #i : (#ivar = #i)"</span>
                            Var ivar
                    | _
                        Arr.wrap JS <span class="hljs-keyword">do</span>
                            <span class="hljs-string">"#i &lt; (#ivar = #val)
                            \ ? <span class="hljs-subst">#{ util \slice }</span>.call(#rite, #i, #ivar)
                            \ : (#ivar = #i, [])"</span>
            <span class="hljs-keyword">else</span>
                (inc = ivar) <span class="hljs-keyword">and</span> start &lt; i <span class="hljs-keyword">and</span> inc += <span class="hljs-string">" + <span class="hljs-subst">#{ i - start }</span>"</span>
                val = Chain rcache||=Literal(rite), [Index JS inc || i]
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Assign
                node = Binary node.op, node.left, node.right, (node.logic <span class="hljs-keyword">or</span> <span class="hljs-literal">true</span>)
            <span class="hljs-keyword">if</span> destructure-args
                <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Var <span class="hljs-keyword">and</span> val <span class="hljs-keyword">instanceof</span> For</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>avoid accidentally creating closure</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    @.[]temps.push tmp = o.scope.temporary \ref
                    vtmp = Var tmp
                    ret.push (<span class="hljs-keyword">this</span> with {left: vtmp, right: val, +void})compile o, LEVEL_TOP
                    ret.push (<span class="hljs-keyword">this</span> with {left: node, right: vtmp, +void})compile o, LEVEL_TOP
                <span class="hljs-keyword">else</span>
                    ret.push (<span class="hljs-keyword">this</span> with {left: node, right: val, +void})compile o, LEVEL_TOP
            <span class="hljs-keyword">else</span>
                ret.push (<span class="hljs-keyword">this</span> with {left: node, right: val, +void})compile o, LEVEL_PAREN
        ret

    rendObj: <span class="hljs-function"><span class="hljs-params">(o, nodes, rite)</span> -&gt;</span>
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes
            node.=it <span class="hljs-keyword">if</span> splat = node <span class="hljs-keyword">instanceof</span> Splat</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p><code>{a or b} = c</code> =&gt; <code>a = c.a or b</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            node.=first <span class="hljs-keyword">if</span> logic = node.get-default!
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Parens
                [node, key] = Chain(node.it)cache-reference o
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Prop
            <span class="hljs-keyword">then</span> node = ({key} = node)val
            <span class="hljs-keyword">else</span> key  = node
            node = CopyL node, Var node.name <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Key
            node = logic &lt;&lt;&lt; first: node <span class="hljs-keyword">if</span> logic
            val  = Chain rcache||=Var(rite), [Index key.maybe-key!]
            val  = Import Obj!, val <span class="hljs-keyword">if</span> splat
            (<span class="hljs-keyword">this</span> with {left: node, right: val, +void})compile o, LEVEL_PAREN</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <h3 id="import">Import</h3>
<p>Copies properties from right to left.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Import</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@left, @right, @all <span class="hljs-keyword">and</span> \All) ~&gt;
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> all <span class="hljs-keyword">and</span> left <span class="hljs-keyword">instanceof</span> Obj <span class="hljs-keyword">and</span> right.items
            <span class="hljs-keyword">return</span> Obj left.items ++ right.as-obj!items

    children: &lt;[ left right ]&gt;

    show: <span class="hljs-function">-&gt;</span> @all

    ::delegate &lt;[ isCallable isArray ]&gt; -&gt; @left[it]!

    unfold-soak: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        {left} = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">if</span> left <span class="hljs-keyword">instanceof</span> Existence <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> left.negated
            <span class="hljs-keyword">if</span> left.=it <span class="hljs-keyword">instanceof</span> Var
                {value} = @left = left
                <span class="hljs-keyword">unless</span> o.scope.check value, <span class="hljs-literal">true</span>
                    left = JS <span class="hljs-string">"typeof #value != 'undefined' &amp;&amp; #value"</span>
            <span class="hljs-keyword">else</span>
                [left, @left, temps] = left.cache o
            <span class="hljs-keyword">return</span> If(left, <span class="hljs-keyword">this</span>) &lt;&lt;&lt; {temps, +soak, @cond, @void}
        If.unfold-soak o, <span class="hljs-keyword">this</span>, \left
        <span class="hljs-keyword">or</span> (@void <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> o.level) <span class="hljs-keyword">and</span>
        If.unfold-soak o, <span class="hljs-keyword">this</span>, \right

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        {right} = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">unless</span> @all
            <span class="hljs-keyword">if</span> right <span class="hljs-keyword">instanceof</span> Chain
                right = right.unfold-soak o
                     <span class="hljs-keyword">or</span> right.unfold-assign o
                     <span class="hljs-keyword">or</span> right.expand-slice o .unwrap!
            <span class="hljs-keyword">return</span> @compile-assign o, right.as-obj!items <span class="hljs-keyword">if</span> right <span class="hljs-keyword">instanceof</span> List
        (CopyL <span class="hljs-keyword">this</span>, Call.make Util(<span class="hljs-string">"import<span class="hljs-subst">#{ @all <span class="hljs-keyword">or</span> <span class="hljs-string">''</span> }</span>"</span>), [@left, right]) .compile-node o</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>If the right operand of <code>&lt;&lt;&lt;</code> is an object or array literal,
expand it to a series of assignments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    compile-assign: <span class="hljs-function"><span class="hljs-params">(o, items)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> @left.compile o <span class="hljs-keyword">unless</span> items.length
        top = <span class="hljs-keyword">not</span> o.level
        <span class="hljs-keyword">if</span> @proto <span class="hljs-keyword">or</span> (items.length &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> (top <span class="hljs-keyword">or</span> @void <span class="hljs-keyword">or</span> items<span class="hljs-number">.0</span> <span class="hljs-keyword">instanceof</span> Splat))
            reft = @left
            reft = Parens reft <span class="hljs-keyword">if</span> reft.<span class="hljs-keyword">is</span>-complex!
        <span class="hljs-keyword">else</span> [left, reft, @temps] = @left.cache o
        [delim, space] = <span class="hljs-keyword">if</span> top <span class="hljs-keyword">then</span> [\; \\n + @tab] <span class="hljs-keyword">else</span> [\, <span class="hljs-string">' '</span>]
        delim += space
        code = <span class="hljs-keyword">if</span> @temps <span class="hljs-keyword">then</span> [left.compile(o, LEVEL_PAREN), delim] <span class="hljs-keyword">else</span> []
        <span class="hljs-keyword">for</span> node, i <span class="hljs-keyword">in</span> items
            i <span class="hljs-keyword">and</span> code.push <span class="hljs-keyword">if</span> com <span class="hljs-keyword">then</span> space <span class="hljs-keyword">else</span> delim
            <span class="hljs-keyword">if</span> com = node.comment
                code.push node.compile o
                <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Splat
                code.push Import(reft, node.it)compile o
                <span class="hljs-keyword">continue</span>
            node.=first <span class="hljs-keyword">if</span> logic = node.get-default!
            <span class="hljs-keyword">if</span> dyna = node <span class="hljs-keyword">instanceof</span> Parens
                [key, val] = node.it.cache o, <span class="hljs-literal">true</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Prop
                {key, val} = node
                <span class="hljs-keyword">if</span> node.accessor
                    key = JS <span class="hljs-string">"'<span class="hljs-subst">#{key.name}</span>'"</span> <span class="hljs-keyword">if</span> key <span class="hljs-keyword">instanceof</span> Key
                    code.push <span class="hljs-string">"Object.defineProperty("</span>, (reft.compile o, LEVEL_LIST), <span class="hljs-string">", "</span>, (key .compile o, LEVEL_LIST), <span class="hljs-string">", "</span>, (node.compile-descriptor o), <span class="hljs-string">")"</span>
                    <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">else</span> key = val = node
            dyna  <span class="hljs-keyword">or</span>  key.=maybe-key!
            logic <span class="hljs-keyword">and</span> val = logic &lt;&lt;&lt; first: val
            code.push (Assign(Chain reft, [Index key]; val)compile o, LEVEL_PAREN)
        <span class="hljs-keyword">return</span> sn(<span class="hljs-literal">null</span>, ...code) <span class="hljs-keyword">if</span> top
        @void <span class="hljs-keyword">or</span> node <span class="hljs-keyword">instanceof</span> Splat <span class="hljs-keyword">or</span>
            code.push (<span class="hljs-keyword">if</span> com <span class="hljs-keyword">then</span> <span class="hljs-string">' '</span> <span class="hljs-keyword">else</span> <span class="hljs-string">', '</span>), (reft.compile o, LEVEL_PAREN)
        <span class="hljs-keyword">if</span> o.level &lt; LEVEL_LIST <span class="hljs-keyword">then</span> sn(<span class="hljs-literal">null</span>, ...code) <span class="hljs-keyword">else</span> sn(<span class="hljs-literal">null</span>, <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <h3 id="in">In</h3>
<p>Handles <code>in</code> operation that tests if the left operand is included within
the right operand, arraywise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">In</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span> <span class="hljs-title">implements</span> <span class="hljs-title">Negatable</span></span>
    (@item, @array) -&gt;

    children: &lt;[ item array ]&gt;

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        {items} = array = @array.expand-slice(o)unwrap!
        <span class="hljs-keyword">if</span> array <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Arr <span class="hljs-keyword">or</span> items.length &lt; <span class="hljs-number">2</span>
            <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, (<span class="hljs-keyword">if</span> @negated <span class="hljs-keyword">then</span> \! <span class="hljs-keyword">else</span> <span class="hljs-string">''</span>), (util \<span class="hljs-keyword">in</span>), <span class="hljs-string">"("</span>, (@item.compile o, LEVEL_LIST), <span class="hljs-string">", "</span>, (array.compile o, LEVEL_LIST), <span class="hljs-string">")"</span>)
        code = []
        [sub, ref] = @item.cache o, <span class="hljs-literal">false</span>, LEVEL_PAREN
        [cmp, cnj] = <span class="hljs-keyword">if</span> @negated <span class="hljs-keyword">then</span> [<span class="hljs-string">' !== '</span> <span class="hljs-string">' &amp;&amp; '</span>] <span class="hljs-keyword">else</span> [<span class="hljs-string">' === '</span> <span class="hljs-string">' || '</span>]
        <span class="hljs-keyword">for</span> test, i <span class="hljs-keyword">in</span> items
            code.push cnj <span class="hljs-keyword">if</span> code.length &gt; <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> test <span class="hljs-keyword">instanceof</span> Splat
                code.push (<span class="hljs-keyword">new</span> In(Var ref; test.it) &lt;&lt;&lt; {@negated})compile o, LEVEL_TOP
                code  = [<span class="hljs-string">"(#sub, "</span>, ...code, <span class="hljs-string">")"</span>] <span class="hljs-keyword">unless</span> i <span class="hljs-keyword">or</span> sub <span class="hljs-keyword">is</span> ref
            <span class="hljs-keyword">else</span>
                code.push (<span class="hljs-keyword">if</span> i <span class="hljs-keyword">or</span> sub <span class="hljs-keyword">is</span> ref <span class="hljs-keyword">then</span> ref <span class="hljs-keyword">else</span> <span class="hljs-string">"(#sub)"</span>), cmp, (test.compile o, LEVEL_OP + PREC\== )
        sub <span class="hljs-keyword">is</span> ref <span class="hljs-keyword">or</span> o.scope.free ref
        <span class="hljs-keyword">if</span> o.level &lt; LEVEL_OP + PREC\|| <span class="hljs-keyword">then</span> sn(<span class="hljs-keyword">this</span>, ...code) <span class="hljs-keyword">else</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <h3 id="existence">Existence</h3>
<p>Checks a value for existence–not <code>undefined</code> nor <code>null</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Existence</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span> <span class="hljs-title">implements</span> <span class="hljs-title">Negatable</span></span>
    (@it, @negated) ~&gt;

    children: [\it]

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        node = @it.unwrap! &lt;&lt;&lt; {@front}
        code = [(node.compile o, LEVEL_OP + PREC\==)]
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Var <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> o.scope.check code.join(<span class="hljs-string">""</span>), <span class="hljs-literal">true</span>
            [op, eq] = <span class="hljs-keyword">if</span> @negated <span class="hljs-keyword">then</span> &lt;[ || = ]&gt; <span class="hljs-keyword">else</span> &lt;[ &amp;&amp; ! ]&gt;
            <span class="hljs-keyword">if</span> @do-anaphorize
                o.scope.declare <span class="hljs-string">'that'</span> Var \that
                [anaph-pre, anaph-post] = <span class="hljs-keyword">if</span> @negated
                    <span class="hljs-keyword">then</span> [[<span class="hljs-string">"(that = undefined) || "</span>], []]
                    <span class="hljs-keyword">else</span> [[], [<span class="hljs-string">" &amp;&amp; (that = "</span>, ...code, <span class="hljs-string">", true)"</span>]]
            code = [<span class="hljs-string">"typeof "</span>, ...code, <span class="hljs-string">" #eq= 'undefined' #op "</span>, ...code, <span class="hljs-string">" #eq== null"</span>]
            code = that ++ code <span class="hljs-keyword">if</span> anaph-pre?
            code = code ++ that <span class="hljs-keyword">if</span> anaph-post?
        <span class="hljs-keyword">else</span>
            code = [<span class="hljs-string">"(that = "</span>, ...code, <span class="hljs-string">")"</span>] <span class="hljs-keyword">if</span> @do-anaphorize
            code.push <span class="hljs-string">" <span class="hljs-subst">#{ op = <span class="hljs-keyword">if</span> @negated <span class="hljs-keyword">then</span> \== <span class="hljs-keyword">else</span> \!= }</span> null"</span>
        <span class="hljs-keyword">if</span> o.level &lt; LEVEL_OP + PREC[op] <span class="hljs-keyword">then</span> sn(<span class="hljs-keyword">this</span>, ...code) <span class="hljs-keyword">else</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"("</span>, code, <span class="hljs-string">")"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <h3 id="fun">Fun</h3>
<p>A function definition. This is the only node that creates a <code>new Scope</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Fun</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@params <span class="hljs-keyword">or</span> [], @body <span class="hljs-keyword">or</span> Block!, @bound <span class="hljs-keyword">and</span> \<span class="hljs-keyword">this</span>$, @curried <span class="hljs-keyword">or</span> <span class="hljs-literal">false</span>, @hushed = <span class="hljs-literal">false</span>, @generator = <span class="hljs-literal">false</span>) ~&gt;

    children: &lt;[ params body ]&gt;

    show: <span class="hljs-function">-&gt;</span> [@name] + [<span class="hljs-string">"~#that"</span> <span class="hljs-keyword">if</span> @bound]

    named: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">this</span> &lt;&lt;&lt; {name: it, +statement}

    <span class="hljs-keyword">is</span>-callable: YES

    <span class="hljs-keyword">is</span>-statement: <span class="hljs-function">-&gt;</span> !!@statement</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>Short-circuit <code>traverse-children</code> method to prevent it
from crossing scope boundaries by default.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    traverse-children: <span class="hljs-function"><span class="hljs-params">(, xscope)</span> -&gt;</span> <span class="hljs-keyword">super</span> ... <span class="hljs-keyword">if</span> xscope

    make-return: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">if</span> @statement <span class="hljs-keyword">then</span> <span class="hljs-keyword">this</span> &lt;&lt;&lt; {+returns} <span class="hljs-keyword">else</span> <span class="hljs-keyword">super</span> ...

    rip-name: !-&gt; @name ||= it.var-name!

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        pscope = o.scope
        sscope = pscope.shared <span class="hljs-keyword">or</span> pscope
        scope  = o.scope = @body.scope =
            <span class="hljs-keyword">new</span> Scope (<span class="hljs-keyword">if</span> @wrapper <span class="hljs-keyword">then</span> pscope <span class="hljs-keyword">else</span> sscope), @wrapper &amp;&amp; sscope
        scope.fun = <span class="hljs-keyword">this</span>
        scope.assign \prototype <span class="hljs-string">"<span class="hljs-subst">#{ that.compile o }</span>.prototype"</span> <span class="hljs-keyword">if</span> @proto
        scope.assign \constructor that                          <span class="hljs-keyword">if</span> @cname
        o.indent = @tab = <span class="hljs-string">''</span> <span class="hljs-keyword">if</span> inLoop = <span class="hljs-keyword">delete</span> o.<span class="hljs-keyword">loop</span>
        o.indent += TAB
        {body, name, tab} = <span class="hljs-keyword">this</span>
        code = [\function]
        <span class="hljs-keyword">if</span> @generator
            @ctor <span class="hljs-keyword">and</span> @carp <span class="hljs-string">"a constructor can't be a generator"</span>
            o.<span class="hljs-keyword">in</span>-generator = <span class="hljs-literal">true</span>
            code.push \*
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> @wrapper
            o.<span class="hljs-keyword">in</span>-generator = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> @bound <span class="hljs-keyword">is</span> \<span class="hljs-keyword">this</span>$
            <span class="hljs-keyword">if</span> @ctor
                scope.assign \<span class="hljs-keyword">this</span>$ <span class="hljs-string">'this instanceof ctor$ ? this : new ctor$'</span>
                body.lines.push Return Literal \<span class="hljs-keyword">this</span>$
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sscope.fun?bound
            <span class="hljs-keyword">then</span> @bound = that
            <span class="hljs-keyword">else</span> sscope.assign \<span class="hljs-keyword">this</span>$ \<span class="hljs-keyword">this</span>
        <span class="hljs-keyword">if</span> @statement
            name                    <span class="hljs-keyword">or</span> @carp  <span class="hljs-string">'nameless function declaration'</span>
            pscope <span class="hljs-keyword">is</span> o.block.scope <span class="hljs-keyword">or</span> @carp <span class="hljs-string">'misplaced function declaration'</span>
            @accessor              <span class="hljs-keyword">and</span> @carp <span class="hljs-string">'named accessor'</span>
            pscope.add name, \function, <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">if</span> @statement <span class="hljs-keyword">or</span> name <span class="hljs-keyword">and</span> @labeled
            code.push <span class="hljs-string">' '</span>, (scope.add name, \function, <span class="hljs-keyword">this</span>)
        @hushed <span class="hljs-keyword">or</span> @ctor <span class="hljs-keyword">or</span> @newed <span class="hljs-keyword">or</span> body.make-<span class="hljs-keyword">return</span>!
        code.push <span class="hljs-string">"("</span>, (@compile-params o, scope), <span class="hljs-string">")"</span>
        code = [sn(<span class="hljs-keyword">this</span>, ...code)]
        code.push <span class="hljs-string">"{"</span>
        code.push <span class="hljs-string">"\n"</span>, bodyCode, <span class="hljs-string">"\n#tab"</span> <span class="hljs-keyword">unless</span> sn-empty(bodyCode = body.compile-with-declarations o)
        code.push \}
        curry-code-check = ~&gt;
            <span class="hljs-keyword">if</span> @curried <span class="hljs-keyword">and</span> @has-splats
                    @carp <span class="hljs-string">'cannot curry a function with a variable number of arguments'</span>
            <span class="hljs-keyword">if</span> @curried <span class="hljs-keyword">and</span> @params.length &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @class-bound
                <span class="hljs-keyword">if</span> @bound
                    [(util \curry), <span class="hljs-string">"(("</span>, ...code, <span class="hljs-string">"), true)"</span>]
                <span class="hljs-keyword">else</span>
                    [(util \curry), <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>]
            <span class="hljs-keyword">else</span> code
        <span class="hljs-keyword">if</span> inLoop <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> pscope.assign pscope.temporary(\fn), sn(<span class="hljs-literal">null</span>, ...curry-code-check!)
        <span class="hljs-keyword">if</span> @returns
            code.push <span class="hljs-string">"\n<span class="hljs-subst">#{tab}</span>return "</span>, name, <span class="hljs-string">";"</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> @bound <span class="hljs-keyword">and</span> @ctor
            code.push <span class="hljs-string">' function ctor$(){} ctor$.prototype = prototype;'</span>
        code = curry-code-check!
        <span class="hljs-keyword">if</span> @front <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @statement <span class="hljs-keyword">then</span> sn(<span class="hljs-literal">null</span>, <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>) <span class="hljs-keyword">else</span> sn(<span class="hljs-literal">null</span>, ...code)

    compile-params: <span class="hljs-function"><span class="hljs-params">(o, scope)</span> -&gt;</span>
        {{length}:params, body} = <span class="hljs-keyword">this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>Remove trailing placeholders.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> params <span class="hljs-keyword">by</span> <span class="hljs-number">-1</span>
            <span class="hljs-keyword">break</span> <span class="hljs-keyword">unless</span> p.<span class="hljs-keyword">is</span>-empty! <span class="hljs-keyword">or</span> p.filler
            --params.length
        <span class="hljs-keyword">for</span> p, i <span class="hljs-keyword">in</span> params
            <span class="hljs-keyword">if</span> p.left <span class="hljs-keyword">instanceof</span> Splat</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>splats + default/operator arguments = too ambiguous to support</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                p.carp <span class="hljs-string">'invalid splat'</span>
            <span class="hljs-keyword">if</span> p <span class="hljs-keyword">instanceof</span> Splat
                @has-splats = <span class="hljs-literal">true</span>
                splace = i</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p><code>(a = x) -&gt;</code> =&gt; <code>(a ? x) -&gt;</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p.op <span class="hljs-keyword">is</span> \=
                params[i] = Binary (p.logic <span class="hljs-keyword">or</span> \?), p.left, p.right</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p><code>(a, ...b, c) -&gt;</code> =&gt; <code>(a) -&gt; [[] ...b, c] = &amp;</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> splace?
            rest = params.splice splace, <span class="hljs-number">9e9</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> @accessor
            that.carp <span class="hljs-string">'excess accessor parameter'</span> <span class="hljs-keyword">if</span> params<span class="hljs-number">.1</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">unless</span> length <span class="hljs-keyword">or</span> @wrapper
            params<span class="hljs-number">.0</span> = Var \it <span class="hljs-keyword">if</span> body.traverse-children -&gt; it.value <span class="hljs-keyword">is</span> \it <span class="hljs-keyword">or</span> <span class="hljs-literal">null</span>
        names   = []
        assigns = []
        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> params
            vr = p
            vr.=first <span class="hljs-keyword">if</span> df = vr.get-default!
            <span class="hljs-keyword">if</span> vr.<span class="hljs-keyword">is</span>-empty!
                vr = Var scope.temporary \arg
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> vr.value <span class="hljs-keyword">is</span> \..
                vr = Var o.ref = scope.temporary!
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> vr <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Var
                unaries = []
                <span class="hljs-keyword">while</span> vr <span class="hljs-keyword">instanceof</span> Unary
                    has-unary = <span class="hljs-literal">true</span>
                    unaries.push vr
                    vr.=it
                v = Var <span class="hljs-keyword">delete</span> (vr.it || vr)name || vr.var-name! || scope.temporary \arg
                assigns.push Assign vr, <span class="hljs-keyword">switch</span>
                    | df        =&gt; Binary p.op, v, p.second
                    | has-unary =&gt; fold (<span class="hljs-function"><span class="hljs-params">(x, y)</span> -&gt;</span> y.it = x; y), v, unaries.reverse!
                    | otherwise =&gt; v
                vr = v
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> df
                assigns.push Assign vr, p.second, \=, p.op, <span class="hljs-literal">true</span>
            names.push (scope.add vr.value, \arg, p), <span class="hljs-string">', '</span>
        <span class="hljs-keyword">if</span> rest
            <span class="hljs-keyword">while</span> splace-- <span class="hljs-keyword">then</span> rest.unshift Arr!
            assigns.push Assign Arr(rest), Literal \arguments
        @body.prepend ...assigns <span class="hljs-keyword">if</span> assigns.length
        names.pop!
        sn(<span class="hljs-literal">null</span>, ...names)</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <h3 id="class">Class</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    ({@title, @sup, @mixins, body}) -&gt; @fun = Fun [] body

    children: &lt;[ title sup mixins fun ]&gt;

    <span class="hljs-keyword">is</span>-callable: YES

    rip-name: !-&gt; @name = it.var-name!

    compile: <span class="hljs-function"><span class="hljs-params">(o, level)</span> -&gt;</span>
        {{{lines}:body}:fun, title} = <span class="hljs-keyword">this</span>
        CopyL <span class="hljs-keyword">this</span>, fun

        bound-funcs = []
        curried-bound-funcs = []
        decl = title?var-name!
        name = decl <span class="hljs-keyword">or</span> @name
        <span class="hljs-keyword">if</span> ID.test name || <span class="hljs-string">''</span> <span class="hljs-keyword">then</span> fun.cname = name <span class="hljs-keyword">else</span> name = \constructor
        proto = Var \prototype
        vname = fun.proto = Var fun.bound = name
        const ctor-name = \constructor$$
        var ctor, ctor-place
        import-proto-obj = <span class="hljs-function"><span class="hljs-params">(node, i)</span> -&gt;</span>
            j = <span class="hljs-number">0</span>
            <span class="hljs-keyword">while</span> j &lt; node.items.length, j++
                prop = node.items[j]
                key = prop.key
                <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">instanceof</span> Key <span class="hljs-keyword">and</span> key.name <span class="hljs-keyword">is</span> ctor-name)
                <span class="hljs-keyword">or</span> (key <span class="hljs-keyword">instanceof</span> Literal <span class="hljs-keyword">and</span> key.value <span class="hljs-keyword">is</span> <span class="hljs-string">"'#ctor-name'"</span>)
                    node.carp <span class="hljs-string">'redundant constructor'</span> <span class="hljs-keyword">if</span> ctor
                    ctor := prop.val
                    node.items.splice j--, <span class="hljs-number">1</span>
                    ctor-place := i
                <span class="hljs-keyword">continue</span> <span class="hljs-keyword">unless</span> prop.val <span class="hljs-keyword">instanceof</span> Fun <span class="hljs-keyword">or</span> prop.accessor
                <span class="hljs-keyword">if</span> key.<span class="hljs-keyword">is</span>-complex!
                    key = Var o.scope.temporary \key
                    prop.key = Assign key, prop.key
                <span class="hljs-keyword">if</span> prop.val.bound
                    <span class="hljs-keyword">if</span> prop.val.curried
                        curried-bound-funcs.push prop.key
                    <span class="hljs-keyword">else</span>
                        bound-funcs.push prop.key
                    prop.val.bound = <span class="hljs-literal">false</span></pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>need to know whether bound param of curry$ should be true</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    prop.val.class-bound = <span class="hljs-literal">true</span>
                <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> [] ++ prop.val
                    v.meth = key
            <span class="hljs-keyword">if</span> node.items.length
              Import(Chain vname .add Index Key \prototype; node) &lt;&lt;&lt; {+proto}
            <span class="hljs-keyword">else</span> Literal <span class="hljs-string">'void'</span>

        <span class="hljs-keyword">for</span> node, i <span class="hljs-keyword">in</span> lines
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Obj
                lines[i] = import-proto-obj node, i
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Fun <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.statement
                ctor <span class="hljs-keyword">and</span> node.carp <span class="hljs-string">'redundant constructor'</span>
                ctor = node
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Assign <span class="hljs-keyword">and</span> node.left <span class="hljs-keyword">instanceof</span> Chain
            <span class="hljs-keyword">and</span> node.left.head.value <span class="hljs-keyword">is</span> \<span class="hljs-keyword">this</span> <span class="hljs-keyword">and</span> node.right <span class="hljs-keyword">instanceof</span> Fun
                node.right.stat = node.left.tails<span class="hljs-number">.0</span>.key
            <span class="hljs-keyword">else</span>
                node.traverse-children !-&gt;
                    <span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Block
                        <span class="hljs-keyword">for</span> child, k <span class="hljs-keyword">in</span> it.lines <span class="hljs-keyword">when</span> child <span class="hljs-keyword">instanceof</span> Obj
                            it.lines[k] = import-proto-obj child, i

        ctor ||= lines.* = <span class="hljs-keyword">if</span> @sup
                    <span class="hljs-keyword">then</span>  Fun [] Block Chain(<span class="hljs-keyword">new</span> Super).add Call [Splat Literal \arguments]
                    <span class="hljs-keyword">else</span> Fun!
        <span class="hljs-keyword">unless</span> ctor <span class="hljs-keyword">instanceof</span> Fun
            lines.splice ctor-place + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, Assign (Var ctor-name), ctor
            lines.unshift ctor = Fun [] Block Return Chain(Var ctor-name).add Call [Splat \arguments <span class="hljs-literal">true</span>]
        ctor &lt;&lt;&lt; {name, +ctor, +statement}
        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> bound-funcs
            ctor.body.lines.unshift <span class="hljs-keyword">do</span>
                Assign (Chain Literal \<span class="hljs-keyword">this</span> .add Index f),
                       (Chain Var (util \bind)
                         .add Call [Literal \<span class="hljs-keyword">this</span>; Literal <span class="hljs-string">"'<span class="hljs-subst">#{f.name}</span>'"</span>; Var \prototype])

        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> curried-bound-funcs
            ctor.body.lines.unshift <span class="hljs-keyword">do</span>
                Assign (Chain Literal \<span class="hljs-keyword">this</span> .add Index Key <span class="hljs-string">"_<span class="hljs-subst">#{f.name}</span>"</span>),
                       (Chain Var (util \curry)
                         .add Call [Chain Var \prototype .add Index f; Var \<span class="hljs-literal">true</span>])
                Assign (Chain Literal \<span class="hljs-keyword">this</span> .add Index f),
                       (Chain Var (util \bind)
                         .add Call [Literal \<span class="hljs-keyword">this</span>; Literal <span class="hljs-string">"'_<span class="hljs-subst">#{f.name}</span>'"</span>])


        lines.push vname
        args = []
        <span class="hljs-keyword">if</span> @sup
            args.push that
            imports = Chain Import (Literal \<span class="hljs-keyword">this</span>), Var \superclass
            fun.proto = Util.Extends (<span class="hljs-keyword">if</span> fun.cname
                <span class="hljs-keyword">then</span> Block [Assign (imports.add Index Key <span class="hljs-string">'displayName'</span>), Literal <span class="hljs-string">"'#name'"</span>
                   ; Literal name]
                <span class="hljs-keyword">else</span> imports)
                , fun.params.* = Var \superclass
        <span class="hljs-keyword">if</span> @mixins
            imports = <span class="hljs-keyword">for</span> args.* <span class="hljs-keyword">in</span> that
                Import proto, JS(<span class="hljs-string">"arguments[<span class="hljs-subst">#{args.length<span class="hljs-number">-1</span>}</span>]"</span>), <span class="hljs-literal">true</span>
            body.prepend ...imports
        body.prepend Literal <span class="hljs-string">"#name.displayName = '#name'"</span> <span class="hljs-keyword">if</span> fun.cname <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @sup
        clas = Parens Call.make(fun, args), <span class="hljs-literal">true</span>
        clas = Assign vname, clas <span class="hljs-keyword">if</span> decl <span class="hljs-keyword">and</span> title.<span class="hljs-keyword">is</span>-complex!
        clas = Assign title, clas <span class="hljs-keyword">if</span> title
        sn(<span class="hljs-literal">null</span>, (clas.compile o, level))</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <h3 id="super">Super</h3>
<p>Reference to the parent method or constructor.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Super</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    -&gt;

    <span class="hljs-keyword">is</span>-callable: YES

    compile: <span class="hljs-function"><span class="hljs-params">({scope}:o)</span> -&gt;</span>
        <span class="hljs-keyword">unless</span> @sproto
            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> scope.get \superclass <span class="hljs-keyword">and</span> scope.fun, scope.=parent
                result = that
                <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, \superclass.prototype, (Index that .compile o)) <span class="hljs-keyword">if</span> result.meth
                <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, \superclass          , (Index that .compile o)) <span class="hljs-keyword">if</span> result.stat
                <span class="hljs-keyword">if</span> scope.fun.<span class="hljs-keyword">in</span>-<span class="hljs-class"><span class="hljs-keyword">class</span></span>
                    <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, that, <span class="hljs-string">".superclass.prototype."</span>, scope.fun.name)
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> scope.fun.<span class="hljs-keyword">in</span>-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">static</span></span>
                    <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, that, <span class="hljs-string">".superclass."</span>, scope.fun.name)
            <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, that, <span class="hljs-string">".superclass"</span>) <span class="hljs-keyword">if</span> o.scope.fun?name
        sn(<span class="hljs-keyword">this</span>, \superclass)</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <h3 id="parens">Parens</h3>
<p>An extra set of parentheses,
specifying evaluation order and/or forcing expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Parens</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@it, @keep, @string, @lb, @rb) ~&gt;

    children: [\it]

    show: <span class="hljs-function">-&gt;</span> @string <span class="hljs-keyword">and</span> <span class="hljs-string">'""'</span>

    ::delegate &lt;[ isComplex isCallable isArray isRegex ]&gt; -&gt; @it[it]!

    <span class="hljs-keyword">is</span>-string: <span class="hljs-function">-&gt;</span> @string <span class="hljs-keyword">or</span> @it.<span class="hljs-keyword">is</span>-string!

    unparen: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">if</span> @keep <span class="hljs-keyword">then</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> @it.unparen!

    compile: <span class="hljs-function"><span class="hljs-params">(o, level ? o.level)</span> -&gt;</span>
        {it} = <span class="hljs-keyword">this</span>
        it{cond, \void} ||= <span class="hljs-keyword">this</span>
        it.head.hushed = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> @calling <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> level <span class="hljs-keyword">or</span> @void)
        <span class="hljs-keyword">unless</span> @keep <span class="hljs-keyword">or</span> @newed <span class="hljs-keyword">or</span> level &gt;= LEVEL_OP + PREC[it.op]
            <span class="hljs-keyword">return</span> ((it &lt;&lt;&lt; {@front})compile o, level || LEVEL_PAREN)
        <span class="hljs-keyword">if</span> it.<span class="hljs-keyword">is</span>-statement!
        <span class="hljs-keyword">then</span> it.compile-closure o
        <span class="hljs-keyword">else</span> sn(<span class="hljs-literal">null</span>, sn(@lb, <span class="hljs-string">"("</span>), (it.compile o, LEVEL_PAREN), sn(@rb, <span class="hljs-string">")"</span>))</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <h3 id="splat">Splat</h3>
<p>A splat, either as an argument to a call,
the operand of a unary operator to be spread,
or as part of a destructuring assignment.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Splat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@it, @filler) ~&gt;

    ::{children, <span class="hljs-keyword">is</span>-complex} = Parens::

    <span class="hljs-keyword">is</span>-assignable: YES

    assigns: <span class="hljs-function">-&gt;</span> @it.assigns it

    compile: <span class="hljs-function">-&gt;</span> @carp <span class="hljs-string">'invalid splat'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Compiles a list of nodes mixed with splats to a proper array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    @compile-array = <span class="hljs-function"><span class="hljs-params">(o, list, apply)</span> -&gt;</span>
        expand list
        index = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> list
            <span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Splat
            ++index
        <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">''</span>) <span class="hljs-keyword">if</span> index &gt;= list.length
        <span class="hljs-keyword">unless</span> list<span class="hljs-number">.1</span>
            <span class="hljs-keyword">return</span> sn(<span class="hljs-keyword">this</span>, ((<span class="hljs-keyword">if</span> apply <span class="hljs-keyword">then</span> Object <span class="hljs-keyword">else</span> ensure-array) list<span class="hljs-number">.0</span>.it
             .compile o, LEVEL_LIST))
        args = []
        atoms = []
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> list.splice index, <span class="hljs-number">9e9</span>
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Splat
                args.push Arr atoms.splice <span class="hljs-number">0</span>, <span class="hljs-number">9e9</span> <span class="hljs-keyword">if</span> atoms.length
                args.push ensure-array node.it
            <span class="hljs-keyword">else</span> atoms.push node
        args.push Arr atoms <span class="hljs-keyword">if</span> atoms.length
        sn(<span class="hljs-literal">null</span>, (<span class="hljs-keyword">if</span> index <span class="hljs-keyword">then</span> Arr list <span class="hljs-keyword">else</span> args.shift!)compile(o, LEVEL_CALL), sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">".concat("</span>), (List.compile o, args), sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">")"</span>))

    function expand nodes
        index = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">while</span> node = nodes[++index] <span class="hljs-keyword">then</span> <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Splat
            {it} = node
            <span class="hljs-keyword">if</span> it.<span class="hljs-keyword">is</span>-empty!
                nodes.splice index-- <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Arr
                nodes.splice index, <span class="hljs-number">1</span>, ...expand it.items
                index += it.items.length - <span class="hljs-number">1</span>
        nodes

    function ensure-array node
        <span class="hljs-keyword">return</span> node <span class="hljs-keyword">if</span> node.<span class="hljs-keyword">is</span>-array!
        Call.make JS(util(\slice) + \.call), [node]</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <h3 id="jump">Jump</h3>
<p><code>break</code> <code>continue</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Jump</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@verb, @label) -&gt;

    show: <span class="hljs-function">-&gt;</span> (@verb <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>) + <span class="hljs-keyword">if</span> @label <span class="hljs-keyword">then</span> <span class="hljs-string">' '</span> + that <span class="hljs-keyword">else</span> <span class="hljs-string">''</span>

    <span class="hljs-keyword">is</span>-statement : YES
    make-<span class="hljs-keyword">return</span>  : THIS

    get-jump: <span class="hljs-function"><span class="hljs-params">(ctx <span class="hljs-keyword">or</span> {})</span> -&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">unless</span> ctx[@verb]
        <span class="hljs-keyword">return</span> that <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (ctx.labels ?= []) <span class="hljs-keyword">and</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">if</span> @label

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> @label
        <span class="hljs-keyword">then</span> that <span class="hljs-keyword">in</span> (o.labels ?= []) <span class="hljs-keyword">or</span> @carp <span class="hljs-string">"unknown label \"#that\""</span>
        <span class="hljs-keyword">else</span> o[@verb]          <span class="hljs-keyword">or</span> @carp <span class="hljs-string">"stray <span class="hljs-subst">#{@verb}</span>"</span>
        sn(<span class="hljs-keyword">this</span>, @show! + \;)

    @extended = !(sub) -&gt;
        sub::children = [\it]
        @[sub.display-name.toLowerCase!] = sub</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <h3 id="throw">Throw</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Throw</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Jump</span></span>
    (@it) ~&gt;

    get-jump: VOID

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span> sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"throw "</span>, (@it?compile o, LEVEL_PAREN <span class="hljs-keyword">or</span> \<span class="hljs-literal">null</span>), <span class="hljs-string">";"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <h3 id="return">Return</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Return</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Jump</span></span>
    ~&gt; <span class="hljs-keyword">if</span> it <span class="hljs-keyword">and</span> it.value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> \void <span class="hljs-keyword">then</span> <span class="hljs-keyword">this</span> &lt;&lt;&lt; {it}

    get-jump: THIS

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"return"</span>, ...(<span class="hljs-keyword">if</span> @it <span class="hljs-keyword">then</span> [<span class="hljs-string">' '</span>, (that.compile o, LEVEL_PAREN)] <span class="hljs-keyword">else</span> []), <span class="hljs-string">";"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <h3 id="while">While</h3>
<p>The traditional <code>while</code>/<code>for</code>/<code>do</code> loop.
Returns an array of values collected from the last expression when requested.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">While</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (test, @un, mode) -&gt;
        mode <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span> mode <span class="hljs-keyword">instanceof</span> Node <span class="hljs-keyword">then</span> @update = mode <span class="hljs-keyword">else</span> @post = <span class="hljs-literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p><code>while true</code> <code>until false</code> =&gt; <code>for (;;)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> @post <span class="hljs-keyword">or</span> test.value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-string">''</span>+!un <span class="hljs-keyword">then</span> <span class="hljs-keyword">this</span> &lt;&lt;&lt; {test}

    children: &lt;[ test body update <span class="hljs-keyword">else</span> ]&gt;

    a-source: \test, aTargets: &lt;[ body update ]&gt;

    show: <span class="hljs-function">-&gt;</span> [\! <span class="hljs-keyword">if</span> @un; \<span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> @post] * <span class="hljs-string">''</span>

    ::<span class="hljs-keyword">is</span>-statement = ::<span class="hljs-keyword">is</span>-array = YES

    make-comprehension: <span class="hljs-function"><span class="hljs-params">(toAdd, loops)</span> -&gt;</span>
        @is-comprehension = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">while</span> loops.length
            toAdd = loops.pop!add-body Block toAdd
            toAdd &lt;&lt;&lt; {+<span class="hljs-keyword">in</span>-comprehension} <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> toAdd.<span class="hljs-keyword">is</span>-comprehension
        @add-body Block toAdd

    get-jump: <span class="hljs-function"><span class="hljs-params">(ctx <span class="hljs-keyword">or</span> {})</span> -&gt;</span>
        ctx &lt;&lt;&lt; {+\<span class="hljs-keyword">continue</span>, +\<span class="hljs-keyword">break</span>}
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> @body?.lines <span class="hljs-keyword">or</span> [] <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> node <span class="hljs-keyword">if</span> node.get-jump ctx

    add-body: <span class="hljs-function"><span class="hljs-params">(@body)</span> -&gt;</span>
        @body = Block If @guard, @body <span class="hljs-keyword">if</span> @guard
        [top] = @body.lines
        @body.lines.length = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> top?verb <span class="hljs-keyword">is</span> \<span class="hljs-keyword">continue</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> top.label
        <span class="hljs-keyword">this</span>

    add-guard: <span class="hljs-function"><span class="hljs-params">(@guard)</span> -&gt;</span> <span class="hljs-keyword">this</span>
    add-obj-comp: <span class="hljs-function"><span class="hljs-params">(@objComp = <span class="hljs-literal">true</span>)</span> -&gt;</span> <span class="hljs-keyword">this</span>

    make-return: <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">if</span> @has-returned
        <span class="hljs-keyword">if</span> it
            <span class="hljs-keyword">if</span> @objComp
                @body = Block @body.make-<span class="hljs-keyword">return</span> it, <span class="hljs-literal">true</span>
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">unless</span> @body <span class="hljs-keyword">or</span> @index
                    @add-body Block Var @index = \ridx$
                last = @body.lines?[*<span class="hljs-number">-1</span>]
                <span class="hljs-keyword">if</span> (@is-comprehension <span class="hljs-keyword">or</span> @in-comprehension) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> last?<span class="hljs-keyword">is</span>-comprehension
                    @body.make-<span class="hljs-keyword">return</span> ...&amp;
                    @else?make-<span class="hljs-keyword">return</span> ...&amp;
                    @has-returned = <span class="hljs-literal">true</span>
                <span class="hljs-keyword">else</span>
                    @res-var = it
                    @else?make-<span class="hljs-keyword">return</span> ...&amp;
        <span class="hljs-keyword">else</span>
            @get-jump! <span class="hljs-keyword">or</span> @returns = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">this</span>

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        o.<span class="hljs-keyword">loop</span> = <span class="hljs-literal">true</span>
        @test <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span> @un <span class="hljs-keyword">then</span> @test.=invert! <span class="hljs-keyword">else</span> @anaphorize!
        <span class="hljs-keyword">return</span> sn(<span class="hljs-literal">null</span>, sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">'do {'</span>), @compile-body (o.indent += TAB; o)) <span class="hljs-keyword">if</span> @post
        test = @test?compile o, LEVEL_PAREN <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>
        <span class="hljs-keyword">unless</span> @update <span class="hljs-keyword">or</span> @else
            head = <span class="hljs-keyword">unless</span> sn-empty(test) <span class="hljs-keyword">then</span> [sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"while ("</span>), test] <span class="hljs-keyword">else</span> [sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">'for (;;'</span>)]
        <span class="hljs-keyword">else</span>
            head = [sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">'for ('</span>)]
            head.push (@yet = o.scope.temporary \yet), <span class="hljs-string">" = true"</span> <span class="hljs-keyword">if</span> @else
            head.push sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">";"</span>), (test.to-string! <span class="hljs-keyword">and</span> <span class="hljs-string">' '</span>), test, sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">";"</span>)
            head.push <span class="hljs-string">' '</span>, (that.compile o, LEVEL_PAREN) <span class="hljs-keyword">if</span> @update
        sn(<span class="hljs-literal">null</span>, ...head, sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">') {'</span>), (@compile-body (o.indent += TAB; o)))

    compile-body: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        o.<span class="hljs-keyword">break</span> = o.<span class="hljs-keyword">continue</span> = <span class="hljs-literal">true</span>
        {body: {lines}, yet, tab} = <span class="hljs-keyword">this</span>
        code = []
        ret = []
        mid = []
        empty = <span class="hljs-keyword">if</span> @objComp <span class="hljs-keyword">then</span> <span class="hljs-string">'{}'</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'[]'</span>
        var _result-name
        get-result-name = ~&gt;
                _result-name ? _result-name := o.scope.temporary <span class="hljs-keyword">if</span> @objComp
                                                         <span class="hljs-keyword">then</span> <span class="hljs-string">'resultObj'</span>
                                                         <span class="hljs-keyword">else</span> <span class="hljs-string">'results'</span>
        last = lines?[*<span class="hljs-number">-1</span>]
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (@is-comprehension <span class="hljs-keyword">or</span> @in-comprehension) <span class="hljs-keyword">or</span> last?<span class="hljs-keyword">is</span>-comprehension
            has-<span class="hljs-keyword">loop</span> = <span class="hljs-literal">false</span>
            last?traverse-children !-&gt; <span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Block <span class="hljs-keyword">and</span> it.lines[*<span class="hljs-number">-1</span>] <span class="hljs-keyword">instanceof</span> While
                has-<span class="hljs-keyword">loop</span> := <span class="hljs-literal">true</span>
            <span class="hljs-keyword">if</span> @returns <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @res-var
                @res-var = res = o.scope.assign get-result-name!, empty
            <span class="hljs-keyword">if</span> @res-var <span class="hljs-keyword">and</span> (last <span class="hljs-keyword">instanceof</span> While <span class="hljs-keyword">or</span> has-<span class="hljs-keyword">loop</span>)
                temp = o.scope.temporary \lresult
                lines.unshift Assign (Var temp), (<span class="hljs-keyword">if</span> lines[*<span class="hljs-number">-1</span>].objComp <span class="hljs-keyword">then</span> Obj! <span class="hljs-keyword">else</span> Arr!), \=
                lines[*<span class="hljs-number">-1</span>]?=make-<span class="hljs-keyword">return</span> temp
                mid.push TAB, (Chain Var @res-var
                    .add Index (Key \push), \., <span class="hljs-literal">true</span>
                    .add Call [Chain Var temp] .compile o), <span class="hljs-string">";\n<span class="hljs-subst">#{@tab}</span>"</span>
            <span class="hljs-keyword">else</span>
                @has-returned = <span class="hljs-literal">true</span>
                <span class="hljs-keyword">if</span> @res-var
                    @body.make-<span class="hljs-keyword">return</span> @res-var
        <span class="hljs-keyword">if</span> @returns
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> last <span class="hljs-keyword">instanceof</span> While <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @has-returned) <span class="hljs-keyword">or</span> @is-comprehension <span class="hljs-keyword">or</span> @in-comprehension
                lines[*<span class="hljs-number">-1</span>]?=make-<span class="hljs-keyword">return</span> (res = o.scope.assign get-result-name!, empty), @objComp
            ret.push <span class="hljs-string">"\n<span class="hljs-subst">#{@tab}</span>return "</span>, (res <span class="hljs-keyword">or</span> empty), <span class="hljs-string">";"</span>
            @else?make-<span class="hljs-keyword">return</span>!
        yet <span class="hljs-keyword">and</span> lines.unshift JS <span class="hljs-string">"#yet = false;"</span>
        code.push <span class="hljs-string">"\n"</span>, bodyCode, <span class="hljs-string">"\n#tab"</span> <span class="hljs-keyword">unless</span> sn-empty(bodyCode = @body.compile o, LEVEL_TOP)
        code.push ...mid
        code.push \}
        code.push sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">" while ("</span>), (@test.compile o&lt;&lt;&lt;{tab} LEVEL_PAREN), sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">");"</span>) <span class="hljs-keyword">if</span> @post
        <span class="hljs-keyword">if</span> yet
            code.push sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">" if ("</span>), yet, sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">") "</span>), (@compile-block o, Block @else)
            o.scope.free yet
        sn(<span class="hljs-literal">null</span>, ...code, ...ret)</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <h3 id="for">For</h3>
<p>LiveScript’s replacements for the <code>for</code> loop are array, object or range iterators.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">For</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">While</span></span>
    -&gt;
        <span class="hljs-keyword">this</span> &lt;&lt;&lt;&lt; it
        @item = <span class="hljs-literal">null</span> <span class="hljs-keyword">if</span> @item <span class="hljs-keyword">instanceof</span> Var <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @item.value
        <span class="hljs-keyword">for</span> @kind <span class="hljs-keyword">or</span> [] =&gt; @[..] = <span class="hljs-literal">true</span>
        @carp <span class="hljs-string">'`for own` requires `of`'</span> <span class="hljs-keyword">if</span> @own <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @object

    children: &lt;[ item source from to step body ]&gt;

    a-source: <span class="hljs-literal">null</span>

    show: <span class="hljs-function">-&gt;</span> ((@kind || []) ++ @index).join <span class="hljs-string">' '</span>

    add-body: <span class="hljs-function"><span class="hljs-params">(body)</span> -&gt;</span>
        has-yield = !!body.traverse-children (child) -&gt;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> child <span class="hljs-keyword">instanceof</span> Yield
        <span class="hljs-keyword">if</span> @let
            @item = Literal \.. <span class="hljs-keyword">if</span> <span class="hljs-keyword">delete</span> @ref
            body = Block Call.let <span class="hljs-keyword">do</span>
                with []
                    ..push Assign Var(that), Literal \index$$ <span class="hljs-keyword">if</span> @index
                    ..push Assign that,      Literal \item$$ <span class="hljs-keyword">if</span> @item
                body
                has-yield

        <span class="hljs-keyword">super</span> body

        <span class="hljs-keyword">if</span> @guard <span class="hljs-keyword">and</span> @let <span class="hljs-keyword">and</span> (@index <span class="hljs-keyword">or</span> @item)
            @body.lines[<span class="hljs-number">0</span>].<span class="hljs-keyword">if</span>.traverse-children !~&gt;
                <span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Var
                    <span class="hljs-keyword">if</span> @index <span class="hljs-keyword">and</span> it.value <span class="hljs-keyword">is</span> @index
                        it.value = \index$$
                    <span class="hljs-keyword">if</span> @item <span class="hljs-keyword">and</span> it.value <span class="hljs-keyword">is</span> @item.value
                        it.value = \item$$
        <span class="hljs-keyword">if</span> @let
            @body := Block Yield \yieldfrom, body <span class="hljs-keyword">if</span> has-yield
            <span class="hljs-keyword">delete</span> @index
            <span class="hljs-keyword">delete</span> @item
        <span class="hljs-keyword">this</span>

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        o.<span class="hljs-keyword">loop</span> = <span class="hljs-literal">true</span>
        temps = @temps = []
        <span class="hljs-keyword">if</span> @object <span class="hljs-keyword">and</span> @index
        <span class="hljs-keyword">then</span> o.scope.declare idx = @index
        <span class="hljs-keyword">else</span> temps.push idx = o.scope.temporary \i
        @add-body Block Var idx <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> @body
        <span class="hljs-keyword">unless</span> @object
            [pvar, step] = (@step <span class="hljs-keyword">or</span> Literal <span class="hljs-number">1</span>)compile-<span class="hljs-keyword">loop</span>-reference o, \step
            pvar <span class="hljs-keyword">is</span> step <span class="hljs-keyword">or</span> temps.push pvar
        <span class="hljs-keyword">if</span> @from
            @item = Var idx <span class="hljs-keyword">if</span> @ref
            [tvar, tail] = @to.compile-<span class="hljs-keyword">loop</span>-reference o, \to
            fvar = @from.compile o, LEVEL_LIST
            vars = <span class="hljs-string">"#idx = #fvar"</span>
            <span class="hljs-keyword">unless</span> tail <span class="hljs-keyword">is</span> tvar
                vars += <span class="hljs-string">", #tail"</span>
                temps.push tvar
            pvar = step = <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> @step <span class="hljs-keyword">and</span> +fvar &gt; +tvar
            eq   = <span class="hljs-keyword">if</span> @op <span class="hljs-keyword">is</span> \til <span class="hljs-keyword">then</span> <span class="hljs-string">''</span> <span class="hljs-keyword">else</span> \=
            cond = <span class="hljs-keyword">if</span> +pvar
                <span class="hljs-keyword">then</span> <span class="hljs-string">"#idx <span class="hljs-subst">#{ <span class="hljs-string">'&lt;&gt;'</span>char-at pvar &lt; <span class="hljs-number">0</span> }</span>#eq #tvar"</span>
                <span class="hljs-keyword">else</span> <span class="hljs-string">"#pvar &lt; 0 ? #idx &gt;#eq #tvar : #idx &lt;#eq #tvar"</span>
        <span class="hljs-keyword">else</span>
            @item = Var o.scope.temporary \x <span class="hljs-keyword">if</span> @ref
            <span class="hljs-keyword">if</span> @item <span class="hljs-keyword">or</span> @object <span class="hljs-keyword">and</span> @own <span class="hljs-keyword">or</span> @let
                [svar, srcPart] = @source.compile-<span class="hljs-keyword">loop</span>-reference o, \ref, <span class="hljs-keyword">not</span> @object, <span class="hljs-literal">true</span>
                svar <span class="hljs-keyword">is</span> srcPart <span class="hljs-keyword">or</span> temps.push svar
            <span class="hljs-keyword">else</span>
                svar = srcPart = @source.compile o, LEVEL_PAREN
            <span class="hljs-keyword">unless</span> @object
                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &gt; pvar <span class="hljs-keyword">and</span> ~~pvar <span class="hljs-keyword">is</span> +pvar  <span class="hljs-comment"># negative int</span>
                    vars = <span class="hljs-string">"#idx = #srcPart.length - 1"</span>
                    cond = <span class="hljs-string">"#idx &gt;= 0"</span>
                <span class="hljs-keyword">else</span>
                    temps.push lvar = o.scope.temporary \len
                    vars = <span class="hljs-string">"#idx = 0, #lvar = #srcPart.length"</span>
                    cond = <span class="hljs-string">"#idx &lt; #lvar"</span>
        @else <span class="hljs-keyword">and</span> @yet = o.scope.temporary \yet
        head = [sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">'for ('</span>)]
        head.push idx, <span class="hljs-string">" in "</span> <span class="hljs-keyword">if</span> @object
        head.push that, <span class="hljs-string">" = true, "</span> <span class="hljs-keyword">if</span> @yet
        <span class="hljs-keyword">if</span> @object
            head.push srcPart
        <span class="hljs-keyword">else</span>
            step <span class="hljs-keyword">is</span> pvar <span class="hljs-keyword">or</span> vars += <span class="hljs-string">', '</span> + step
            head.push vars, <span class="hljs-string">"; "</span>, cond, <span class="hljs-string">"; "</span> + <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> ~= Math.abs pvar
                <span class="hljs-keyword">then</span> (<span class="hljs-keyword">if</span> pvar &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> \-- <span class="hljs-keyword">else</span> \++) + idx
                <span class="hljs-keyword">else</span> idx + <span class="hljs-keyword">if</span> pvar &lt; <span class="hljs-number">0</span>
                    <span class="hljs-keyword">then</span> <span class="hljs-string">' -= '</span> + pvar.to-string!.slice <span class="hljs-number">1</span>
                    <span class="hljs-keyword">else</span> <span class="hljs-string">' += '</span> + pvar
        @own <span class="hljs-keyword">and</span> head.push sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">") if ("</span>), (o.scope.assign \own$ <span class="hljs-string">'{}.hasOwnProperty'</span>), <span class="hljs-string">".call("</span>, svar, <span class="hljs-string">", "</span>, idx, <span class="hljs-string">")"</span>
        head.push sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">') {'</span>)
        <span class="hljs-keyword">if</span> @let
            @body.traverse-children !-&gt;
                <span class="hljs-keyword">switch</span> it.value
                | \index$$ =&gt; it.value = idx
                | \item$$  =&gt; it.value = <span class="hljs-string">"#svar[#idx]"</span>
        o.indent += TAB
        <span class="hljs-keyword">if</span> @index <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @object
            head.push \\n + o.indent, Assign(Var @index; JS idx).compile(o, LEVEL_TOP), \;
        <span class="hljs-keyword">if</span> @item <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @item.<span class="hljs-keyword">is</span>-empty! <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @from
            head.push \\n + o.indent, Assign(@item, JS <span class="hljs-string">"#svar[#idx]"</span>)compile(o, LEVEL_TOP), \;
        o.ref = @item.value <span class="hljs-keyword">if</span> @ref
        body  = @compile-body o
        head.push \\n + @tab <span class="hljs-keyword">if</span> (@item <span class="hljs-keyword">or</span> (@index <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @object)) <span class="hljs-keyword">and</span> \} <span class="hljs-keyword">is</span> body.to-string!.char-at <span class="hljs-number">0</span>
        sn(<span class="hljs-literal">null</span>, ...head, body)</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <h3 id="step-slice">Step slice</h3>
<p>Slices a list in steps
Makes it possible to combine non-literals and the BY keyword in slices
E.g. list[1 to 10][f() to x by (1+1)]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">StepSlice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">For</span></span>

    make-return: <span class="hljs-function"><span class="hljs-params">(@make-returnArg)</span> -&gt;</span> <span class="hljs-keyword">super</span> ...

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        @index = o.scope.temporary \x
        [sub, ref, temps] = @target.unwrap!cache o
        @guard = Binary <span class="hljs-string">'&lt;'</span> (Literal @index), (Chain ref .add Index Key \length)
        @make-comprehension (Chain ref .add Index Literal @index), <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">if</span> @make-returnArg? <span class="hljs-keyword">then</span> @make-<span class="hljs-keyword">return</span> @make-returnArg
        code = []
        <span class="hljs-keyword">if</span> temps <span class="hljs-keyword">then</span> code.push sub.compile(o), \; + \\n + o.indent
        code.push <span class="hljs-keyword">super</span> ...
        sn(<span class="hljs-keyword">this</span>, ...code)</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <h3 id="try">Try</h3>
<p>Classic <code>try</code>-<code>catch</code>-<code>finally</code> block with optional <code>catch</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Try</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@attempt, @thrown, @recovery, @ensure) -&gt;
        @recovery?lines.unshift Assign (@thrown <span class="hljs-keyword">or</span> Var \e), Var \e$

    children: &lt;[ attempt recovery ensure ]&gt;

    show: <span class="hljs-function">-&gt;</span> @thrown

    <span class="hljs-keyword">is</span>-statement: YES

    <span class="hljs-keyword">is</span>-callable: <span class="hljs-function">-&gt;</span> @recovery?<span class="hljs-keyword">is</span>-callable! <span class="hljs-keyword">and</span> @attempt.<span class="hljs-keyword">is</span>-callable!

    get-jump: <span class="hljs-function">-&gt;</span> @attempt.get-jump it <span class="hljs-keyword">or</span> @recovery?get-jump it

    make-return: <span class="hljs-function">-&gt;</span>
        @attempt .=make-<span class="hljs-keyword">return</span> ...&amp;
        @recovery?=make-<span class="hljs-keyword">return</span> ...&amp;
        <span class="hljs-keyword">this</span>

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        o.indent += TAB
        code = [sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">'try '</span>), (@compile-block o, @attempt)]
        <span class="hljs-keyword">if</span> @recovery <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> @ensure <span class="hljs-keyword">and</span> JS <span class="hljs-string">''</span>
            code.push sn(that, <span class="hljs-string">' catch (e$) '</span>), (@compile-block o, that)
        <span class="hljs-keyword">if</span> @ensure
            code.push sn(that, <span class="hljs-string">' finally '</span>), (@compile-block o, that)
        sn(<span class="hljs-literal">null</span>, ...code)</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <h3 id="switch">Switch</h3>
<p>Compiles to the regular JS <code>switch</code>-<code>case</code>-<code>default</code>,
but with forced <code>break</code> after each cases.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Switch</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@type, @topic, @cases, @default) -&gt;
        <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> \match
            @target = Arr topic <span class="hljs-keyword">if</span> topic
            @topic = <span class="hljs-literal">null</span>
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">if</span> topic
                <span class="hljs-keyword">throw</span> <span class="hljs-string">"can't have more than one topic in switch statement"</span> <span class="hljs-keyword">if</span> topic.length &gt; <span class="hljs-number">1</span>
                @topic.=<span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> @cases.length <span class="hljs-keyword">and</span> (last = @cases[*<span class="hljs-number">-1</span>]).tests.length <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">and</span> last.tests<span class="hljs-number">.0</span> <span class="hljs-keyword">instanceof</span> Var <span class="hljs-keyword">and</span> last.tests<span class="hljs-number">.0</span>.value <span class="hljs-keyword">is</span> \_
            @cases.pop!
            @default = last.body

    children: &lt;[ topic cases default ]&gt;

    a-source: \topic, aTargets: &lt;[ cases default ]&gt;

    show: <span class="hljs-function">-&gt;</span> @type

    <span class="hljs-keyword">is</span>-statement: YES

    <span class="hljs-keyword">is</span>-callable: <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> @cases <span class="hljs-keyword">when</span> <span class="hljs-keyword">not</span> c.<span class="hljs-keyword">is</span>-callable! <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> @default <span class="hljs-keyword">then</span> @default.<span class="hljs-keyword">is</span>-callable! <span class="hljs-keyword">else</span> <span class="hljs-literal">true</span>

    get-jump: <span class="hljs-function"><span class="hljs-params">(ctx <span class="hljs-keyword">or</span> {})</span> -&gt;</span>
        ctx.<span class="hljs-keyword">break</span> = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> @cases <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> that <span class="hljs-keyword">if</span> c.body.get-jump ctx
        @default?get-jump ctx

    make-return: <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> @cases <span class="hljs-keyword">then</span> c.make-<span class="hljs-keyword">return</span> ...&amp;
        @default?make-<span class="hljs-keyword">return</span> ...&amp;
        <span class="hljs-keyword">this</span>

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        {tab} = <span class="hljs-keyword">this</span>
        [target-node, target] = Chain @target .cache-reference o <span class="hljs-keyword">if</span> @target
        topic = <span class="hljs-keyword">if</span> @type <span class="hljs-keyword">is</span> \match
            t = <span class="hljs-keyword">if</span> target <span class="hljs-keyword">then</span> [target-node] <span class="hljs-keyword">else</span> []
            Block (t ++ [Literal \<span class="hljs-literal">false</span>]) .compile o, LEVEL_PAREN
        <span class="hljs-keyword">else</span>
            !!@topic <span class="hljs-keyword">and</span> @anaphorize!compile o, LEVEL_PAREN
        code  = [sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"switch ("</span>, sn-safe(topic), <span class="hljs-string">") {\n"</span>)]
        stop  = @default <span class="hljs-keyword">or</span> @cases.length - <span class="hljs-number">1</span>
        o.<span class="hljs-keyword">break</span> = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">for</span> c, i <span class="hljs-keyword">in</span> @cases
            code.push (c.compile-case o, tab, i <span class="hljs-keyword">is</span> stop, (@type <span class="hljs-keyword">is</span> \match <span class="hljs-keyword">or</span> !topic), @type, target)
        <span class="hljs-keyword">if</span> @default
            o.indent = tab + TAB
            code.push tab + <span class="hljs-string">"default:\n"</span>, that, <span class="hljs-string">"\n"</span> <span class="hljs-keyword">if</span> @default.compile o, LEVEL_TOP
        sn(<span class="hljs-literal">null</span>, ...code, tab + \})</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <h3 id="case">Case</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Case</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@tests, @body) -&gt;

    children: &lt;[ tests body ]&gt;

    <span class="hljs-keyword">is</span>-callable: <span class="hljs-function">-&gt;</span> @body.<span class="hljs-keyword">is</span>-callable!

    make-return: <span class="hljs-function">-&gt;</span>
        @body.make-<span class="hljs-keyword">return</span> ...&amp; <span class="hljs-keyword">unless</span> @body.lines[*<span class="hljs-number">-1</span>]?value <span class="hljs-keyword">is</span> \fallthrough
        <span class="hljs-keyword">this</span>

    compile-case: <span class="hljs-function"><span class="hljs-params">(o, tab, nobr, bool, type, target)</span> -&gt;</span>
        tests = []
        <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> @tests
            test.=expand-slice(o)unwrap!
            <span class="hljs-keyword">if</span> test <span class="hljs-keyword">instanceof</span> Arr <span class="hljs-keyword">and</span> type <span class="hljs-keyword">isnt</span> \match
                <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> test.items <span class="hljs-keyword">then</span> tests.push t
            <span class="hljs-keyword">else</span> tests.push test
        tests.length <span class="hljs-keyword">or</span> tests.push Literal \void
        <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> \match
            <span class="hljs-keyword">for</span> test, i <span class="hljs-keyword">in</span> tests
                tar = Chain target .add Index (Literal i), \., <span class="hljs-literal">true</span>
                tests[i] = Parens (Chain test .auto-compare (<span class="hljs-keyword">if</span> target <span class="hljs-keyword">then</span> [tar] <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>))
        <span class="hljs-keyword">if</span> bool
            binary = <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> \match <span class="hljs-keyword">then</span> \&amp;&amp; <span class="hljs-keyword">else</span> \||
            [t] = tests
            i = <span class="hljs-number">0</span>
            <span class="hljs-keyword">while</span> tests[++i] <span class="hljs-keyword">then</span> t = Binary binary, t, that
            tests = [(@&lt;&lt;&lt;{t, a-source: \t, aTargets: [\body]})anaphorize!invert!]
        code = []
        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tests <span class="hljs-keyword">then</span> code.push tab, sn(t, <span class="hljs-string">"case "</span>, (t.compile o, LEVEL_PAREN), <span class="hljs-string">":\n"</span>)
        {lines} = @body
        last = lines[*<span class="hljs-number">-1</span>]
        lines[*<span class="hljs-number">-1</span>] = JS <span class="hljs-string">'// fallthrough'</span> <span class="hljs-keyword">if</span> ft = last?value <span class="hljs-keyword">is</span> \fallthrough
        o.indent = tab += TAB
        code.push bodyCode, \\n     <span class="hljs-keyword">unless</span> sn-empty(bodyCode = @body.compile o, LEVEL_TOP)
        code.push tab  + <span class="hljs-string">'break;\n'</span> <span class="hljs-keyword">unless</span> nobr <span class="hljs-keyword">or</span> ft <span class="hljs-keyword">or</span> last <span class="hljs-keyword">instanceof</span> Jump
        sn(<span class="hljs-literal">null</span>, ...code)</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <h3 id="if">If</h3>
<p>The <code>if</code>/<code>else</code> structure that acts as both statement and expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">If</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@if, @then, @un) ~&gt;

    children: &lt;[ <span class="hljs-keyword">if</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">else</span> ]&gt;

    a-source: \<span class="hljs-keyword">if</span>, aTargets: [\<span class="hljs-keyword">then</span>]

    show: <span class="hljs-function">-&gt;</span> @un <span class="hljs-keyword">and</span> \!

    terminator: <span class="hljs-string">''</span>

    ::delegate &lt;[ isCallable isArray isString isRegex ]&gt; -&gt;
        @else?[it]! <span class="hljs-keyword">and</span> @then[it]!

    get-jump: <span class="hljs-function">-&gt;</span> @then.get-jump it <span class="hljs-keyword">or</span> @else?get-jump it

    make-return: <span class="hljs-function">-&gt;</span>
        @then.=make-<span class="hljs-keyword">return</span> ...&amp;
        @else?=make-<span class="hljs-keyword">return</span> ...&amp;
        <span class="hljs-keyword">this</span>

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> @un <span class="hljs-keyword">then</span> @if.=invert! <span class="hljs-keyword">else</span> @soak <span class="hljs-keyword">or</span> @anaphorize!
        <span class="hljs-keyword">if</span> o.level <span class="hljs-keyword">then</span> @compile-expression o <span class="hljs-keyword">else</span> @compile-statement o

    compile-statement: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        code = [sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"if ("</span>, (@if.compile o, LEVEL_PAREN), <span class="hljs-string">") "</span>)]
        o.indent += TAB
        code.push (@compile-block o, Block @then)
        <span class="hljs-keyword">return</span> sn(<span class="hljs-literal">null</span>, ...code) <span class="hljs-keyword">unless</span> els = @else
        sn(<span class="hljs-literal">null</span>, ...code, sn(els, <span class="hljs-string">' else '</span>), (<span class="hljs-keyword">if</span> els <span class="hljs-keyword">instanceof</span> constructor
            <span class="hljs-keyword">then</span> els.compile o &lt;&lt;&lt; indent: @tab, LEVEL_TOP
            <span class="hljs-keyword">else</span> @compile-block o, els))

    compile-expression: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        {then: thn, else: els <span class="hljs-keyword">or</span> Literal \void} = <span class="hljs-keyword">this</span>
        @void <span class="hljs-keyword">and</span> thn.void = els.void = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> @else <span class="hljs-keyword">and</span> (@cond <span class="hljs-keyword">or</span> @void)
            <span class="hljs-keyword">return</span> Parens Binary \&amp;&amp; @if, thn .compile o
        code = [sn(<span class="hljs-keyword">this</span>, @if.compile o, LEVEL_COND)]
        pad  = <span class="hljs-keyword">if</span> els.<span class="hljs-keyword">is</span>-complex! <span class="hljs-keyword">then</span> \\n + o.indent += TAB <span class="hljs-keyword">else</span> <span class="hljs-string">' '</span>
        code.push <span class="hljs-string">"#pad"</span>, sn(thn, <span class="hljs-string">"? "</span>), (thn.compile o, LEVEL_LIST), <span class="hljs-string">"#pad"</span>, sn(els, <span class="hljs-string">": "</span>), (els.compile o, LEVEL_LIST)
        <span class="hljs-keyword">if</span> o.level &lt; LEVEL_COND <span class="hljs-keyword">then</span> sn(<span class="hljs-literal">null</span>, ...code) <span class="hljs-keyword">else</span> sn(<span class="hljs-literal">null</span>, <span class="hljs-string">"("</span>, code, <span class="hljs-string">")"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>Unfolds a node’s child if soak,
then tuck the node under the created <strong>If</strong>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    @unfold-soak = <span class="hljs-function"><span class="hljs-params">(o, parent, name)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> parent[name]unfold-soak o
            parent[name] = that.<span class="hljs-keyword">then</span>
            that &lt;&lt;&lt; {parent.cond, parent.void, then: Chain parent}</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <h3 id="label">Label</h3>
<p>A labeled block or statement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Label</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@label <span class="hljs-keyword">or</span> \_, @it) -&gt;
        @carp <span class="hljs-string">"can't use label with a curried function (attempted label '<span class="hljs-subst">#{@label}</span>')"</span> <span class="hljs-keyword">if</span> @it.curried
        <span class="hljs-keyword">if</span> fun = it <span class="hljs-keyword">instanceof</span> [Fun, Class] <span class="hljs-keyword">and</span> it <span class="hljs-keyword">or</span>
             it.calling <span class="hljs-keyword">and</span> it.it.head
            fun.name <span class="hljs-keyword">or</span> fun &lt;&lt;&lt; {name: @label, +labeled}
            <span class="hljs-keyword">return</span> it

    ::{children, <span class="hljs-keyword">is</span>-callable, <span class="hljs-keyword">is</span>-array} = Parens::

    show: <span class="hljs-function">-&gt;</span> @label

    <span class="hljs-keyword">is</span>-statement: YES

    get-jump: <span class="hljs-function"><span class="hljs-params">(ctx <span class="hljs-keyword">or</span> {})</span> -&gt;</span>
        (ctx.labels ?= []).push @label
        @it.get-jump ctx &lt;&lt;&lt; {+\<span class="hljs-keyword">break</span>}

    make-return: <span class="hljs-function">-&gt;</span> @it.=make-<span class="hljs-keyword">return</span> ...&amp;; <span class="hljs-keyword">this</span>

    compile-node: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        {label, it} = <span class="hljs-keyword">this</span>
        labels = o.labels = [...o.labels <span class="hljs-keyword">or</span> []]
        @carp <span class="hljs-string">"duplicate label \"#label\""</span> <span class="hljs-keyword">if</span> label <span class="hljs-keyword">in</span> labels
        labels.push label
        it.<span class="hljs-keyword">is</span>-statement! <span class="hljs-keyword">or</span> it = Block it
        sn(<span class="hljs-literal">null</span>, sn(<span class="hljs-keyword">this</span>, label, <span class="hljs-string">": "</span>), (<span class="hljs-keyword">if</span> it <span class="hljs-keyword">instanceof</span> Block
            <span class="hljs-keyword">then</span> o.indent += TAB; @compile-block o, it
            <span class="hljs-keyword">else</span> it.compile o))</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <h3 id="cascade">Cascade</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Cascade</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@input, @output, @prog1) ~&gt;

    show: <span class="hljs-function">-&gt;</span> @prog1

    children: &lt;[ input output ]&gt;

    terminator: <span class="hljs-string">''</span>

    ::delegate &lt;[ isCallable isArray isString isRegex ]&gt; -&gt;
        @[<span class="hljs-keyword">if</span> @prog1 <span class="hljs-keyword">then</span> \input <span class="hljs-keyword">else</span> \output][it]!

    get-jump: <span class="hljs-function">-&gt;</span> @output.get-jump it

    make-return: <span class="hljs-function"><span class="hljs-params">(@ret)</span> -&gt;</span> <span class="hljs-keyword">this</span>

    compile-node: <span class="hljs-function"><span class="hljs-params">({level}:o)</span> -&gt;</span>
        {input, output, prog1, ref} = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">if</span> prog1 <span class="hljs-keyword">and</span> (\ret <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">or</span> level <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> @void)
            output.add (Literal(\..) &lt;&lt;&lt; {+cascadee})
        <span class="hljs-keyword">if</span> \ret <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>
            output.=make-<span class="hljs-keyword">return</span> @ret
        <span class="hljs-keyword">if</span> ref
        <span class="hljs-keyword">then</span> prog1 <span class="hljs-keyword">or</span> output = Assign Var(ref), output
        <span class="hljs-keyword">else</span> ref = o.scope.temporary \x
        <span class="hljs-keyword">if</span> input <span class="hljs-keyword">instanceof</span> Cascade
        <span class="hljs-keyword">then</span> input &lt;&lt;&lt; {ref}
        <span class="hljs-keyword">else</span> input &amp;&amp;= Assign Var(ref), input
        o.level &amp;&amp;= LEVEL_PAREN
        code = [(input.compile o)]
        out  = Block output .compile o &lt;&lt;&lt; ref: <span class="hljs-keyword">new</span> String ref
        @carp <span class="hljs-string">"unreferred cascadee"</span> <span class="hljs-keyword">if</span> prog1 <span class="hljs-keyword">is</span> \cascade <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> o.ref.erred
        <span class="hljs-keyword">return</span> sn(<span class="hljs-literal">null</span>, ...code, input.terminator, <span class="hljs-string">"\n"</span>, out) <span class="hljs-keyword">unless</span> level
        code.push <span class="hljs-string">", "</span>, out
        <span class="hljs-keyword">if</span> level &gt; LEVEL_PAREN <span class="hljs-keyword">then</span> sn(<span class="hljs-literal">null</span>, <span class="hljs-string">"("</span>, ...code, <span class="hljs-string">")"</span>) <span class="hljs-keyword">else</span> sn(<span class="hljs-literal">null</span>, ...code)</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <h3 id="js">JS</h3>
<p>Embedded JavaScript snippets.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">JS</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@code, @literal, @comment) ~&gt;

    show: <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">if</span> @comment <span class="hljs-keyword">then</span> @code <span class="hljs-keyword">else</span> <span class="hljs-string">"`<span class="hljs-subst">#{@code}</span>`"</span>

    terminator: <span class="hljs-string">''</span>

    ::<span class="hljs-keyword">is</span>-assignable = ::<span class="hljs-keyword">is</span>-callable = <span class="hljs-function">-&gt;</span> <span class="hljs-keyword">not</span> @comment

    compile: <span class="hljs-function">-&gt;</span> sn(<span class="hljs-keyword">this</span>, sn-safe(<span class="hljs-keyword">if</span> @literal <span class="hljs-keyword">then</span> entab @code, it.indent <span class="hljs-keyword">else</span> @code))</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <h3 id="require">Require</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Require</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@body) ~&gt;

    children: &lt;[ body ]&gt;

    compile: <span class="hljs-function"><span class="hljs-params">(o)</span> -&gt;</span>
        get-value = (item, <span class="hljs-keyword">throw</span>-error) ~&gt;
            | item <span class="hljs-keyword">instanceof</span> Key     =&gt; item.name
            | item <span class="hljs-keyword">instanceof</span> Var     =&gt; item.value
            | item <span class="hljs-keyword">instanceof</span> Literal =&gt; item.value
            | otherwise               =&gt; <span class="hljs-keyword">if</span> <span class="hljs-keyword">throw</span>-error
                                   <span class="hljs-keyword">then</span> @carp <span class="hljs-string">'invalid require! argument'</span>
                                   <span class="hljs-keyword">else</span> item

        process-item = <span class="hljs-function"><span class="hljs-params">(item)</span> -&gt;</span>
            [asg, value] = <span class="hljs-keyword">switch</span>
            | item <span class="hljs-keyword">instanceof</span> Prop    =&gt; [item.val, item.key]
            | otherwise               =&gt; [item, item]
            asg-value = get-value asg
            to-asg = <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span>! asg-value <span class="hljs-keyword">is</span> <span class="hljs-string">'String'</span> <span class="hljs-keyword">then</span> CopyL asg, Var name-from-path asg-value <span class="hljs-keyword">else</span> asg
            value = strip-string get-value value, <span class="hljs-literal">true</span>

            main = Chain (CopyL <span class="hljs-keyword">this</span>, Var <span class="hljs-string">'require'</span>) .add Call [Literal <span class="hljs-string">"'#value'"</span>]

            sn(item, (Assign to-asg, main .compile o))

        <span class="hljs-keyword">if</span> @body.items?
            code = []
            <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> @body.items
                code.push (process-item item), <span class="hljs-string">";\n<span class="hljs-subst">#{o.indent}</span>"</span>
            code.pop!
            sn(<span class="hljs-literal">null</span>, ...code)
        <span class="hljs-keyword">else</span>
            sn(<span class="hljs-literal">null</span>, process-item @body)</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <h3 id="util">Util</h3>
<p>A wrapper node for utility functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Util</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@verb) ~&gt;

    {(Jump::)show}

    <span class="hljs-keyword">is</span>-callable: YES

    compile: <span class="hljs-function">-&gt;</span> sn(<span class="hljs-keyword">this</span>, util @verb)</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <h4 id="util-extends">Util.Extends</h4>
<p>An operator that sets up class-ical inheritance between two constructors,
returning the left one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    @Extends = <span class="hljs-function">-&gt;</span> Call.make Util(\extend), &amp;[<span class="hljs-number">0</span> <span class="hljs-number">1</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <h3 id="vars">Vars</h3>
<p>Declares uninitialized variables.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">exports</span>.<span class="hljs-title">Vars</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span></span>
    (@vars) ~&gt;

    children: [\vars]

    make-return: THIS

    compile: <span class="hljs-function"><span class="hljs-params">(o, level)</span> -&gt;</span>
        <span class="hljs-keyword">for</span> {value}:v <span class="hljs-keyword">in</span> @vars
            v.carp <span class="hljs-string">'invalid variable declaration'</span> <span class="hljs-keyword">unless</span> v <span class="hljs-keyword">instanceof</span> Var
            v.carp <span class="hljs-string">"redeclaration of \"#value\""</span> <span class="hljs-keyword">if</span> o.scope.check value
            o.scope.declare value, v
        sn(<span class="hljs-keyword">this</span>, (Literal \void .compile o, level))</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <h3 id="parser-utils">Parser Utils</h3>
<p>Helpers for modifying nodes in <a href="../lib/parser.js">parser</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
exports.L = <span class="hljs-function"><span class="hljs-params">(a, b, node)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> node &amp;&amp; <span class="hljs-keyword">typeof</span> node == <span class="hljs-string">"object"</span>
        node &lt;&lt;&lt;
            first_line: a.first_line+<span class="hljs-number">1</span>
            first_column: a.first_column
            last_line: b.last_line+<span class="hljs-number">1</span>
            last_column: b.last_column
            line: a.first_line+<span class="hljs-number">1</span>
            column: a.first_column
    node

exports.CopyL = CopyL = <span class="hljs-function"><span class="hljs-params">(a, node)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> node &amp;&amp; <span class="hljs-keyword">typeof</span> node == <span class="hljs-string">"object"</span>
        node &lt;&lt;&lt;
            first_line: a.first_line
            first_column: a.first_column
            last_line: a.last_line
            last_column: a.last_column
            line: a.line
            column: a.column
    node

exports.Box = <span class="hljs-function"><span class="hljs-params">(v)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> v == <span class="hljs-string">"object"</span>
        v
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">new</span> v.constructor(v)

exports.Decl = <span class="hljs-function"><span class="hljs-params">(type, nodes, lno)</span> -&gt;</span>
    <span class="hljs-keyword">throw</span> SyntaxError <span class="hljs-string">"empty #type on line #lno"</span> <span class="hljs-keyword">unless</span> nodes<span class="hljs-number">.0</span>
    DECLS[type] nodes

DECLS =
    export: <span class="hljs-function"><span class="hljs-params">(lines)</span> -&gt;</span>
        i = <span class="hljs-number">-1</span>
        out = Util \out
        <span class="hljs-keyword">while</span> node = lines[++i]
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Block
                lines.splice i-- <span class="hljs-number">1</span> ...node.lines
                <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Fun <span class="hljs-keyword">and</span> node.name
                lines.splice i++ <span class="hljs-number">0</span> Assign Chain(out, [Index Key that]), Var that
                <span class="hljs-keyword">continue</span>
            lines[i] =
                <span class="hljs-keyword">if</span> node.var-name!
                <span class="hljs-keyword">or</span> node <span class="hljs-keyword">instanceof</span> Assign <span class="hljs-keyword">and</span> node.left. var-name!
                <span class="hljs-keyword">or</span> node <span class="hljs-keyword">instanceof</span> Class  <span class="hljs-keyword">and</span> node.title?var-name!
                <span class="hljs-keyword">then</span> Assign Chain(out, [Index Key that]), node
                <span class="hljs-keyword">else</span> Import out, node
        Block lines

    import: <span class="hljs-function"><span class="hljs-params">(lines, all)</span> -&gt;</span>
        <span class="hljs-keyword">for</span> line, i <span class="hljs-keyword">in</span> lines <span class="hljs-keyword">then</span> lines[i] = Import Literal(\<span class="hljs-keyword">this</span>), line, all
        Block lines

    import-all: <span class="hljs-function">-&gt;</span> @import it, <span class="hljs-literal">true</span>

    const: <span class="hljs-function"><span class="hljs-params">(lines)</span> -&gt;</span>
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> lines
            node.op <span class="hljs-keyword">is</span> \= <span class="hljs-keyword">or</span> node.carp <span class="hljs-string">'invalid constant variable declaration'</span>
            node.const = <span class="hljs-literal">true</span>
        Block lines

    var: Vars</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <h4 id="scope">Scope</h4>
<p>Regulates lexical scoping within LiveScript. As you
generate code, you create a tree of scopes in the same shape as the nested
functions. Each scope knows about the function parameters and the variables
declared within it, and has references to its parent/shared enclosing scopes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>!function Scope @parent, @shared
    @variables = {}
Scope ::=
    READ_ONLY: const:\constant function:\function undefined:\undeclared</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>Adds a new variable or overrides an existing one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    add: <span class="hljs-function"><span class="hljs-params">(name, type, node)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">and</span> t = @variables<span class="hljs-string">"#name."</span>
            <span class="hljs-keyword">if</span> @READ_ONLY[t] <span class="hljs-keyword">or</span> @READ_ONLY[type]
                node.carp <span class="hljs-string">"redeclaration of #that \"#name\""</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> type <span class="hljs-keyword">is</span> \arg
                node.carp <span class="hljs-string">"duplicate parameter \"#name\""</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> \upvar
                node.carp <span class="hljs-string">"accidental shadow of \"#name\""</span>
            <span class="hljs-keyword">return</span> name <span class="hljs-keyword">if</span> t <span class="hljs-keyword">in</span> &lt;[ arg function ]&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>Dot-suffix to bypass <code>Object::</code> members.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        @variables<span class="hljs-string">"#name."</span> = type
        name

    get: <span class="hljs-function"><span class="hljs-params">(name)</span> -&gt;</span> @variables<span class="hljs-string">"#name."</span></pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>Declares a variable unless declared already.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    declare: <span class="hljs-function"><span class="hljs-params">(name, node, constant)</span> -&gt;</span>
        <span class="hljs-keyword">if</span> @shared
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> @check name
            scope = that
        <span class="hljs-keyword">else</span>
            scope = <span class="hljs-keyword">this</span>
        scope.add name, (<span class="hljs-keyword">if</span> constant <span class="hljs-keyword">then</span> \const <span class="hljs-keyword">else</span> \var), node</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>Ensures that an assignment is made at the top of this scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    assign: <span class="hljs-function"><span class="hljs-params">(name, value)</span> -&gt;</span> @add name, {value}</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>If we need to store an intermediate result, find an available name for a
compiler-generated variable. <code>var$</code>, <code>var1$</code>, and so on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    temporary: <span class="hljs-function"><span class="hljs-params">(name || \ref)</span> -&gt;</span>
        <span class="hljs-keyword">until</span> @variables<span class="hljs-string">"#name\$."</span> <span class="hljs-keyword">in</span> [\reuse void]
            name = <span class="hljs-keyword">if</span> name.length &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> name &lt; \z
                <span class="hljs-keyword">then</span> String.fromCharCode name.charCodeAt! + <span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span> name.replace <span class="hljs-regexp">/\d*$/</span> -&gt; ++it
        @add name + \$, \var</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>Allows a variable to be reused.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    free: <span class="hljs-function"><span class="hljs-params">(name)</span> -&gt;</span> @add name, \reuse</pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>Checks to see if a variable has already been declared.
Walks up the scope if <code>above</code> flag is specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    check: <span class="hljs-function"><span class="hljs-params">(name, above)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> type <span class="hljs-keyword">if</span> (type = @variables<span class="hljs-string">"#name."</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> above
        @parent?check name, above</pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>Checks if a variable can be reassigned.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    check-read-only: <span class="hljs-function"><span class="hljs-params">(name)</span> -&gt;</span>
        <span class="hljs-keyword">return</span> that <span class="hljs-keyword">if</span> @READ_ONLY[@check name, <span class="hljs-literal">true</span>]
        @variables<span class="hljs-string">"#name."</span> ||= \upvar
        <span class="hljs-string">''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>Concatenates the declarations in this scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    emit: <span class="hljs-function"><span class="hljs-params">(code, tab)</span> -&gt;</span>
        vrs = []
        asn = []
        fun = []
        <span class="hljs-keyword">for</span> name, type <span class="hljs-keyword">of</span> @variables
            name.=slice <span class="hljs-number">0</span> <span class="hljs-number">-1</span>
            <span class="hljs-keyword">if</span> type <span class="hljs-keyword">in</span> &lt;[ var const reuse ]&gt;
                vrs.push name, <span class="hljs-string">", "</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> type.value
                <span class="hljs-keyword">if</span> ~(val = entab that, tab).to-string!.last-index-<span class="hljs-keyword">of</span> \function( <span class="hljs-number">0</span>
                    <span class="hljs-keyword">if</span> val <span class="hljs-keyword">instanceof</span> SourceNode
                        sn-remove-left(val, <span class="hljs-number">8</span>)
                    <span class="hljs-keyword">else</span>
                        val = val.slice(<span class="hljs-number">8</span>)
                    fun.push <span class="hljs-string">"function "</span>, name, val, <span class="hljs-string">"\n#tab"</span>
                <span class="hljs-keyword">else</span>
                    asn.push name, <span class="hljs-string">" = "</span>, val, <span class="hljs-string">", "</span>
        declCode = vrs.concat asn
        declCode.pop!
        fun.pop!
        code = sn(<span class="hljs-keyword">this</span>, <span class="hljs-string">"<span class="hljs-subst">#{tab}</span>var "</span>, ...declCode, <span class="hljs-string">";\n"</span>, code) <span class="hljs-keyword">if</span> declCode.length &gt; <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> fun.length &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> sn(<span class="hljs-keyword">this</span>, code, <span class="hljs-string">"\n#tab"</span>, ...fun) <span class="hljs-keyword">else</span> sn(<span class="hljs-keyword">this</span>, code)</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <h4 id="constants">Constants</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>
function YES  <span class="hljs-keyword">then</span> <span class="hljs-literal">true</span>
function NO   <span class="hljs-keyword">then</span> <span class="hljs-literal">false</span>
function THIS <span class="hljs-keyword">then</span> <span class="hljs-keyword">this</span>
function VOID <span class="hljs-keyword">then</span> void

UTILS =</pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>Creates an object’s prototypal child, ensuring <code>__proto__</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    clone: <span class="hljs-string">'''function(it){
      function fun(){} fun.prototype = it;
      return new fun;
    }'''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <p>Sets up <code>.prototype</code> between a pair of constructors
as well as <code>.constructor</code> and <code>.superclass</code> references.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    extend: <span class="hljs-string">'''function(sub, sup){
      function fun(){} fun.prototype = (sub.superclass = sup).prototype;
      (sub.prototype = new fun).constructor = sub;
      if (typeof sup.extended == 'function') sup.extended(sub);
      return sub;
    }'''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>Creates a bound method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    bind: <span class="hljs-string">'''function(obj, key, target){
      return function(){ return (target || obj)[key].apply(obj, arguments) };
    }'''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>Copies properties from right to left.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    import: <span class="hljs-string">'''function(obj, src){
      var own = {}.hasOwnProperty;
      for (var key in src) if (own.call(src, key)) obj[key] = src[key];
      return obj;
    }'''</span>
    import-all: <span class="hljs-string">'''function(obj, src){
      for (var key in src) obj[key] = src[key];
      return obj;
    }'''</span>

    repeat-string: <span class="hljs-string">'''function(str, n){
      for (var r = ''; n &gt; 0; (n &gt;&gt;= 1) &amp;&amp; (str += str)) if (n &amp; 1) r += str;
      return r;
    }'''</span>
    repeat-array: <span class="hljs-string">'''function(arr, n){
      for (var r = []; n &gt; 0; (n &gt;&gt;= 1) &amp;&amp; (arr = arr.concat(arr)))
        if (n &amp; 1) r.push.apply(r, arr);
      return r;
    }'''</span>

    in: <span class="hljs-string">'''function(x, xs){
      var i = -1, l = xs.length &gt;&gt;&gt; 0;
      while (++i &lt; l) if (x === xs[i]) return true;
      return false;
    }'''</span>

    out: <span class="hljs-string">'''typeof exports != 'undefined' &amp;&amp; exports || this'''</span>

    curry: <span class="hljs-string">'''function(f, bound){
      var context,
      _curry = function(args) {
        return f.length &gt; 1 ? function(){
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) &lt;
              f.length &amp;&amp; arguments.length ?
            _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }'''</span>

    flip: <span class="hljs-string">'''function(f){
      return curry$(function (x, y) { return f(y, x); });
    }'''</span>

    partialize: <span class="hljs-string">'''function(f, args, where){
      var context = this;
      return function(){
        var params = slice$.call(arguments), i,
            len = params.length, wlen = where.length,
            ta = args ? args.concat() : [], tw = where ? where.concat() : [];
        for(i = 0; i &lt; len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
        return len &lt; wlen &amp;&amp; len ?
          partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
      };
    }'''</span>
    not: <span class="hljs-string">'''function(x){ return !x; }'''</span>
    compose: <span class="hljs-string">'''function() {
      var functions = arguments;
      return function() {
        var i, result;
        result = functions[0].apply(this, arguments);
        for (i = 1; i &lt; functions.length; ++i) {
          result = functions[i](result);
        }
        return result;
      };
    }'''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>modified version of underscore.js’s _.isEqual and eq functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    deep-eq: <span class="hljs-string">'''function(x, y, type){
      var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
          has = function (obj, key) { return hasOwnProperty.call(obj, key); };
      var first = true;
      return eq(x, y, []);
      function eq(a, b, stack) {
        var className, length, size, result, alength, blength, r, key, ref, sizeB;
        if (a == null || b == null) { return a === b; }
        if (a.__placeholder__ || b.__placeholder__) { return true; }
        if (a === b) { return a !== 0 || 1 / a == 1 / b; }
        className = toString.call(a);
        if (toString.call(b) != className) { return false; }
        switch (className) {
          case '[object String]': return a == String(b);
          case '[object Number]':
            return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
          case '[object Date]':
          case '[object Boolean]':
            return +a == +b;
          case '[object RegExp]':
            return a.source == b.source &amp;&amp;
                   a.global == b.global &amp;&amp;
                   a.multiline == b.multiline &amp;&amp;
                   a.ignoreCase == b.ignoreCase;
        }
        if (typeof a != 'object' || typeof b != 'object') { return false; }
        length = stack.length;
        while (length--) { if (stack[length] == a) { return true; } }
        stack.push(a);
        size = 0;
        result = true;
        if (className == '[object Array]') {
          alength = a.length;
          blength = b.length;
          if (first) {
            switch (type) {
            case '===': result = alength === blength; break;
            case '&lt;==': result = alength &lt;= blength; break;
            case '&lt;&lt;=': result = alength &lt; blength; break;
            }
            size = alength;
            first = false;
          } else {
            result = alength === blength;
            size = alength;
          }
          if (result) {
            while (size--) {
              if (!(result = size in a == size in b &amp;&amp; eq(a[size], b[size], stack))){ break; }
            }
          }
        } else {
          if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
            return false;
          }
          for (key in a) {
            if (has(a, key)) {
              size++;
              if (!(result = has(b, key) &amp;&amp; eq(a[key], b[key], stack))) { break; }
            }
          }
          if (result) {
            sizeB = 0;
            for (key in b) {
              if (has(b, key)) { ++sizeB; }
            }
            if (first) {
              if (type === '&lt;&lt;=') {
                result = size &lt; sizeB;
              } else if (type === '&lt;==') {
                result = size &lt;= sizeB
              } else {
                result = size === sizeB;
              }
            } else {
              first = false;
              result = size === sizeB;
            }
          }
        }
        stack.pop();
        return result;
      }
    }'''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>Shortcuts to speed up the lookup time for native methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    split    : <span class="hljs-string">"''.split"</span>
    replace  : <span class="hljs-string">"''.replace"</span>
    to-string: <span class="hljs-string">'{}.toString'</span>
    join     : <span class="hljs-string">'[].join'</span>
    slice    : <span class="hljs-string">'[].slice'</span>
    splice   : <span class="hljs-string">'[].splice'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <p>Each level indicates a node’s position in the AST.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>LEVEL_TOP    = <span class="hljs-number">0</span>  <span class="hljs-comment"># ...;</span>
LEVEL_PAREN  = <span class="hljs-number">1</span>  <span class="hljs-comment"># (...)</span>
LEVEL_LIST   = <span class="hljs-number">2</span>  <span class="hljs-comment"># [...]</span>
LEVEL_COND   = <span class="hljs-number">3</span>  <span class="hljs-comment"># ... ? x : y</span>
LEVEL_OP     = <span class="hljs-number">4</span>  <span class="hljs-comment"># !...</span>
LEVEL_CALL   = <span class="hljs-number">5</span>  <span class="hljs-comment"># ...()</span></pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p>Operator precedences.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>let @ = PREC = {unary: <span class="hljs-number">0.9</span>}
    @\&amp;&amp; = @\|| = @\xor                             = <span class="hljs-number">0.2</span>
    @\.&amp;.  = @\.^.  = @\.|.                         = <span class="hljs-number">0.3</span>
    @\== = @\!= = @\~= = @\!~= = @\=== = @\!==      = <span class="hljs-number">0.4</span>
    @\&lt;  = @\&gt;  = @\&lt;=  = @\&gt;= = @of = @instanceof  = <span class="hljs-number">0.5</span>
    @\&lt;&lt;= = @\&gt;&gt;= = @\&lt;== = @\&gt;== = @\++            = <span class="hljs-number">0.5</span>
    @\.&lt;&lt;. = @\.&gt;&gt;. = @\.&gt;&gt;&gt;.                       = <span class="hljs-number">0.6</span>
    @\+  = @\-                                      = <span class="hljs-number">0.7</span>
    @\*  = @\/  = @\%                               = <span class="hljs-number">0.8</span>

TAB = <span class="hljs-string">' '</span> * <span class="hljs-number">2</span>

ID = <span class="hljs-regexp">/^(?!\d)[\w$\xAA-\uFFDC]+$/</span>

SIMPLENUM = <span class="hljs-regexp">/^\d+$/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <h4 id="helpers">Helpers</h4>

            </div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>Declares a utility function at the top level.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>function util <span class="hljs-keyword">then</span> Scope.root.assign it+\$ UTILS[it]

function entab code, tab <span class="hljs-keyword">then</span> code.replace <span class="hljs-regexp">/\n/g</span> \\n + tab</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
