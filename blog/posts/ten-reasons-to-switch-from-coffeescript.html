title: Ten reasons to switch from CoffeeScript to LiveScript
date:  4 Jul 2012
author: <a href="http://paulmillr.com/">Paul Miller</a>
-----

<p><a href="http://coffeescript.org">CoffeeScript</a> has been around for a while and is now used by many developers and tools.</p>

<p>But why should someone switch from Coffee to its fork, LiveScript?
Here's ten reasons:</p>

<ol>
<li>Improved readability. LiveScript supports dashes in identifiers and mangles them to camelCase to keep consistent with javascript code style. <code>document.query-selector-all</code> will be transformed to <code>document.querySelectorAll</code>. As for numbers, they support underscores and suffixes: <code>64_000km</code> will be compiled simply to <code>64000</code>.</li>

<li><code>|&gt;</code> chaining operator. It works with functions instead of methods on prototypes which allows to easily write your own modular functions for chains.</li>

<li><a href="http://gkz.github.com/prelude-ls/">Standard library</a>. ECMAScript 5 array extras are nice, but they’re not enough. Plays awesomly with chaining operator.</li>

<li>Partially applied operators and member access. This allows writing pure functional code without boilerplate: <code>people |&gt; map (.name) |&gt; filter (in visitors)</code> instead of <code>people.map((man) -&gt; man.name).filter((name) -&gt; name in visitors)</code>.</li>

<li>Compiler flag that disables variable reassignments in compile-time for less errors. Works like ES6 <code>const</code>, but it compiles to <code>var</code>, because <code>const</code> isn’t supported greatly by engines today.</li>

<li>Improved scoping. <code>=</code> always declares variable in current scope, use <code>:=</code> for redeclaration of outer scope var, which reduces bugs.</li>

<li>Improved operators associativity. <code>unique pulls .length</code> will execute <code>unique</code> and then get <code>.length</code> property of result, unlike in coffeescript, which requires brackets. <code>unique node or not empty node</code> compiles to <code>unique(node) || !empty(node)</code> and not to <code>unique(node || !empty(node))</code>.</li>

<li>Real, ECMAScript 6 / Python / Haskell-style flattened list comprehensions. `[x ** y for x in [10, 20] for y in [2, 3]]` will create `[100, 1000, 400, 8000]` as it should.</li>

<li>Curried functions. <code>(a, b, c) --&gt; a * b * c</code> instead of <code>(a) -&gt; (b) -&gt; (c) -&gt; a * b * c</code>. Very useful for functional caching of stuff.</li>

<li>New idioms. Async callbacks flattening syntax: <code>error &lt;- fs.write-file path, data</code>. “Array of words” ruby idiom: <code>&lt;[one two three]&gt;</code> vs <code>['one', 'two', 'three']</code>. <code>is not</code> works like <code>isnt</code>, like in Python and unlike in Coffee <code>2 is not 4</code> is <code>2 !== 4</code> and not <code>2 === !4</code> and much more.</li>
</ol>

<p>In case you’ve already written some coffeescript code, there’s <a href="http://gkz.github.com/LiveScript/#coffee-to-ls">conversion guide</a>.</p>

<p>If you decided to write a web application with LiveScript,
I recommend to take a look at <a href="http://brunch.io/">Brunch</a>,
which "just works" and supports livescript without mess.</p>
